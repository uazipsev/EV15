Disassembly Listing for RouterPic
Generated From:
C:/Users/Igor/MPLABXProjects/RouterPic.X/dist/default/debug/RouterPic.X.debug.elf
Sep 21, 2014 7:58:06 AM

---  c:/users/igor/mplabxprojects/routerpic.x/queue.cpp  ------------------------------------------------
1:                   #include <xc.h>
2:                   #include <string.h>
3:                   #include "queue.h"
4:                   
5:                   struct dmaSettings
6:                   {
7:                       unsigned char *dma_array;
8:                       volatile unsigned int *dmacon;
9:                       unsigned int con_busy_mask;
10:                      unsigned int con_en_mask;
11:                      volatile unsigned int *dmasize;
12:                      volatile unsigned int *dmaecon;
13:                      unsigned int econ_force_mask;
14:                  };
15:                  
16:                  
17:                  // function runs to iniciate the queue system
18:                  // the function is handed all the tools it needs to work the dma for sending
19:                  
20:                  void Queue_handler::queue_begin(struct dmaSettings *_settings, int module_number)
21:                  {
9D000D64  27BDFFE8   ADDIU SP, SP, -24
9D000D68  AFBF0014   SW RA, 20(SP)
9D000D6C  AFBE0010   SW S8, 16(SP)
9D000D70  03A0F021   ADDU S8, SP, ZERO
9D000D74  AFC40018   SW A0, 24(S8)
9D000D78  AFC5001C   SW A1, 28(S8)
9D000D7C  AFC60020   SW A2, 32(S8)
22:                      dma_array = _settings[module_number].dma_array;
9D000D80  8FC20020   LW V0, 32(S8)
9D000D84  00021080   SLL V0, V0, 2
9D000D88  000218C0   SLL V1, V0, 3
9D000D8C  00621023   SUBU V0, V1, V0
9D000D90  8FC3001C   LW V1, 28(S8)
9D000D94  00621021   ADDU V0, V1, V0
9D000D98  8C430000   LW V1, 0(V0)
9D000D9C  8FC20018   LW V0, 24(S8)
9D000DA0  AC43041C   SW V1, 1052(V0)
23:                      dmacon = _settings[module_number].dmacon;
9D000DA4  8FC20020   LW V0, 32(S8)
9D000DA8  00021080   SLL V0, V0, 2
9D000DAC  000218C0   SLL V1, V0, 3
9D000DB0  00621023   SUBU V0, V1, V0
9D000DB4  8FC3001C   LW V1, 28(S8)
9D000DB8  00621021   ADDU V0, V1, V0
9D000DBC  8C430004   LW V1, 4(V0)
9D000DC0  8FC20018   LW V0, 24(S8)
9D000DC4  AC430420   SW V1, 1056(V0)
24:                      con_busy_mask = _settings[module_number].con_busy_mask;
9D000DC8  8FC20020   LW V0, 32(S8)
9D000DCC  00021080   SLL V0, V0, 2
9D000DD0  000218C0   SLL V1, V0, 3
9D000DD4  00621023   SUBU V0, V1, V0
9D000DD8  8FC3001C   LW V1, 28(S8)
9D000DDC  00621021   ADDU V0, V1, V0
9D000DE0  8C430008   LW V1, 8(V0)
9D000DE4  8FC20018   LW V0, 24(S8)
9D000DE8  AC430424   SW V1, 1060(V0)
25:                      dmasize = _settings[module_number].dmasize;
9D000DEC  8FC20020   LW V0, 32(S8)
9D000DF0  00021080   SLL V0, V0, 2
9D000DF4  000218C0   SLL V1, V0, 3
9D000DF8  00621023   SUBU V0, V1, V0
9D000DFC  8FC3001C   LW V1, 28(S8)
9D000E00  00621021   ADDU V0, V1, V0
9D000E04  8C430010   LW V1, 16(V0)
9D000E08  8FC20018   LW V0, 24(S8)
9D000E0C  AC43042C   SW V1, 1068(V0)
26:                      dmaecon = _settings[module_number].dmaecon;
9D000E10  8FC20020   LW V0, 32(S8)
9D000E14  00021080   SLL V0, V0, 2
9D000E18  000218C0   SLL V1, V0, 3
9D000E1C  00621023   SUBU V0, V1, V0
9D000E20  8FC3001C   LW V1, 28(S8)
9D000E24  00621021   ADDU V0, V1, V0
9D000E28  8C430014   LW V1, 20(V0)
9D000E2C  8FC20018   LW V0, 24(S8)
9D000E30  AC430430   SW V1, 1072(V0)
27:                      econ_force_mask = _settings[module_number].econ_force_mask;
9D000E34  8FC20020   LW V0, 32(S8)
9D000E38  00021080   SLL V0, V0, 2
9D000E3C  000218C0   SLL V1, V0, 3
9D000E40  00621023   SUBU V0, V1, V0
9D000E44  8FC3001C   LW V1, 28(S8)
9D000E48  00621021   ADDU V0, V1, V0
9D000E4C  8C430018   LW V1, 24(V0)
9D000E50  8FC20018   LW V0, 24(S8)
9D000E54  AC430434   SW V1, 1076(V0)
28:                      module_ID = module_number;
9D000E58  8FC20018   LW V0, 24(S8)
9D000E5C  8FC30020   LW V1, 32(S8)
9D000E60  AC430438   SW V1, 1080(V0)
29:                      queue_init();
9D000E64  8FC40018   LW A0, 24(S8)
9D000E68  0F4003A2   JAL 0x9D000E88
9D000E6C  00000000   NOP
30:                  }
9D000E70  03C0E821   ADDU SP, S8, ZERO
9D000E74  8FBF0014   LW RA, 20(SP)
9D000E78  8FBE0010   LW S8, 16(SP)
9D000E7C  27BD0018   ADDIU SP, SP, 24
9D000E80  03E00008   JR RA
9D000E84  00000000   NOP
31:                  
32:                  void Queue_handler::queue_init(void)
33:                  {
9D000E88  27BDFFE0   ADDIU SP, SP, -32
9D000E8C  AFBF001C   SW RA, 28(SP)
9D000E90  AFBE0018   SW S8, 24(SP)
9D000E94  03A0F021   ADDU S8, SP, ZERO
9D000E98  AFC40020   SW A0, 32(S8)
34:                      send_queue.head = 0;
9D000E9C  8FC20020   LW V0, 32(S8)
9D000EA0  AC400410   SW ZERO, 1040(V0)
35:                      send_queue.tail = 0;
9D000EA4  8FC20020   LW V0, 32(S8)
9D000EA8  AC400414   SW ZERO, 1044(V0)
36:                      send_queue.count = 0;
9D000EAC  8FC20020   LW V0, 32(S8)
9D000EB0  AC400418   SW ZERO, 1048(V0)
37:                      int i;
38:                      for (i = 0; i < TOP_LEVEL_QUEUE_DEPTH; i++)
9D000EB4  AFC00010   SW ZERO, 16(S8)
9D000EB8  0B4003E3   J 0x9D000F8C
9D000EBC  00000000   NOP
9D000F80  8FC20010   LW V0, 16(S8)
9D000F84  24420001   ADDIU V0, V0, 1
9D000F88  AFC20010   SW V0, 16(S8)
9D000F8C  8FC20010   LW V0, 16(S8)
9D000F90  28420005   SLTI V0, V0, 5
9D000F94  304200FF   ANDI V0, V0, 255
9D000F98  1440FFC9   BNE V0, ZERO, 0x9D000EC0
9D000F9C  00000000   NOP
39:                      {
40:                          send_queue.queue[i].count = 0;
9D000EC0  8FC50020   LW A1, 32(S8)
9D000EC4  8FC40010   LW A0, 16(S8)
9D000EC8  00801821   ADDU V1, A0, ZERO
9D000ECC  00031080   SLL V0, V1, 2
9D000ED0  00401821   ADDU V1, V0, ZERO
9D000ED4  00031080   SLL V0, V1, 2
9D000ED8  00431023   SUBU V0, V0, V1
9D000EDC  00441021   ADDU V0, V0, A0
9D000EE0  00021100   SLL V0, V0, 4
9D000EE4  00A21021   ADDU V0, A1, V0
9D000EE8  AC4000CC   SW ZERO, 204(V0)
41:                          send_queue.queue[i].head = 0;
9D000EEC  8FC50020   LW A1, 32(S8)
9D000EF0  8FC40010   LW A0, 16(S8)
9D000EF4  00801821   ADDU V1, A0, ZERO
9D000EF8  00031080   SLL V0, V1, 2
9D000EFC  00401821   ADDU V1, V0, ZERO
9D000F00  00031080   SLL V0, V1, 2
9D000F04  00431023   SUBU V0, V0, V1
9D000F08  00441021   ADDU V0, V0, A0
9D000F0C  00021100   SLL V0, V0, 4
9D000F10  00A21021   ADDU V0, A1, V0
9D000F14  AC4000C4   SW ZERO, 196(V0)
42:                          send_queue.queue[i].tail = 0;
9D000F18  8FC50020   LW A1, 32(S8)
9D000F1C  8FC40010   LW A0, 16(S8)
9D000F20  00801821   ADDU V1, A0, ZERO
9D000F24  00031080   SLL V0, V1, 2
9D000F28  00401821   ADDU V1, V0, ZERO
9D000F2C  00031080   SLL V0, V1, 2
9D000F30  00431023   SUBU V0, V0, V1
9D000F34  00441021   ADDU V0, V0, A0
9D000F38  00021100   SLL V0, V0, 4
9D000F3C  00A21021   ADDU V0, A1, V0
9D000F40  AC4000C8   SW ZERO, 200(V0)
43:                          memset(send_queue.queue[i].buf, 0, SECOND_LEVEL_QUEUE_DEPTH);
9D000F44  8FC40010   LW A0, 16(S8)
9D000F48  00801821   ADDU V1, A0, ZERO
9D000F4C  00031080   SLL V0, V1, 2
9D000F50  00401821   ADDU V1, V0, ZERO
9D000F54  00031080   SLL V0, V1, 2
9D000F58  00431023   SUBU V0, V0, V1
9D000F5C  00441021   ADDU V0, V0, A0
9D000F60  00021100   SLL V0, V0, 4
9D000F64  8FC30020   LW V1, 32(S8)
9D000F68  00621021   ADDU V0, V1, V0
9D000F6C  00402021   ADDU A0, V0, ZERO
9D000F70  00002821   ADDU A1, ZERO, ZERO
9D000F74  240600C1   ADDIU A2, ZERO, 193
9D000F78  0F400DE1   JAL memset
9D000F7C  00000000   NOP
44:                      }
45:                  
46:                  }
9D000FA0  03C0E821   ADDU SP, S8, ZERO
9D000FA4  8FBF001C   LW RA, 28(SP)
9D000FA8  8FBE0018   LW S8, 24(SP)
9D000FAC  27BD0020   ADDIU SP, SP, 32
9D000FB0  03E00008   JR RA
9D000FB4  00000000   NOP
47:                  
48:                  void Queue_handler::queue_put(unsigned char * what, unsigned char how_many, unsigned char where, unsigned char from_where)
49:                  {
9D000FB8  27BDFFD8   ADDIU SP, SP, -40
9D000FBC  AFBF0024   SW RA, 36(SP)
9D000FC0  AFBE0020   SW S8, 32(SP)
9D000FC4  03A0F021   ADDU S8, SP, ZERO
9D000FC8  AFC40028   SW A0, 40(S8)
9D000FCC  AFC5002C   SW A1, 44(S8)
9D000FD0  00C02021   ADDU A0, A2, ZERO
9D000FD4  00E01821   ADDU V1, A3, ZERO
9D000FD8  8FC20038   LW V0, 56(S8)
9D000FDC  A3C40030   SB A0, 48(S8)
9D000FE0  A3C30034   SB V1, 52(S8)
9D000FE4  A3C20018   SB V0, 24(S8)
50:                      if (send_queue.count < TOP_LEVEL_QUEUE_DEPTH)
9D000FE8  8FC20028   LW V0, 40(S8)
9D000FEC  8C420418   LW V0, 1048(V0)
9D000FF0  28420005   SLTI V0, V0, 5
9D000FF4  1040003F   BEQ V0, ZERO, 0x9D0010F4
9D000FF8  00000000   NOP
51:                      {
52:                          queue_data_put(0x06);
9D000FFC  8FC40028   LW A0, 40(S8)
9D001000  24050006   ADDIU A1, ZERO, 6
9D001004  0F400483   JAL 0x9D00120C
9D001008  00000000   NOP
53:                          queue_data_put(0x85);
9D00100C  8FC40028   LW A0, 40(S8)
9D001010  24050085   ADDIU A1, ZERO, 133
9D001014  0F400483   JAL 0x9D00120C
9D001018  00000000   NOP
54:                          queue_data_put(where);
9D00101C  93C20034   LBU V0, 52(S8)
9D001020  8FC40028   LW A0, 40(S8)
9D001024  00402821   ADDU A1, V0, ZERO
9D001028  0F400483   JAL 0x9D00120C
9D00102C  00000000   NOP
55:                          queue_data_put(from_where);
9D001030  93C20018   LBU V0, 24(S8)
9D001034  8FC40028   LW A0, 40(S8)
9D001038  00402821   ADDU A1, V0, ZERO
9D00103C  0F400483   JAL 0x9D00120C
9D001040  00000000   NOP
56:                          queue_data_put(how_many);
9D001044  93C20030   LBU V0, 48(S8)
9D001048  8FC40028   LW A0, 40(S8)
9D00104C  00402821   ADDU A1, V0, ZERO
9D001050  0F400483   JAL 0x9D00120C
9D001054  00000000   NOP
57:                          int i;
58:                          for (i = 0; i <= (how_many + 1); i++)
9D001058  AFC00010   SW ZERO, 16(S8)
9D00105C  0B400424   J 0x9D001090
9D001060  00000000   NOP
9D001084  8FC20010   LW V0, 16(S8)
9D001088  24420001   ADDIU V0, V0, 1
9D00108C  AFC20010   SW V0, 16(S8)
9D001090  93C20030   LBU V0, 48(S8)
9D001094  24430001   ADDIU V1, V0, 1
9D001098  8FC20010   LW V0, 16(S8)
9D00109C  0062102A   SLT V0, V1, V0
9D0010A0  38420001   XORI V0, V0, 1
9D0010A4  304200FF   ANDI V0, V0, 255
9D0010A8  1440FFEE   BNE V0, ZERO, 0x9D001064
9D0010AC  00000000   NOP
59:                          {
60:                              queue_data_put(what[i]);
9D001064  8FC20010   LW V0, 16(S8)
9D001068  8FC3002C   LW V1, 44(S8)
9D00106C  00621021   ADDU V0, V1, V0
9D001070  90420000   LBU V0, 0(V0)
9D001074  8FC40028   LW A0, 40(S8)
9D001078  00402821   ADDU A1, V0, ZERO
9D00107C  0F400483   JAL 0x9D00120C
9D001080  00000000   NOP
61:                          }
62:                          send_queue.head = modulo_inc(send_queue.head, TOP_LEVEL_QUEUE_DEPTH);
9D0010B0  8FC20028   LW V0, 40(S8)
9D0010B4  8C420410   LW V0, 1040(V0)
9D0010B8  8FC40028   LW A0, 40(S8)
9D0010BC  00402821   ADDU A1, V0, ZERO
9D0010C0  24060005   ADDIU A2, ZERO, 5
9D0010C4  0F4005B2   JAL 0x9D0016C8
9D0010C8  00000000   NOP
9D0010CC  00401821   ADDU V1, V0, ZERO
9D0010D0  8FC20028   LW V0, 40(S8)
9D0010D4  AC430410   SW V1, 1040(V0)
63:                          send_queue.count++;
9D0010D8  8FC20028   LW V0, 40(S8)
9D0010DC  8C420418   LW V0, 1048(V0)
9D0010E0  24430001   ADDIU V1, V0, 1
9D0010E4  8FC20028   LW V0, 40(S8)
9D0010E8  AC430418   SW V1, 1048(V0)
9D0010EC  0B40047D   J 0x9D0011F4
9D0010F0  00000000   NOP
64:                      } else
65:                      {
66:                          queue_data_put(0x06);
9D0010F4  8FC40028   LW A0, 40(S8)
9D0010F8  24050006   ADDIU A1, ZERO, 6
9D0010FC  0F400483   JAL 0x9D00120C
9D001100  00000000   NOP
67:                          queue_data_put(0x85);
9D001104  8FC40028   LW A0, 40(S8)
9D001108  24050085   ADDIU A1, ZERO, 133
9D00110C  0F400483   JAL 0x9D00120C
9D001110  00000000   NOP
68:                          queue_data_put(where);
9D001114  93C20034   LBU V0, 52(S8)
9D001118  8FC40028   LW A0, 40(S8)
9D00111C  00402821   ADDU A1, V0, ZERO
9D001120  0F400483   JAL 0x9D00120C
9D001124  00000000   NOP
69:                          queue_data_put(from_where);
9D001128  93C20018   LBU V0, 24(S8)
9D00112C  8FC40028   LW A0, 40(S8)
9D001130  00402821   ADDU A1, V0, ZERO
9D001134  0F400483   JAL 0x9D00120C
9D001138  00000000   NOP
70:                          queue_data_put(how_many);
9D00113C  93C20030   LBU V0, 48(S8)
9D001140  8FC40028   LW A0, 40(S8)
9D001144  00402821   ADDU A1, V0, ZERO
9D001148  0F400483   JAL 0x9D00120C
9D00114C  00000000   NOP
71:                          int i;
72:                          for (i = 0; i <= how_many; i++)
9D001150  AFC00014   SW ZERO, 20(S8)
9D001154  0B400462   J 0x9D001188
9D001158  00000000   NOP
9D00117C  8FC20014   LW V0, 20(S8)
9D001180  24420001   ADDIU V0, V0, 1
9D001184  AFC20014   SW V0, 20(S8)
9D001188  93C30030   LBU V1, 48(S8)
9D00118C  8FC20014   LW V0, 20(S8)
9D001190  0062102A   SLT V0, V1, V0
9D001194  38420001   XORI V0, V0, 1
9D001198  304200FF   ANDI V0, V0, 255
9D00119C  1440FFEF   BNE V0, ZERO, 0x9D00115C
9D0011A0  00000000   NOP
73:                          {
74:                              queue_data_put(what[i]);
9D00115C  8FC20014   LW V0, 20(S8)
9D001160  8FC3002C   LW V1, 44(S8)
9D001164  00621021   ADDU V0, V1, V0
9D001168  90420000   LBU V0, 0(V0)
9D00116C  8FC40028   LW A0, 40(S8)
9D001170  00402821   ADDU A1, V0, ZERO
9D001174  0F400483   JAL 0x9D00120C
9D001178  00000000   NOP
75:                          }
76:                          send_queue.head = modulo_inc(send_queue.head, TOP_LEVEL_QUEUE_DEPTH);
9D0011A4  8FC20028   LW V0, 40(S8)
9D0011A8  8C420410   LW V0, 1040(V0)
9D0011AC  8FC40028   LW A0, 40(S8)
9D0011B0  00402821   ADDU A1, V0, ZERO
9D0011B4  24060005   ADDIU A2, ZERO, 5
9D0011B8  0F4005B2   JAL 0x9D0016C8
9D0011BC  00000000   NOP
9D0011C0  00401821   ADDU V1, V0, ZERO
9D0011C4  8FC20028   LW V0, 40(S8)
9D0011C8  AC430410   SW V1, 1040(V0)
77:                          send_queue.tail = modulo_inc(send_queue.tail, TOP_LEVEL_QUEUE_DEPTH);
9D0011CC  8FC20028   LW V0, 40(S8)
9D0011D0  8C420414   LW V0, 1044(V0)
9D0011D4  8FC40028   LW A0, 40(S8)
9D0011D8  00402821   ADDU A1, V0, ZERO
9D0011DC  24060005   ADDIU A2, ZERO, 5
9D0011E0  0F4005B2   JAL 0x9D0016C8
9D0011E4  00000000   NOP
9D0011E8  00401821   ADDU V1, V0, ZERO
9D0011EC  8FC20028   LW V0, 40(S8)
9D0011F0  AC430414   SW V1, 1044(V0)
78:                      }
79:                  }
9D0011F4  03C0E821   ADDU SP, S8, ZERO
9D0011F8  8FBF0024   LW RA, 36(SP)
9D0011FC  8FBE0020   LW S8, 32(SP)
9D001200  27BD0028   ADDIU SP, SP, 40
9D001204  03E00008   JR RA
9D001208  00000000   NOP
80:                  
81:                  void Queue_handler::queue_data_put(unsigned char data)
82:                  {
9D00120C  27BDFFE0   ADDIU SP, SP, -32
9D001210  AFBF001C   SW RA, 28(SP)
9D001214  AFBE0018   SW S8, 24(SP)
9D001218  AFB00014   SW S0, 20(SP)
9D00121C  03A0F021   ADDU S8, SP, ZERO
9D001220  AFC40020   SW A0, 32(S8)
9D001224  00A01021   ADDU V0, A1, ZERO
9D001228  A3C20024   SB V0, 36(S8)
83:                      if (send_queue.queue[send_queue.head].count < SECOND_LEVEL_QUEUE_DEPTH)
9D00122C  8FC20020   LW V0, 32(S8)
9D001230  8C440410   LW A0, 1040(V0)
9D001234  8FC50020   LW A1, 32(S8)
9D001238  00801821   ADDU V1, A0, ZERO
9D00123C  00031080   SLL V0, V1, 2
9D001240  00401821   ADDU V1, V0, ZERO
9D001244  00031080   SLL V0, V1, 2
9D001248  00431023   SUBU V0, V0, V1
9D00124C  00441021   ADDU V0, V0, A0
9D001250  00021100   SLL V0, V0, 4
9D001254  00A21021   ADDU V0, A1, V0
9D001258  8C4200CC   LW V0, 204(V0)
9D00125C  284200C1   SLTI V0, V0, 193
9D001260  10400052   BEQ V0, ZERO, 0x9D0013AC
9D001264  00000000   NOP
84:                      {
85:                          send_queue.queue[send_queue.head].buf[send_queue.queue[send_queue.head].head] = data;
9D001268  8FC20020   LW V0, 32(S8)
9D00126C  8C440410   LW A0, 1040(V0)
9D001270  8FC20020   LW V0, 32(S8)
9D001274  8C450410   LW A1, 1040(V0)
9D001278  8FC60020   LW A2, 32(S8)
9D00127C  00A01821   ADDU V1, A1, ZERO
9D001280  00031080   SLL V0, V1, 2
9D001284  00401821   ADDU V1, V0, ZERO
9D001288  00031080   SLL V0, V1, 2
9D00128C  00431023   SUBU V0, V0, V1
9D001290  00451021   ADDU V0, V0, A1
9D001294  00021100   SLL V0, V0, 4
9D001298  00C21021   ADDU V0, A2, V0
9D00129C  8C4600C4   LW A2, 196(V0)
9D0012A0  8FC50020   LW A1, 32(S8)
9D0012A4  00801821   ADDU V1, A0, ZERO
9D0012A8  00031080   SLL V0, V1, 2
9D0012AC  00401821   ADDU V1, V0, ZERO
9D0012B0  00031080   SLL V0, V1, 2
9D0012B4  00431023   SUBU V0, V0, V1
9D0012B8  00441021   ADDU V0, V0, A0
9D0012BC  00021100   SLL V0, V0, 4
9D0012C0  00461021   ADDU V0, V0, A2
9D0012C4  00A21021   ADDU V0, A1, V0
9D0012C8  93C30024   LBU V1, 36(S8)
9D0012CC  A0430000   SB V1, 0(V0)
86:                          send_queue.queue[send_queue.head].head = modulo_inc(send_queue.queue[send_queue.head].head, SECOND_LEVEL_QUEUE_DEPTH);
9D0012D0  8FC20020   LW V0, 32(S8)
9D0012D4  8C500410   LW S0, 1040(V0)
9D0012D8  8FC20020   LW V0, 32(S8)
9D0012DC  8C440410   LW A0, 1040(V0)
9D0012E0  8FC50020   LW A1, 32(S8)
9D0012E4  00801821   ADDU V1, A0, ZERO
9D0012E8  00031080   SLL V0, V1, 2
9D0012EC  00401821   ADDU V1, V0, ZERO
9D0012F0  00031080   SLL V0, V1, 2
9D0012F4  00431023   SUBU V0, V0, V1
9D0012F8  00441021   ADDU V0, V0, A0
9D0012FC  00021100   SLL V0, V0, 4
9D001300  00A21021   ADDU V0, A1, V0
9D001304  8C4200C4   LW V0, 196(V0)
9D001308  8FC40020   LW A0, 32(S8)
9D00130C  00402821   ADDU A1, V0, ZERO
9D001310  240600C1   ADDIU A2, ZERO, 193
9D001314  0F4005B2   JAL 0x9D0016C8
9D001318  00000000   NOP
9D00131C  00402021   ADDU A0, V0, ZERO
9D001320  8FC50020   LW A1, 32(S8)
9D001324  02001821   ADDU V1, S0, ZERO
9D001328  00031080   SLL V0, V1, 2
9D00132C  00401821   ADDU V1, V0, ZERO
9D001330  00031080   SLL V0, V1, 2
9D001334  00431023   SUBU V0, V0, V1
9D001338  00501021   ADDU V0, V0, S0
9D00133C  00021100   SLL V0, V0, 4
9D001340  00A21021   ADDU V0, A1, V0
9D001344  AC4400C4   SW A0, 196(V0)
87:                          send_queue.queue[send_queue.head].count++;
9D001348  8FC20020   LW V0, 32(S8)
9D00134C  8C430410   LW V1, 1040(V0)
9D001350  8FC50020   LW A1, 32(S8)
9D001354  00602021   ADDU A0, V1, ZERO
9D001358  00041080   SLL V0, A0, 2
9D00135C  00402021   ADDU A0, V0, ZERO
9D001360  00041080   SLL V0, A0, 2
9D001364  00441023   SUBU V0, V0, A0
9D001368  00431021   ADDU V0, V0, V1
9D00136C  00021100   SLL V0, V0, 4
9D001370  00A21021   ADDU V0, A1, V0
9D001374  8C4200CC   LW V0, 204(V0)
9D001378  24450001   ADDIU A1, V0, 1
9D00137C  8FC60020   LW A2, 32(S8)
9D001380  00602021   ADDU A0, V1, ZERO
9D001384  00041080   SLL V0, A0, 2
9D001388  00402021   ADDU A0, V0, ZERO
9D00138C  00041080   SLL V0, A0, 2
9D001390  00441023   SUBU V0, V0, A0
9D001394  00431021   ADDU V0, V0, V1
9D001398  00021100   SLL V0, V0, 4
9D00139C  00C21021   ADDU V0, A2, V0
9D0013A0  AC4500CC   SW A1, 204(V0)
9D0013A4  0B400541   J 0x9D001504
9D0013A8  00000000   NOP
88:                      } else
89:                      {
90:                          send_queue.queue[send_queue.head].buf[send_queue.queue[send_queue.head].head] = data;
9D0013AC  8FC20020   LW V0, 32(S8)
9D0013B0  8C440410   LW A0, 1040(V0)
9D0013B4  8FC20020   LW V0, 32(S8)
9D0013B8  8C450410   LW A1, 1040(V0)
9D0013BC  8FC60020   LW A2, 32(S8)
9D0013C0  00A01821   ADDU V1, A1, ZERO
9D0013C4  00031080   SLL V0, V1, 2
9D0013C8  00401821   ADDU V1, V0, ZERO
9D0013CC  00031080   SLL V0, V1, 2
9D0013D0  00431023   SUBU V0, V0, V1
9D0013D4  00451021   ADDU V0, V0, A1
9D0013D8  00021100   SLL V0, V0, 4
9D0013DC  00C21021   ADDU V0, A2, V0
9D0013E0  8C4600C4   LW A2, 196(V0)
9D0013E4  8FC50020   LW A1, 32(S8)
9D0013E8  00801821   ADDU V1, A0, ZERO
9D0013EC  00031080   SLL V0, V1, 2
9D0013F0  00401821   ADDU V1, V0, ZERO
9D0013F4  00031080   SLL V0, V1, 2
9D0013F8  00431023   SUBU V0, V0, V1
9D0013FC  00441021   ADDU V0, V0, A0
9D001400  00021100   SLL V0, V0, 4
9D001404  00461021   ADDU V0, V0, A2
9D001408  00A21021   ADDU V0, A1, V0
9D00140C  93C30024   LBU V1, 36(S8)
9D001410  A0430000   SB V1, 0(V0)
91:                          send_queue.queue[send_queue.head].head = modulo_inc(send_queue.queue[send_queue.head].head, SECOND_LEVEL_QUEUE_DEPTH);
9D001414  8FC20020   LW V0, 32(S8)
9D001418  8C500410   LW S0, 1040(V0)
9D00141C  8FC20020   LW V0, 32(S8)
9D001420  8C440410   LW A0, 1040(V0)
9D001424  8FC50020   LW A1, 32(S8)
9D001428  00801821   ADDU V1, A0, ZERO
9D00142C  00031080   SLL V0, V1, 2
9D001430  00401821   ADDU V1, V0, ZERO
9D001434  00031080   SLL V0, V1, 2
9D001438  00431023   SUBU V0, V0, V1
9D00143C  00441021   ADDU V0, V0, A0
9D001440  00021100   SLL V0, V0, 4
9D001444  00A21021   ADDU V0, A1, V0
9D001448  8C4200C4   LW V0, 196(V0)
9D00144C  8FC40020   LW A0, 32(S8)
9D001450  00402821   ADDU A1, V0, ZERO
9D001454  240600C1   ADDIU A2, ZERO, 193
9D001458  0F4005B2   JAL 0x9D0016C8
9D00145C  00000000   NOP
9D001460  00402021   ADDU A0, V0, ZERO
9D001464  8FC50020   LW A1, 32(S8)
9D001468  02001821   ADDU V1, S0, ZERO
9D00146C  00031080   SLL V0, V1, 2
9D001470  00401821   ADDU V1, V0, ZERO
9D001474  00031080   SLL V0, V1, 2
9D001478  00431023   SUBU V0, V0, V1
9D00147C  00501021   ADDU V0, V0, S0
9D001480  00021100   SLL V0, V0, 4
9D001484  00A21021   ADDU V0, A1, V0
9D001488  AC4400C4   SW A0, 196(V0)
92:                          send_queue.queue[send_queue.head].tail = modulo_inc(send_queue.queue[send_queue.head].tail, SECOND_LEVEL_QUEUE_DEPTH);
9D00148C  8FC20020   LW V0, 32(S8)
9D001490  8C500410   LW S0, 1040(V0)
9D001494  8FC20020   LW V0, 32(S8)
9D001498  8C440410   LW A0, 1040(V0)
9D00149C  8FC50020   LW A1, 32(S8)
9D0014A0  00801821   ADDU V1, A0, ZERO
9D0014A4  00031080   SLL V0, V1, 2
9D0014A8  00401821   ADDU V1, V0, ZERO
9D0014AC  00031080   SLL V0, V1, 2
9D0014B0  00431023   SUBU V0, V0, V1
9D0014B4  00441021   ADDU V0, V0, A0
9D0014B8  00021100   SLL V0, V0, 4
9D0014BC  00A21021   ADDU V0, A1, V0
9D0014C0  8C4200C8   LW V0, 200(V0)
9D0014C4  8FC40020   LW A0, 32(S8)
9D0014C8  00402821   ADDU A1, V0, ZERO
9D0014CC  240600C1   ADDIU A2, ZERO, 193
9D0014D0  0F4005B2   JAL 0x9D0016C8
9D0014D4  00000000   NOP
9D0014D8  00402021   ADDU A0, V0, ZERO
9D0014DC  8FC50020   LW A1, 32(S8)
9D0014E0  02001821   ADDU V1, S0, ZERO
9D0014E4  00031080   SLL V0, V1, 2
9D0014E8  00401821   ADDU V1, V0, ZERO
9D0014EC  00031080   SLL V0, V1, 2
9D0014F0  00431023   SUBU V0, V0, V1
9D0014F4  00501021   ADDU V0, V0, S0
9D0014F8  00021100   SLL V0, V0, 4
9D0014FC  00A21021   ADDU V0, A1, V0
9D001500  AC4400C8   SW A0, 200(V0)
93:                      }
94:                  }
9D001504  03C0E821   ADDU SP, S8, ZERO
9D001508  8FBF001C   LW RA, 28(SP)
9D00150C  8FBE0018   LW S8, 24(SP)
9D001510  8FB00014   LW S0, 20(SP)
9D001514  27BD0020   ADDIU SP, SP, 32
9D001518  03E00008   JR RA
9D00151C  00000000   NOP
95:                  
96:                  unsigned char Queue_handler::queue_data_get(void)
97:                  {
9D001520  27BDFFF0   ADDIU SP, SP, -16
9D001524  AFBE000C   SW S8, 12(SP)
9D001528  03A0F021   ADDU S8, SP, ZERO
9D00152C  AFC40010   SW A0, 16(S8)
98:                      unsigned char dat;
99:                      if (send_queue.count > 0)
9D001530  8FC20010   LW V0, 16(S8)
9D001534  8C420418   LW V0, 1048(V0)
9D001538  1840005C   BLEZ V0, 0x9D0016AC
9D00153C  00000000   NOP
100:                     {
101:                         if (send_queue.queue[send_queue.tail].count > 0)
9D001540  8FC20010   LW V0, 16(S8)
9D001544  8C440414   LW A0, 1044(V0)
9D001548  8FC50010   LW A1, 16(S8)
9D00154C  00801821   ADDU V1, A0, ZERO
9D001550  00031080   SLL V0, V1, 2
9D001554  00401821   ADDU V1, V0, ZERO
9D001558  00031080   SLL V0, V1, 2
9D00155C  00431023   SUBU V0, V0, V1
9D001560  00441021   ADDU V0, V0, A0
9D001564  00021100   SLL V0, V0, 4
9D001568  00A21021   ADDU V0, A1, V0
9D00156C  8C4200CC   LW V0, 204(V0)
9D001570  1840004B   BLEZ V0, 0x9D0016A0
9D001574  00000000   NOP
102:                         {
103:                             dat = send_queue.queue[send_queue.tail].buf[send_queue.queue[send_queue.tail].tail];
9D001578  8FC20010   LW V0, 16(S8)
9D00157C  8C440414   LW A0, 1044(V0)
9D001580  8FC20010   LW V0, 16(S8)
9D001584  8C450414   LW A1, 1044(V0)
9D001588  8FC60010   LW A2, 16(S8)
9D00158C  00A01821   ADDU V1, A1, ZERO
9D001590  00031080   SLL V0, V1, 2
9D001594  00401821   ADDU V1, V0, ZERO
9D001598  00031080   SLL V0, V1, 2
9D00159C  00431023   SUBU V0, V0, V1
9D0015A0  00451021   ADDU V0, V0, A1
9D0015A4  00021100   SLL V0, V0, 4
9D0015A8  00C21021   ADDU V0, A2, V0
9D0015AC  8C4600C8   LW A2, 200(V0)
9D0015B0  8FC50010   LW A1, 16(S8)
9D0015B4  00801821   ADDU V1, A0, ZERO
9D0015B8  00031080   SLL V0, V1, 2
9D0015BC  00401821   ADDU V1, V0, ZERO
9D0015C0  00031080   SLL V0, V1, 2
9D0015C4  00431023   SUBU V0, V0, V1
9D0015C8  00441021   ADDU V0, V0, A0
9D0015CC  00021100   SLL V0, V0, 4
9D0015D0  00461021   ADDU V0, V0, A2
9D0015D4  00A21021   ADDU V0, A1, V0
9D0015D8  90420000   LBU V0, 0(V0)
9D0015DC  A3C20000   SB V0, 0(S8)
104:                             send_queue.queue[send_queue.tail].tail--;
9D0015E0  8FC20010   LW V0, 16(S8)
9D0015E4  8C430414   LW V1, 1044(V0)
9D0015E8  8FC50010   LW A1, 16(S8)
9D0015EC  00602021   ADDU A0, V1, ZERO
9D0015F0  00041080   SLL V0, A0, 2
9D0015F4  00402021   ADDU A0, V0, ZERO
9D0015F8  00041080   SLL V0, A0, 2
9D0015FC  00441023   SUBU V0, V0, A0
9D001600  00431021   ADDU V0, V0, V1
9D001604  00021100   SLL V0, V0, 4
9D001608  00A21021   ADDU V0, A1, V0
9D00160C  8C4200C8   LW V0, 200(V0)
9D001610  2445FFFF   ADDIU A1, V0, -1
9D001614  8FC60010   LW A2, 16(S8)
9D001618  00602021   ADDU A0, V1, ZERO
9D00161C  00041080   SLL V0, A0, 2
9D001620  00402021   ADDU A0, V0, ZERO
9D001624  00041080   SLL V0, A0, 2
9D001628  00441023   SUBU V0, V0, A0
9D00162C  00431021   ADDU V0, V0, V1
9D001630  00021100   SLL V0, V0, 4
9D001634  00C21021   ADDU V0, A2, V0
9D001638  AC4500C8   SW A1, 200(V0)
105:                             send_queue.queue[send_queue.tail].count--;
9D00163C  8FC20010   LW V0, 16(S8)
9D001640  8C430414   LW V1, 1044(V0)
9D001644  8FC50010   LW A1, 16(S8)
9D001648  00602021   ADDU A0, V1, ZERO
9D00164C  00041080   SLL V0, A0, 2
9D001650  00402021   ADDU A0, V0, ZERO
9D001654  00041080   SLL V0, A0, 2
9D001658  00441023   SUBU V0, V0, A0
9D00165C  00431021   ADDU V0, V0, V1
9D001660  00021100   SLL V0, V0, 4
9D001664  00A21021   ADDU V0, A1, V0
9D001668  8C4200CC   LW V0, 204(V0)
9D00166C  2445FFFF   ADDIU A1, V0, -1
9D001670  8FC60010   LW A2, 16(S8)
9D001674  00602021   ADDU A0, V1, ZERO
9D001678  00041080   SLL V0, A0, 2
9D00167C  00402021   ADDU A0, V0, ZERO
9D001680  00041080   SLL V0, A0, 2
9D001684  00441023   SUBU V0, V0, A0
9D001688  00431021   ADDU V0, V0, V1
9D00168C  00021100   SLL V0, V0, 4
9D001690  00C21021   ADDU V0, A2, V0
9D001694  AC4500CC   SW A1, 204(V0)
9D001698  0B4005AC   J 0x9D0016B0
9D00169C  00000000   NOP
106:                         } else
107:                         {
108:                             dat = 0;
9D0016A0  A3C00000   SB ZERO, 0(S8)
9D0016A4  0B4005AC   J 0x9D0016B0
9D0016A8  00000000   NOP
109:                         }
110:                     } else
111:                     {
112:                         dat = 0;
9D0016AC  A3C00000   SB ZERO, 0(S8)
113:                     }
114:                     return dat;
9D0016B0  93C20000   LBU V0, 0(S8)
115:                 }
9D0016B4  03C0E821   ADDU SP, S8, ZERO
9D0016B8  8FBE000C   LW S8, 12(SP)
9D0016BC  27BD0010   ADDIU SP, SP, 16
9D0016C0  03E00008   JR RA
9D0016C4  00000000   NOP
116:                 
117:                 unsigned int Queue_handler::modulo_inc(const unsigned int value, const unsigned int modulus)
118:                 {
9D0016C8  27BDFFF0   ADDIU SP, SP, -16
9D0016CC  AFBE000C   SW S8, 12(SP)
9D0016D0  03A0F021   ADDU S8, SP, ZERO
9D0016D4  AFC40010   SW A0, 16(S8)
9D0016D8  AFC50014   SW A1, 20(S8)
9D0016DC  AFC60018   SW A2, 24(S8)
119:                     unsigned int my_value = value + 1;
9D0016E0  8FC20014   LW V0, 20(S8)
9D0016E4  24420001   ADDIU V0, V0, 1
9D0016E8  AFC20000   SW V0, 0(S8)
120:                     if (my_value >= modulus)
9D0016EC  8FC30000   LW V1, 0(S8)
9D0016F0  8FC20018   LW V0, 24(S8)
9D0016F4  0062102B   SLTU V0, V1, V0
9D0016F8  14400002   BNE V0, ZERO, 0x9D001704
9D0016FC  00000000   NOP
121:                     {
122:                         my_value = 0;
9D001700  AFC00000   SW ZERO, 0(S8)
123:                     }
124:                     return (my_value);
9D001704  8FC20000   LW V0, 0(S8)
125:                 }
9D001708  03C0E821   ADDU SP, S8, ZERO
9D00170C  8FBE000C   LW S8, 12(SP)
9D001710  27BD0010   ADDIU SP, SP, 16
9D001714  03E00008   JR RA
9D001718  00000000   NOP
126:                 
127:                 bool Queue_handler::queue_send(void)
128:                 {
9D00171C  27BDFFE0   ADDIU SP, SP, -32
9D001720  AFBF001C   SW RA, 28(SP)
9D001724  AFBE0018   SW S8, 24(SP)
9D001728  03A0F021   ADDU S8, SP, ZERO
9D00172C  AFC40020   SW A0, 32(S8)
129:                     if (send_queue.count > 0) // if send queue is empty no need to send
9D001730  8FC20020   LW V0, 32(S8)
9D001734  8C420418   LW V0, 1048(V0)
9D001738  1840008D   BLEZ V0, 0x9D001970
9D00173C  00000000   NOP
130:                     {
131:                         if ((*dmacon & con_busy_mask) == 0) // if dma is busy then no need to send
9D001740  8FC20020   LW V0, 32(S8)
9D001744  8C420420   LW V0, 1056(V0)
9D001748  8C430000   LW V1, 0(V0)
9D00174C  8FC20020   LW V0, 32(S8)
9D001750  8C420424   LW V0, 1060(V0)
9D001754  00621024   AND V0, V1, V0
9D001758  2C420001   SLTIU V0, V0, 1
9D00175C  304200FF   ANDI V0, V0, 255
9D001760  10400080   BEQ V0, ZERO, 0x9D001964
9D001764  00000000   NOP
132:                         {
133:                             // if all the checks pass populate the dma buffer, set the size, enable and force a send
134:                             int g;
135:                             int h = send_queue.queue[send_queue.tail].count;
9D001768  8FC20020   LW V0, 32(S8)
9D00176C  8C440414   LW A0, 1044(V0)
9D001770  8FC50020   LW A1, 32(S8)
9D001774  00801821   ADDU V1, A0, ZERO
9D001778  00031080   SLL V0, V1, 2
9D00177C  00401821   ADDU V1, V0, ZERO
9D001780  00031080   SLL V0, V1, 2
9D001784  00431023   SUBU V0, V0, V1
9D001788  00441021   ADDU V0, V0, A0
9D00178C  00021100   SLL V0, V0, 4
9D001790  00A21021   ADDU V0, A1, V0
9D001794  8C4200CC   LW V0, 204(V0)
9D001798  AFC20014   SW V0, 20(S8)
136:                             for (g = 0; g >= g; g++)
9D00179C  AFC00010   SW ZERO, 16(S8)
9D001950  8FC20010   LW V0, 16(S8)
9D001954  24420001   ADDIU V0, V0, 1
9D001958  AFC20010   SW V0, 16(S8)
9D00195C  0B4005E8   J 0x9D0017A0
9D001960  00000000   NOP
137:                             {
138:                                 dma_array[g] = send_queue.queue[send_queue.tail].buf[g];
9D0017A0  8FC20020   LW V0, 32(S8)
9D0017A4  8C43041C   LW V1, 1052(V0)
9D0017A8  8FC20010   LW V0, 16(S8)
9D0017AC  00622821   ADDU A1, V1, V0
9D0017B0  8FC20020   LW V0, 32(S8)
9D0017B4  8C440414   LW A0, 1044(V0)
9D0017B8  8FC60020   LW A2, 32(S8)
9D0017BC  00801821   ADDU V1, A0, ZERO
9D0017C0  00031080   SLL V0, V1, 2
9D0017C4  00401821   ADDU V1, V0, ZERO
9D0017C8  00031080   SLL V0, V1, 2
9D0017CC  00431023   SUBU V0, V0, V1
9D0017D0  00441021   ADDU V0, V0, A0
9D0017D4  00021100   SLL V0, V0, 4
9D0017D8  8FC30010   LW V1, 16(S8)
9D0017DC  00431021   ADDU V0, V0, V1
9D0017E0  00C21021   ADDU V0, A2, V0
9D0017E4  90420000   LBU V0, 0(V0)
9D0017E8  A0A20000   SB V0, 0(A1)
139:                                 *dmasize = h;
9D0017EC  8FC20020   LW V0, 32(S8)
9D0017F0  8C42042C   LW V0, 1068(V0)
9D0017F4  8FC30014   LW V1, 20(S8)
9D0017F8  AC430000   SW V1, 0(V0)
140:                                 *dmacon |= con_en_mask;
9D0017FC  8FC20020   LW V0, 32(S8)
9D001800  8C420420   LW V0, 1056(V0)
9D001804  8FC30020   LW V1, 32(S8)
9D001808  8C630420   LW V1, 1056(V1)
9D00180C  8C640000   LW A0, 0(V1)
9D001810  8FC30020   LW V1, 32(S8)
9D001814  8C630428   LW V1, 1064(V1)
9D001818  00831825   OR V1, A0, V1
9D00181C  AC430000   SW V1, 0(V0)
141:                                 *dmaecon |= econ_force_mask;
9D001820  8FC20020   LW V0, 32(S8)
9D001824  8C420430   LW V0, 1072(V0)
9D001828  8FC30020   LW V1, 32(S8)
9D00182C  8C630430   LW V1, 1072(V1)
9D001830  8C640000   LW A0, 0(V1)
9D001834  8FC30020   LW V1, 32(S8)
9D001838  8C630434   LW V1, 1076(V1)
9D00183C  00831825   OR V1, A0, V1
9D001840  AC430000   SW V1, 0(V0)
142:                                 // flush send que
143:                                 send_queue.queue[send_queue.tail].count = 0;
9D001844  8FC20020   LW V0, 32(S8)
9D001848  8C440414   LW A0, 1044(V0)
9D00184C  8FC50020   LW A1, 32(S8)
9D001850  00801821   ADDU V1, A0, ZERO
9D001854  00031080   SLL V0, V1, 2
9D001858  00401821   ADDU V1, V0, ZERO
9D00185C  00031080   SLL V0, V1, 2
9D001860  00431023   SUBU V0, V0, V1
9D001864  00441021   ADDU V0, V0, A0
9D001868  00021100   SLL V0, V0, 4
9D00186C  00A21021   ADDU V0, A1, V0
9D001870  AC4000CC   SW ZERO, 204(V0)
144:                                 send_queue.queue[send_queue.tail].head = 0;
9D001874  8FC20020   LW V0, 32(S8)
9D001878  8C440414   LW A0, 1044(V0)
9D00187C  8FC50020   LW A1, 32(S8)
9D001880  00801821   ADDU V1, A0, ZERO
9D001884  00031080   SLL V0, V1, 2
9D001888  00401821   ADDU V1, V0, ZERO
9D00188C  00031080   SLL V0, V1, 2
9D001890  00431023   SUBU V0, V0, V1
9D001894  00441021   ADDU V0, V0, A0
9D001898  00021100   SLL V0, V0, 4
9D00189C  00A21021   ADDU V0, A1, V0
9D0018A0  AC4000C4   SW ZERO, 196(V0)
145:                                 send_queue.queue[send_queue.tail].tail = 0;
9D0018A4  8FC20020   LW V0, 32(S8)
9D0018A8  8C440414   LW A0, 1044(V0)
9D0018AC  8FC50020   LW A1, 32(S8)
9D0018B0  00801821   ADDU V1, A0, ZERO
9D0018B4  00031080   SLL V0, V1, 2
9D0018B8  00401821   ADDU V1, V0, ZERO
9D0018BC  00031080   SLL V0, V1, 2
9D0018C0  00431023   SUBU V0, V0, V1
9D0018C4  00441021   ADDU V0, V0, A0
9D0018C8  00021100   SLL V0, V0, 4
9D0018CC  00A21021   ADDU V0, A1, V0
9D0018D0  AC4000C8   SW ZERO, 200(V0)
146:                                 memset(send_queue.queue[send_queue.tail].buf, 0, SECOND_LEVEL_QUEUE_DEPTH);
9D0018D4  8FC20020   LW V0, 32(S8)
9D0018D8  8C440414   LW A0, 1044(V0)
9D0018DC  00801821   ADDU V1, A0, ZERO
9D0018E0  00031080   SLL V0, V1, 2
9D0018E4  00401821   ADDU V1, V0, ZERO
9D0018E8  00031080   SLL V0, V1, 2
9D0018EC  00431023   SUBU V0, V0, V1
9D0018F0  00441021   ADDU V0, V0, A0
9D0018F4  00021100   SLL V0, V0, 4
9D0018F8  8FC30020   LW V1, 32(S8)
9D0018FC  00621021   ADDU V0, V1, V0
9D001900  00402021   ADDU A0, V0, ZERO
9D001904  00002821   ADDU A1, ZERO, ZERO
9D001908  240600C1   ADDIU A2, ZERO, 193
9D00190C  0F400DE1   JAL memset
9D001910  00000000   NOP
147:                                 //tidy up tail and counter
148:                                 send_queue.count--;
9D001914  8FC20020   LW V0, 32(S8)
9D001918  8C420418   LW V0, 1048(V0)
9D00191C  2443FFFF   ADDIU V1, V0, -1
9D001920  8FC20020   LW V0, 32(S8)
9D001924  AC430418   SW V1, 1048(V0)
149:                                 send_queue.tail = modulo_inc(send_queue.tail, TOP_LEVEL_QUEUE_DEPTH);
9D001928  8FC20020   LW V0, 32(S8)
9D00192C  8C420414   LW V0, 1044(V0)
9D001930  8FC40020   LW A0, 32(S8)
9D001934  00402821   ADDU A1, V0, ZERO
9D001938  24060005   ADDIU A2, ZERO, 5
9D00193C  0F4005B2   JAL 0x9D0016C8
9D001940  00000000   NOP
9D001944  00401821   ADDU V1, V0, ZERO
9D001948  8FC20020   LW V0, 32(S8)
9D00194C  AC430414   SW V1, 1044(V0)
150:                 
151:                 
152:                             }
153:                         } else
154:                         {
155:                             return false;
9D001964  00001021   ADDU V0, ZERO, ZERO
9D001968  0B40065D   J 0x9D001974
9D00196C  00000000   NOP
156:                         }
157:                     } else
158:                     {
159:                         return false;
9D001970  00001021   ADDU V0, ZERO, ZERO
160:                     }
161:                 
162:                 }
9D001974  03C0E821   ADDU SP, S8, ZERO
9D001978  8FBF001C   LW RA, 28(SP)
9D00197C  8FBE0018   LW S8, 24(SP)
9D001980  27BD0020   ADDIU SP, SP, 32
9D001984  03E00008   JR RA
9D001988  00000000   NOP
---  c:/users/igor/mplabxprojects/routerpic.x/main.cpp  -------------------------------------------------
1:                   /* 
2:                    * File:   main.cpp
3:                    * Author: Igor
4:                    *
5:                    * Created on August 3, 2014, 7:09 AM
6:                    */
7:                   
8:                   
9:                   #include <xc.h>
10:                  #define _SUPPRESS_PLIB_WARNING
11:                  #include <plib.h>
12:                  #include "constants.h"
13:                  #include "main.h"
14:                  #include "initialize.h"
15:                  #include "queue.h"
16:                  #include "FastTransfer.h"
17:                  #include "variables.h"
18:                  
19:                  // PIC32MX575F512H Configuration Bit Settings
20:                  
21:                  // 'C' source line config statements
22:                  
23:                  // DEVCFG3
24:                  // USERID = No Setting
25:                  #pragma config FSRSSEL = PRIORITY_0     // SRS Select (SRS Priority 0)
26:                  #pragma config FCANIO = ON              // CAN I/O Pin Select (Default CAN I/O)
27:                  #pragma config FUSBIDIO = ON            // USB USID Selection (Controlled by the USB Module)
28:                  #pragma config FVBUSONIO = ON           // USB VBUS ON Selection (Controlled by USB Module)
29:                  
30:                  // DEVCFG2
31:                  #pragma config FPLLIDIV = DIV_2         // PLL Input Divider (2x Divider)
32:                  #pragma config FPLLMUL = MUL_20         // PLL Multiplier (20x Multiplier)
33:                  #pragma config UPLLIDIV = DIV_12        // USB PLL Input Divider (12x Divider)
34:                  #pragma config UPLLEN = OFF             // USB PLL Enable (Disabled and Bypassed)
35:                  #pragma config FPLLODIV = DIV_1         // System PLL Output Clock Divider (PLL Divide by 1)
36:                  
37:                  // DEVCFG1
38:                  #pragma config FNOSC = FRCPLL           // Oscillator Selection Bits (Fast RC Osc with PLL)
39:                  #pragma config FSOSCEN = OFF            // Secondary Oscillator Enable (Disabled)
40:                  #pragma config IESO = OFF               // Internal/External Switch Over (Disabled)
41:                  #pragma config POSCMOD = OFF            // Primary Oscillator Configuration (Primary osc disabled)
42:                  #pragma config OSCIOFNC = OFF           // CLKO Output Signal Active on the OSCO Pin (Disabled)
43:                  #pragma config FPBDIV = DIV_1           // Peripheral Clock Divisor (Pb_Clk is Sys_Clk/1)
44:                  #pragma config FCKSM = CSDCMD           // Clock Switching and Monitor Selection (Clock Switch Disable, FSCM Disabled)
45:                  #pragma config WDTPS = PS1048576        // Watchdog Timer Postscaler (1:1048576)
46:                  #pragma config FWDTEN = OFF             // Watchdog Timer Enable (WDT Disabled (SWDTEN Bit Controls))
47:                  
48:                  // DEVCFG0
49:                  #pragma config DEBUG = ON               // Background Debugger Enable (Debugger is enabled)
50:                  #pragma config ICESEL = ICS_PGx1        // ICE/ICD Comm Channel Select (ICE EMUC1/EMUD1 pins shared with PGC1/PGD1)
51:                  #pragma config PWP = OFF                // Program Flash Write Protect (Disable)
52:                  #pragma config BWP = OFF                // Boot Flash Write Protect bit (Protection Disabled)
53:                  #pragma config CP = OFF                 // Code Protect (Protection Disabled)
54:                  
55:                  
56:                  using namespace std;
57:                  
58:                  
59:                  int main(void)
60:                  {
9D003118  27BDFFE8   ADDIU SP, SP, -24
9D00311C  AFBF0014   SW RA, 20(SP)
9D003120  AFBE0010   SW S8, 16(SP)
9D003124  03A0F021   ADDU S8, SP, ZERO
61:                      initialize();
9D003128  0F400014   JAL 0x9D000050
9D00312C  00000000   NOP
62:                  
63:                      TRISEbits.TRISE4 = 0;
9D003130  3C03BF88   LUI V1, -16504
9D003134  8C626100   LW V0, 24832(V1)
9D003138  7C022104   INS V0, ZERO, 4, 1
9D00313C  AC626100   SW V0, 24832(V1)
64:                      TRISEbits.TRISE4 = 0;
9D003140  3C03BF88   LUI V1, -16504
9D003144  8C626100   LW V0, 24832(V1)
9D003148  7C022104   INS V0, ZERO, 4, 1
9D00314C  AC626100   SW V0, 24832(V1)
65:                  
66:                      LATEbits.LATE4 = 1;
9D003150  3C03BF88   LUI V1, -16504
9D003154  8C626120   LW V0, 24864(V1)
9D003158  24040001   ADDIU A0, ZERO, 1
9D00315C  7C822104   INS V0, A0, 4, 1
9D003160  AC626120   SW V0, 24864(V1)
67:                      LATEbits.LATE3 = 1;
9D003164  3C03BF88   LUI V1, -16504
9D003168  8C626120   LW V0, 24864(V1)
9D00316C  24040001   ADDIU A0, ZERO, 1
9D003170  7C8218C4   INS V0, A0, 3, 1
9D003174  AC626120   SW V0, 24864(V1)
9D003178  0B400C61   J 0x9D003184
9D00317C  00000000   NOP
68:                  
69:                      while (1)
9D003180  00000000   NOP
9D0031CC  0B400C61   J 0x9D003184
9D0031D0  00000000   NOP
70:                      {
71:                          if (receive_one.receiveData())
9D003184  3C02A000   LUI V0, -24576
9D003188  24440988   ADDIU A0, V0, 2440
9D00318C  0F4008DB   JAL 0x9D00236C
9D003190  00000000   NOP
9D003194  1040FFFA   BEQ V0, ZERO, 0x9D003180
9D003198  00000000   NOP
72:                          {
73:                              LATEbits.LATE4 ^= 1;
9D00319C  3C02BF88   LUI V0, -16504
9D0031A0  8C426120   LW V0, 24864(V0)
9D0031A4  7C420100   EXT V0, V0, 4, 1
9D0031A8  304200FF   ANDI V0, V0, 255
9D0031AC  38420001   XORI V0, V0, 1
9D0031B0  304200FF   ANDI V0, V0, 255
9D0031B4  30420001   ANDI V0, V0, 1
9D0031B8  304400FF   ANDI A0, V0, 255
9D0031BC  3C03BF88   LUI V1, -16504
9D0031C0  8C626120   LW V0, 24864(V1)
9D0031C4  7C822104   INS V0, A0, 4, 1
9D0031C8  AC626120   SW V0, 24864(V1)
74:                  
75:                          }
76:                          //        receive_two.receiveData();
77:                          //        receive_three.receiveData();
78:                          //        receive_four.receiveData();
79:                          //        receive_five.receiveData();
80:                          //        receive_six.receiveData();
81:                          //
82:                          //        DMA_one.queue_send();
83:                          //        DMA_two.queue_send();
84:                          //        DMA_three.queue_send();
85:                          //        DMA_four.queue_send();
86:                          //        DMA_five.queue_send();
87:                          //        DMA_six.queue_send();
88:                      }
89:                  
90:                      return 0;
91:                  }
92:                  
93:                  static enum feild
94:                  {
95:                      EXCEP_IRQ = 0, // interrupt
96:                      EXCEP_AdEL = 4, // address error exception (load or ifetch)
97:                      EXCEP_AdES, // address error exception (store)
98:                      EXCEP_IBE, // bus error (ifetch)
99:                      EXCEP_DBE, // bus error (load/store)
100:                     EXCEP_Sys, // syscall
101:                     EXCEP_Bp, // breakpoint
102:                     EXCEP_RI, // reserved instruction
103:                     EXCEP_CpU, // coprocessor unusable
104:                     EXCEP_Overflow, // arithmetic overflow
105:                     EXCEP_Trap, // trap (possible divide by zero)
106:                     EXCEP_IS1 = 16, // implementation specfic 1
107:                     EXCEP_CEU, // CorExtend Unuseable
108:                     EXCEP_C2E // coprocessor 2
109:                 } _excep_code;
110:                 static unsigned int _epc_code;
111:                 static unsigned int _excep_addr;
112:                 // this function overrides the normal _weak_ generic handler
113:                 
114:                 void _general_exception_handler(void)
115:                 {
9D0031D4  27BDFFF8   ADDIU SP, SP, -8
9D0031D8  AFBE0004   SW S8, 4(SP)
9D0031DC  03A0F021   ADDU S8, SP, ZERO
116:                     LATEbits.LATE4 = 0;
9D0031E0  3C03BF88   LUI V1, -16504
9D0031E4  8C626120   LW V0, 24864(V1)
9D0031E8  7C022104   INS V0, ZERO, 4, 1
9D0031EC  AC626120   SW V0, 24864(V1)
117:                     asm volatile("mfc0 %0,$13" : "=r" (_excep_code));
9D0031F0  40026800   MFC0 V0, Cause
9D0031F4  AF828010   SW V0, -32752(GP)
118:                     asm volatile("mfc0 %0,$14" : "=r" (_excep_addr));
9D0031F8  40027000   MFC0 V0, EPC
9D0031FC  AF828018   SW V0, -32744(GP)
119:                     _excep_code =(feild)((_excep_code & 0x0000007C) >> 2);
9D003200  8F828010   LW V0, -32752(GP)
9D003204  3042007C   ANDI V0, V0, 124
9D003208  00021083   SRA V0, V0, 2
9D00320C  AF828010   SW V0, -32752(GP)
120:                     while (1)
9D003210  0B400C84   J 0x9D003210
9D003214  00000000   NOP
121:                     {
122:                         // Examine _excep_code to identify the type of exception
123:                         // Examine _excep_addr to find the address that caused the exception
124:                     }
125:                 }
---  c:/users/igor/mplabxprojects/routerpic.x/interrupt_handler.cpp  ------------------------------------
1:                   #include <xc.h>
2:                   #include <sys/attribs.h>
3:                   #include <stdlib.h>
4:                   #include "interrupt_handler.h"
5:                   #include "buffer.h"
6:                   #include "constants.h"
7:                   #include "queue.h"
8:                   #include "FastTransfer.h"
9:                   #include "variables.h"
10:                  
11:                  void __ISR(_UART_1_VECTOR, IPL1AUTO) Uart1Handler(void)
12:                  {
9D00198C  415DE800   RDPGPR SP, SP
9D001990  401B7000   MFC0 K1, EPC
9D001994  401A6002   MFC0 K0, SRSCtl
9D001998  27BDFF88   ADDIU SP, SP, -120
9D00199C  AFBB0074   SW K1, 116(SP)
9D0019A0  401B6000   MFC0 K1, Status
9D0019A4  AFBA0070   SW K0, 112(SP)
9D0019A8  AFBB006C   SW K1, 108(SP)
9D0019AC  7C1B7844   INS K1, ZERO, 1, 15
9D0019B0  377B0400   ORI K1, K1, 1024
9D0019B4  409B6000   MTC0 K1, Status
9D0019B8  AFA3001C   SW V1, 28(SP)
9D0019BC  AFA20018   SW V0, 24(SP)
9D0019C0  8FA30070   LW V1, 112(SP)
9D0019C4  3063000F   ANDI V1, V1, 15
9D0019C8  14600012   BNE V1, ZERO, 0x9D001A14
9D0019CC  00000000   NOP
9D0019D0  AFBF005C   SW RA, 92(SP)
9D0019D4  AFBE0058   SW S8, 88(SP)
9D0019D8  AFB90054   SW T9, 84(SP)
9D0019DC  AFB80050   SW T8, 80(SP)
9D0019E0  AFAF004C   SW T7, 76(SP)
9D0019E4  AFAE0048   SW T6, 72(SP)
9D0019E8  AFAD0044   SW T5, 68(SP)
9D0019EC  AFAC0040   SW T4, 64(SP)
9D0019F0  AFAB003C   SW T3, 60(SP)
9D0019F4  AFAA0038   SW T2, 56(SP)
9D0019F8  AFA90034   SW T1, 52(SP)
9D0019FC  AFA80030   SW T0, 48(SP)
9D001A00  AFA7002C   SW A3, 44(SP)
9D001A04  AFA60028   SW A2, 40(SP)
9D001A08  AFA50024   SW A1, 36(SP)
9D001A0C  AFA40020   SW A0, 32(SP)
9D001A10  AFA10014   SW AT, 20(SP)
9D001A14  00001012   MFLO V0, 0
9D001A18  AFA20064   SW V0, 100(SP)
9D001A1C  00001810   MFHI V1, 0
9D001A20  AFA30060   SW V1, 96(SP)
9D001A24  03A0F021   ADDU S8, SP, ZERO
13:                      
14:                      
15:                      ring_buff_put(&buffer_one, U1RXREG); //move data to software buffer
9D001A28  3C02BF80   LUI V0, -16512
9D001A2C  8C426030   LW V0, 24624(V0)
9D001A30  304200FF   ANDI V0, V0, 255
9D001A34  3C03A000   LUI V1, -24576
9D001A38  24640230   ADDIU A0, V1, 560
9D001A3C  00402821   ADDU A1, V0, ZERO
9D001A40  0F400A6E   JAL 0x9D0029B8
9D001A44  00000000   NOP
16:                      //U1TXREG = ring_buff_get(&buffer_one);
17:                      IFS0CLR = _IFS0_U1RXIF_MASK; // clear interrupt flag
9D001A48  3C02BF88   LUI V0, -16504
9D001A4C  3C030800   LUI V1, 2048
9D001A50  AC431034   SW V1, 4148(V0)
18:                  }
9D001A54  03C0E821   ADDU SP, S8, ZERO
9D001A58  8FA20064   LW V0, 100(SP)
9D001A5C  00400013   MTLO V0, 0
9D001A60  8FA30060   LW V1, 96(SP)
9D001A64  00600011   MTHI V1, 0
9D001A68  8FA20070   LW V0, 112(SP)
9D001A6C  3042000F   ANDI V0, V0, 15
9D001A70  14400014   BNE V0, ZERO, 0x9D001AC4
9D001A74  00000000   NOP
9D001A78  8FBF005C   LW RA, 92(SP)
9D001A7C  8FBE0058   LW S8, 88(SP)
9D001A80  8FB90054   LW T9, 84(SP)
9D001A84  8FB80050   LW T8, 80(SP)
9D001A88  8FAF004C   LW T7, 76(SP)
9D001A8C  8FAE0048   LW T6, 72(SP)
9D001A90  8FAD0044   LW T5, 68(SP)
9D001A94  8FAC0040   LW T4, 64(SP)
9D001A98  8FAB003C   LW T3, 60(SP)
9D001A9C  8FAA0038   LW T2, 56(SP)
9D001AA0  8FA90034   LW T1, 52(SP)
9D001AA4  8FA80030   LW T0, 48(SP)
9D001AA8  8FA7002C   LW A3, 44(SP)
9D001AAC  8FA60028   LW A2, 40(SP)
9D001AB0  8FA50024   LW A1, 36(SP)
9D001AB4  8FA40020   LW A0, 32(SP)
9D001AB8  8FA3001C   LW V1, 28(SP)
9D001ABC  8FA20018   LW V0, 24(SP)
9D001AC0  8FA10014   LW AT, 20(SP)
9D001AC4  41606000   DI ZERO
9D001AC8  000000C0   EHB
9D001ACC  8FBA0074   LW K0, 116(SP)
9D001AD0  8FBB006C   LW K1, 108(SP)
9D001AD4  409A7000   MTC0 K0, EPC
9D001AD8  8FBA0070   LW K0, 112(SP)
9D001ADC  27BD0078   ADDIU SP, SP, 120
9D001AE0  409A6002   MTC0 K0, SRSCtl
9D001AE4  41DDE800   WRPGPR SP, SP
9D001AE8  409B6000   MTC0 K1, Status
9D001AEC  42000018   ERET
19:                  
20:                  void __ISR(_UART_2_VECTOR, IPL1AUTO) Uart2Handler(void)
21:                  {
9D001AF0  415DE800   RDPGPR SP, SP
9D001AF4  401B7000   MFC0 K1, EPC
9D001AF8  401A6002   MFC0 K0, SRSCtl
9D001AFC  27BDFF88   ADDIU SP, SP, -120
9D001B00  AFBB0074   SW K1, 116(SP)
9D001B04  401B6000   MFC0 K1, Status
9D001B08  AFBA0070   SW K0, 112(SP)
9D001B0C  AFBB006C   SW K1, 108(SP)
9D001B10  7C1B7844   INS K1, ZERO, 1, 15
9D001B14  377B0400   ORI K1, K1, 1024
9D001B18  409B6000   MTC0 K1, Status
9D001B1C  AFA3001C   SW V1, 28(SP)
9D001B20  AFA20018   SW V0, 24(SP)
9D001B24  8FA30070   LW V1, 112(SP)
9D001B28  3063000F   ANDI V1, V1, 15
9D001B2C  14600012   BNE V1, ZERO, 0x9D001B78
9D001B30  00000000   NOP
9D001B34  AFBF005C   SW RA, 92(SP)
9D001B38  AFBE0058   SW S8, 88(SP)
9D001B3C  AFB90054   SW T9, 84(SP)
9D001B40  AFB80050   SW T8, 80(SP)
9D001B44  AFAF004C   SW T7, 76(SP)
9D001B48  AFAE0048   SW T6, 72(SP)
9D001B4C  AFAD0044   SW T5, 68(SP)
9D001B50  AFAC0040   SW T4, 64(SP)
9D001B54  AFAB003C   SW T3, 60(SP)
9D001B58  AFAA0038   SW T2, 56(SP)
9D001B5C  AFA90034   SW T1, 52(SP)
9D001B60  AFA80030   SW T0, 48(SP)
9D001B64  AFA7002C   SW A3, 44(SP)
9D001B68  AFA60028   SW A2, 40(SP)
9D001B6C  AFA50024   SW A1, 36(SP)
9D001B70  AFA40020   SW A0, 32(SP)
9D001B74  AFA10014   SW AT, 20(SP)
9D001B78  00001012   MFLO V0, 0
9D001B7C  AFA20064   SW V0, 100(SP)
9D001B80  00001810   MFHI V1, 0
9D001B84  AFA30060   SW V1, 96(SP)
9D001B88  03A0F021   ADDU S8, SP, ZERO
22:                      ring_buff_put(&buffer_two, U2RXREG);
9D001B8C  3C02BF80   LUI V0, -16512
9D001B90  8C426830   LW V0, 26672(V0)
9D001B94  304200FF   ANDI V0, V0, 255
9D001B98  3C03A000   LUI V1, -24576
9D001B9C  2464027C   ADDIU A0, V1, 636
9D001BA0  00402821   ADDU A1, V0, ZERO
9D001BA4  0F400A6E   JAL 0x9D0029B8
9D001BA8  00000000   NOP
23:                      IFS1CLR = _IFS1_U2RXIF_MASK;
9D001BAC  3C02BF88   LUI V0, -16504
9D001BB0  24030200   ADDIU V1, ZERO, 512
9D001BB4  AC431044   SW V1, 4164(V0)
24:                  }
9D001BB8  03C0E821   ADDU SP, S8, ZERO
9D001BBC  8FA20064   LW V0, 100(SP)
9D001BC0  00400013   MTLO V0, 0
9D001BC4  8FA30060   LW V1, 96(SP)
9D001BC8  00600011   MTHI V1, 0
9D001BCC  8FA20070   LW V0, 112(SP)
9D001BD0  3042000F   ANDI V0, V0, 15
9D001BD4  14400014   BNE V0, ZERO, 0x9D001C28
9D001BD8  00000000   NOP
9D001BDC  8FBF005C   LW RA, 92(SP)
9D001BE0  8FBE0058   LW S8, 88(SP)
9D001BE4  8FB90054   LW T9, 84(SP)
9D001BE8  8FB80050   LW T8, 80(SP)
9D001BEC  8FAF004C   LW T7, 76(SP)
9D001BF0  8FAE0048   LW T6, 72(SP)
9D001BF4  8FAD0044   LW T5, 68(SP)
9D001BF8  8FAC0040   LW T4, 64(SP)
9D001BFC  8FAB003C   LW T3, 60(SP)
9D001C00  8FAA0038   LW T2, 56(SP)
9D001C04  8FA90034   LW T1, 52(SP)
9D001C08  8FA80030   LW T0, 48(SP)
9D001C0C  8FA7002C   LW A3, 44(SP)
9D001C10  8FA60028   LW A2, 40(SP)
9D001C14  8FA50024   LW A1, 36(SP)
9D001C18  8FA40020   LW A0, 32(SP)
9D001C1C  8FA3001C   LW V1, 28(SP)
9D001C20  8FA20018   LW V0, 24(SP)
9D001C24  8FA10014   LW AT, 20(SP)
9D001C28  41606000   DI ZERO
9D001C2C  000000C0   EHB
9D001C30  8FBA0074   LW K0, 116(SP)
9D001C34  8FBB006C   LW K1, 108(SP)
9D001C38  409A7000   MTC0 K0, EPC
9D001C3C  8FBA0070   LW K0, 112(SP)
9D001C40  27BD0078   ADDIU SP, SP, 120
9D001C44  409A6002   MTC0 K0, SRSCtl
9D001C48  41DDE800   WRPGPR SP, SP
9D001C4C  409B6000   MTC0 K1, Status
9D001C50  42000018   ERET
25:                  
26:                  void __ISR(_UART_3_VECTOR, IPL1AUTO) Uart3Handler(void)
27:                  {
9D001C54  415DE800   RDPGPR SP, SP
9D001C58  401B7000   MFC0 K1, EPC
9D001C5C  401A6002   MFC0 K0, SRSCtl
9D001C60  27BDFF88   ADDIU SP, SP, -120
9D001C64  AFBB0074   SW K1, 116(SP)
9D001C68  401B6000   MFC0 K1, Status
9D001C6C  AFBA0070   SW K0, 112(SP)
9D001C70  AFBB006C   SW K1, 108(SP)
9D001C74  7C1B7844   INS K1, ZERO, 1, 15
9D001C78  377B0400   ORI K1, K1, 1024
9D001C7C  409B6000   MTC0 K1, Status
9D001C80  AFA3001C   SW V1, 28(SP)
9D001C84  AFA20018   SW V0, 24(SP)
9D001C88  8FA30070   LW V1, 112(SP)
9D001C8C  3063000F   ANDI V1, V1, 15
9D001C90  14600012   BNE V1, ZERO, 0x9D001CDC
9D001C94  00000000   NOP
9D001C98  AFBF005C   SW RA, 92(SP)
9D001C9C  AFBE0058   SW S8, 88(SP)
9D001CA0  AFB90054   SW T9, 84(SP)
9D001CA4  AFB80050   SW T8, 80(SP)
9D001CA8  AFAF004C   SW T7, 76(SP)
9D001CAC  AFAE0048   SW T6, 72(SP)
9D001CB0  AFAD0044   SW T5, 68(SP)
9D001CB4  AFAC0040   SW T4, 64(SP)
9D001CB8  AFAB003C   SW T3, 60(SP)
9D001CBC  AFAA0038   SW T2, 56(SP)
9D001CC0  AFA90034   SW T1, 52(SP)
9D001CC4  AFA80030   SW T0, 48(SP)
9D001CC8  AFA7002C   SW A3, 44(SP)
9D001CCC  AFA60028   SW A2, 40(SP)
9D001CD0  AFA50024   SW A1, 36(SP)
9D001CD4  AFA40020   SW A0, 32(SP)
9D001CD8  AFA10014   SW AT, 20(SP)
9D001CDC  00001012   MFLO V0, 0
9D001CE0  AFA20064   SW V0, 100(SP)
9D001CE4  00001810   MFHI V1, 0
9D001CE8  AFA30060   SW V1, 96(SP)
9D001CEC  03A0F021   ADDU S8, SP, ZERO
28:                      ring_buff_put(&buffer_three, U3RXREG);
9D001CF0  3C02BF80   LUI V0, -16512
9D001CF4  8C426430   LW V0, 25648(V0)
9D001CF8  304200FF   ANDI V0, V0, 255
9D001CFC  3C03A000   LUI V1, -24576
9D001D00  246402C8   ADDIU A0, V1, 712
9D001D04  00402821   ADDU A1, V0, ZERO
9D001D08  0F400A6E   JAL 0x9D0029B8
9D001D0C  00000000   NOP
29:                      IFS1SET = _IFS1_U3RXIF_MASK;
9D001D10  3C02BF88   LUI V0, -16504
9D001D14  24030040   ADDIU V1, ZERO, 64
9D001D18  AC431048   SW V1, 4168(V0)
30:                  }
9D001D1C  03C0E821   ADDU SP, S8, ZERO
9D001D20  8FA20064   LW V0, 100(SP)
9D001D24  00400013   MTLO V0, 0
9D001D28  8FA30060   LW V1, 96(SP)
9D001D2C  00600011   MTHI V1, 0
9D001D30  8FA20070   LW V0, 112(SP)
9D001D34  3042000F   ANDI V0, V0, 15
9D001D38  14400014   BNE V0, ZERO, 0x9D001D8C
9D001D3C  00000000   NOP
9D001D40  8FBF005C   LW RA, 92(SP)
9D001D44  8FBE0058   LW S8, 88(SP)
9D001D48  8FB90054   LW T9, 84(SP)
9D001D4C  8FB80050   LW T8, 80(SP)
9D001D50  8FAF004C   LW T7, 76(SP)
9D001D54  8FAE0048   LW T6, 72(SP)
9D001D58  8FAD0044   LW T5, 68(SP)
9D001D5C  8FAC0040   LW T4, 64(SP)
9D001D60  8FAB003C   LW T3, 60(SP)
9D001D64  8FAA0038   LW T2, 56(SP)
9D001D68  8FA90034   LW T1, 52(SP)
9D001D6C  8FA80030   LW T0, 48(SP)
9D001D70  8FA7002C   LW A3, 44(SP)
9D001D74  8FA60028   LW A2, 40(SP)
9D001D78  8FA50024   LW A1, 36(SP)
9D001D7C  8FA40020   LW A0, 32(SP)
9D001D80  8FA3001C   LW V1, 28(SP)
9D001D84  8FA20018   LW V0, 24(SP)
9D001D88  8FA10014   LW AT, 20(SP)
9D001D8C  41606000   DI ZERO
9D001D90  000000C0   EHB
9D001D94  8FBA0074   LW K0, 116(SP)
9D001D98  8FBB006C   LW K1, 108(SP)
9D001D9C  409A7000   MTC0 K0, EPC
9D001DA0  8FBA0070   LW K0, 112(SP)
9D001DA4  27BD0078   ADDIU SP, SP, 120
9D001DA8  409A6002   MTC0 K0, SRSCtl
9D001DAC  41DDE800   WRPGPR SP, SP
9D001DB0  409B6000   MTC0 K1, Status
9D001DB4  42000018   ERET
31:                  
32:                  void __ISR(_UART_4_VECTOR, IPL1AUTO) Uart4Handler(void)
33:                  {
9D001DB8  415DE800   RDPGPR SP, SP
9D001DBC  401B7000   MFC0 K1, EPC
9D001DC0  401A6002   MFC0 K0, SRSCtl
9D001DC4  27BDFF88   ADDIU SP, SP, -120
9D001DC8  AFBB0074   SW K1, 116(SP)
9D001DCC  401B6000   MFC0 K1, Status
9D001DD0  AFBA0070   SW K0, 112(SP)
9D001DD4  AFBB006C   SW K1, 108(SP)
9D001DD8  7C1B7844   INS K1, ZERO, 1, 15
9D001DDC  377B0400   ORI K1, K1, 1024
9D001DE0  409B6000   MTC0 K1, Status
9D001DE4  AFA3001C   SW V1, 28(SP)
9D001DE8  AFA20018   SW V0, 24(SP)
9D001DEC  8FA30070   LW V1, 112(SP)
9D001DF0  3063000F   ANDI V1, V1, 15
9D001DF4  14600012   BNE V1, ZERO, 0x9D001E40
9D001DF8  00000000   NOP
9D001DFC  AFBF005C   SW RA, 92(SP)
9D001E00  AFBE0058   SW S8, 88(SP)
9D001E04  AFB90054   SW T9, 84(SP)
9D001E08  AFB80050   SW T8, 80(SP)
9D001E0C  AFAF004C   SW T7, 76(SP)
9D001E10  AFAE0048   SW T6, 72(SP)
9D001E14  AFAD0044   SW T5, 68(SP)
9D001E18  AFAC0040   SW T4, 64(SP)
9D001E1C  AFAB003C   SW T3, 60(SP)
9D001E20  AFAA0038   SW T2, 56(SP)
9D001E24  AFA90034   SW T1, 52(SP)
9D001E28  AFA80030   SW T0, 48(SP)
9D001E2C  AFA7002C   SW A3, 44(SP)
9D001E30  AFA60028   SW A2, 40(SP)
9D001E34  AFA50024   SW A1, 36(SP)
9D001E38  AFA40020   SW A0, 32(SP)
9D001E3C  AFA10014   SW AT, 20(SP)
9D001E40  00001012   MFLO V0, 0
9D001E44  AFA20064   SW V0, 100(SP)
9D001E48  00001810   MFHI V1, 0
9D001E4C  AFA30060   SW V1, 96(SP)
9D001E50  03A0F021   ADDU S8, SP, ZERO
34:                      ring_buff_put(&buffer_four, U4RXREG);
9D001E54  3C02BF80   LUI V0, -16512
9D001E58  8C426230   LW V0, 25136(V0)
9D001E5C  304200FF   ANDI V0, V0, 255
9D001E60  3C03A000   LUI V1, -24576
9D001E64  24640314   ADDIU A0, V1, 788
9D001E68  00402821   ADDU A1, V0, ZERO
9D001E6C  0F400A6E   JAL 0x9D0029B8
9D001E70  00000000   NOP
35:                      IFS2SET = _IFS2_U4RXIF_MASK;
9D001E74  3C02BF88   LUI V0, -16504
9D001E78  24030010   ADDIU V1, ZERO, 16
9D001E7C  AC431058   SW V1, 4184(V0)
36:                  }
9D001E80  03C0E821   ADDU SP, S8, ZERO
9D001E84  8FA20064   LW V0, 100(SP)
9D001E88  00400013   MTLO V0, 0
9D001E8C  8FA30060   LW V1, 96(SP)
9D001E90  00600011   MTHI V1, 0
9D001E94  8FA20070   LW V0, 112(SP)
9D001E98  3042000F   ANDI V0, V0, 15
9D001E9C  14400014   BNE V0, ZERO, 0x9D001EF0
9D001EA0  00000000   NOP
9D001EA4  8FBF005C   LW RA, 92(SP)
9D001EA8  8FBE0058   LW S8, 88(SP)
9D001EAC  8FB90054   LW T9, 84(SP)
9D001EB0  8FB80050   LW T8, 80(SP)
9D001EB4  8FAF004C   LW T7, 76(SP)
9D001EB8  8FAE0048   LW T6, 72(SP)
9D001EBC  8FAD0044   LW T5, 68(SP)
9D001EC0  8FAC0040   LW T4, 64(SP)
9D001EC4  8FAB003C   LW T3, 60(SP)
9D001EC8  8FAA0038   LW T2, 56(SP)
9D001ECC  8FA90034   LW T1, 52(SP)
9D001ED0  8FA80030   LW T0, 48(SP)
9D001ED4  8FA7002C   LW A3, 44(SP)
9D001ED8  8FA60028   LW A2, 40(SP)
9D001EDC  8FA50024   LW A1, 36(SP)
9D001EE0  8FA40020   LW A0, 32(SP)
9D001EE4  8FA3001C   LW V1, 28(SP)
9D001EE8  8FA20018   LW V0, 24(SP)
9D001EEC  8FA10014   LW AT, 20(SP)
9D001EF0  41606000   DI ZERO
9D001EF4  000000C0   EHB
9D001EF8  8FBA0074   LW K0, 116(SP)
9D001EFC  8FBB006C   LW K1, 108(SP)
9D001F00  409A7000   MTC0 K0, EPC
9D001F04  8FBA0070   LW K0, 112(SP)
9D001F08  27BD0078   ADDIU SP, SP, 120
9D001F0C  409A6002   MTC0 K0, SRSCtl
9D001F10  41DDE800   WRPGPR SP, SP
9D001F14  409B6000   MTC0 K1, Status
9D001F18  42000018   ERET
37:                  
38:                  void __ISR(_UART_5_VECTOR, IPL1AUTO) Uart5Handler(void)
39:                  {
9D001F1C  415DE800   RDPGPR SP, SP
9D001F20  401B7000   MFC0 K1, EPC
9D001F24  401A6002   MFC0 K0, SRSCtl
9D001F28  27BDFF88   ADDIU SP, SP, -120
9D001F2C  AFBB0074   SW K1, 116(SP)
9D001F30  401B6000   MFC0 K1, Status
9D001F34  AFBA0070   SW K0, 112(SP)
9D001F38  AFBB006C   SW K1, 108(SP)
9D001F3C  7C1B7844   INS K1, ZERO, 1, 15
9D001F40  377B0400   ORI K1, K1, 1024
9D001F44  409B6000   MTC0 K1, Status
9D001F48  AFA3001C   SW V1, 28(SP)
9D001F4C  AFA20018   SW V0, 24(SP)
9D001F50  8FA30070   LW V1, 112(SP)
9D001F54  3063000F   ANDI V1, V1, 15
9D001F58  14600012   BNE V1, ZERO, 0x9D001FA4
9D001F5C  00000000   NOP
9D001F60  AFBF005C   SW RA, 92(SP)
9D001F64  AFBE0058   SW S8, 88(SP)
9D001F68  AFB90054   SW T9, 84(SP)
9D001F6C  AFB80050   SW T8, 80(SP)
9D001F70  AFAF004C   SW T7, 76(SP)
9D001F74  AFAE0048   SW T6, 72(SP)
9D001F78  AFAD0044   SW T5, 68(SP)
9D001F7C  AFAC0040   SW T4, 64(SP)
9D001F80  AFAB003C   SW T3, 60(SP)
9D001F84  AFAA0038   SW T2, 56(SP)
9D001F88  AFA90034   SW T1, 52(SP)
9D001F8C  AFA80030   SW T0, 48(SP)
9D001F90  AFA7002C   SW A3, 44(SP)
9D001F94  AFA60028   SW A2, 40(SP)
9D001F98  AFA50024   SW A1, 36(SP)
9D001F9C  AFA40020   SW A0, 32(SP)
9D001FA0  AFA10014   SW AT, 20(SP)
9D001FA4  00001012   MFLO V0, 0
9D001FA8  AFA20064   SW V0, 100(SP)
9D001FAC  00001810   MFHI V1, 0
9D001FB0  AFA30060   SW V1, 96(SP)
9D001FB4  03A0F021   ADDU S8, SP, ZERO
40:                      ring_buff_put(&buffer_five, U5RXREG);
9D001FB8  3C02BF80   LUI V0, -16512
9D001FBC  8C426A30   LW V0, 27184(V0)
9D001FC0  304200FF   ANDI V0, V0, 255
9D001FC4  3C03A000   LUI V1, -24576
9D001FC8  24640360   ADDIU A0, V1, 864
9D001FCC  00402821   ADDU A1, V0, ZERO
9D001FD0  0F400A6E   JAL 0x9D0029B8
9D001FD4  00000000   NOP
41:                      IFS2SET = _IFS2_U5RXIF_MASK;
9D001FD8  3C02BF88   LUI V0, -16504
9D001FDC  24030400   ADDIU V1, ZERO, 1024
9D001FE0  AC431058   SW V1, 4184(V0)
42:                  }
9D001FE4  03C0E821   ADDU SP, S8, ZERO
9D001FE8  8FA20064   LW V0, 100(SP)
9D001FEC  00400013   MTLO V0, 0
9D001FF0  8FA30060   LW V1, 96(SP)
9D001FF4  00600011   MTHI V1, 0
9D001FF8  8FA20070   LW V0, 112(SP)
9D001FFC  3042000F   ANDI V0, V0, 15
9D002000  14400014   BNE V0, ZERO, 0x9D002054
9D002004  00000000   NOP
9D002008  8FBF005C   LW RA, 92(SP)
9D00200C  8FBE0058   LW S8, 88(SP)
9D002010  8FB90054   LW T9, 84(SP)
9D002014  8FB80050   LW T8, 80(SP)
9D002018  8FAF004C   LW T7, 76(SP)
9D00201C  8FAE0048   LW T6, 72(SP)
9D002020  8FAD0044   LW T5, 68(SP)
9D002024  8FAC0040   LW T4, 64(SP)
9D002028  8FAB003C   LW T3, 60(SP)
9D00202C  8FAA0038   LW T2, 56(SP)
9D002030  8FA90034   LW T1, 52(SP)
9D002034  8FA80030   LW T0, 48(SP)
9D002038  8FA7002C   LW A3, 44(SP)
9D00203C  8FA60028   LW A2, 40(SP)
9D002040  8FA50024   LW A1, 36(SP)
9D002044  8FA40020   LW A0, 32(SP)
9D002048  8FA3001C   LW V1, 28(SP)
9D00204C  8FA20018   LW V0, 24(SP)
9D002050  8FA10014   LW AT, 20(SP)
9D002054  41606000   DI ZERO
9D002058  000000C0   EHB
9D00205C  8FBA0074   LW K0, 116(SP)
9D002060  8FBB006C   LW K1, 108(SP)
9D002064  409A7000   MTC0 K0, EPC
9D002068  8FBA0070   LW K0, 112(SP)
9D00206C  27BD0078   ADDIU SP, SP, 120
9D002070  409A6002   MTC0 K0, SRSCtl
9D002074  41DDE800   WRPGPR SP, SP
9D002078  409B6000   MTC0 K1, Status
9D00207C  42000018   ERET
43:                  
44:                  void __ISR(_UART_6_VECTOR, IPL1AUTO) Uart6Handler(void)
45:                  {
9D002080  415DE800   RDPGPR SP, SP
9D002084  401B7000   MFC0 K1, EPC
9D002088  401A6002   MFC0 K0, SRSCtl
9D00208C  27BDFF88   ADDIU SP, SP, -120
9D002090  AFBB0074   SW K1, 116(SP)
9D002094  401B6000   MFC0 K1, Status
9D002098  AFBA0070   SW K0, 112(SP)
9D00209C  AFBB006C   SW K1, 108(SP)
9D0020A0  7C1B7844   INS K1, ZERO, 1, 15
9D0020A4  377B0400   ORI K1, K1, 1024
9D0020A8  409B6000   MTC0 K1, Status
9D0020AC  AFA3001C   SW V1, 28(SP)
9D0020B0  AFA20018   SW V0, 24(SP)
9D0020B4  8FA30070   LW V1, 112(SP)
9D0020B8  3063000F   ANDI V1, V1, 15
9D0020BC  14600012   BNE V1, ZERO, 0x9D002108
9D0020C0  00000000   NOP
9D0020C4  AFBF005C   SW RA, 92(SP)
9D0020C8  AFBE0058   SW S8, 88(SP)
9D0020CC  AFB90054   SW T9, 84(SP)
9D0020D0  AFB80050   SW T8, 80(SP)
9D0020D4  AFAF004C   SW T7, 76(SP)
9D0020D8  AFAE0048   SW T6, 72(SP)
9D0020DC  AFAD0044   SW T5, 68(SP)
9D0020E0  AFAC0040   SW T4, 64(SP)
9D0020E4  AFAB003C   SW T3, 60(SP)
9D0020E8  AFAA0038   SW T2, 56(SP)
9D0020EC  AFA90034   SW T1, 52(SP)
9D0020F0  AFA80030   SW T0, 48(SP)
9D0020F4  AFA7002C   SW A3, 44(SP)
9D0020F8  AFA60028   SW A2, 40(SP)
9D0020FC  AFA50024   SW A1, 36(SP)
9D002100  AFA40020   SW A0, 32(SP)
9D002104  AFA10014   SW AT, 20(SP)
9D002108  00001012   MFLO V0, 0
9D00210C  AFA20064   SW V0, 100(SP)
9D002110  00001810   MFHI V1, 0
9D002114  AFA30060   SW V1, 96(SP)
9D002118  03A0F021   ADDU S8, SP, ZERO
46:                      ring_buff_put(&buffer_six, U6RXREG);
9D00211C  3C02BF80   LUI V0, -16512
9D002120  8C426630   LW V0, 26160(V0)
9D002124  304200FF   ANDI V0, V0, 255
9D002128  3C03A000   LUI V1, -24576
9D00212C  246403AC   ADDIU A0, V1, 940
9D002130  00402821   ADDU A1, V0, ZERO
9D002134  0F400A6E   JAL 0x9D0029B8
9D002138  00000000   NOP
47:                      IFS2SET = _IFS2_U6RXIF_MASK;
9D00213C  3C02BF88   LUI V0, -16504
9D002140  24030080   ADDIU V1, ZERO, 128
9D002144  AC431058   SW V1, 4184(V0)
48:                  }
9D002148  03C0E821   ADDU SP, S8, ZERO
9D00214C  8FA20064   LW V0, 100(SP)
9D002150  00400013   MTLO V0, 0
9D002154  8FA30060   LW V1, 96(SP)
9D002158  00600011   MTHI V1, 0
9D00215C  8FA20070   LW V0, 112(SP)
9D002160  3042000F   ANDI V0, V0, 15
9D002164  14400014   BNE V0, ZERO, 0x9D0021B8
9D002168  00000000   NOP
9D00216C  8FBF005C   LW RA, 92(SP)
9D002170  8FBE0058   LW S8, 88(SP)
9D002174  8FB90054   LW T9, 84(SP)
9D002178  8FB80050   LW T8, 80(SP)
9D00217C  8FAF004C   LW T7, 76(SP)
9D002180  8FAE0048   LW T6, 72(SP)
9D002184  8FAD0044   LW T5, 68(SP)
9D002188  8FAC0040   LW T4, 64(SP)
9D00218C  8FAB003C   LW T3, 60(SP)
9D002190  8FAA0038   LW T2, 56(SP)
9D002194  8FA90034   LW T1, 52(SP)
9D002198  8FA80030   LW T0, 48(SP)
9D00219C  8FA7002C   LW A3, 44(SP)
9D0021A0  8FA60028   LW A2, 40(SP)
9D0021A4  8FA50024   LW A1, 36(SP)
9D0021A8  8FA40020   LW A0, 32(SP)
9D0021AC  8FA3001C   LW V1, 28(SP)
9D0021B0  8FA20018   LW V0, 24(SP)
9D0021B4  8FA10014   LW AT, 20(SP)
9D0021B8  41606000   DI ZERO
9D0021BC  000000C0   EHB
9D0021C0  8FBA0074   LW K0, 116(SP)
9D0021C4  8FBB006C   LW K1, 108(SP)
9D0021C8  409A7000   MTC0 K0, EPC
9D0021CC  8FBA0070   LW K0, 112(SP)
9D0021D0  27BD0078   ADDIU SP, SP, 120
9D0021D4  409A6002   MTC0 K0, SRSCtl
9D0021D8  41DDE800   WRPGPR SP, SP
9D0021DC  409B6000   MTC0 K1, Status
9D0021E0  42000018   ERET
49:                  
50:                  //void __ISR(_TIMER_1_VECTOR, IPL7SRS) Timer1Handler(void){
51:                  //    static int count = 0;
52:                  //    count++;
53:                  //    if (count >= 100){
54:                  //        count = 0;
55:                  //        LATEbits.LATE4 ^= 1;
56:                  //    }
57:                  //    IFS0CLR = _IFS0_T1IF_MASK;
58:                  //}
---  c:/users/igor/mplabxprojects/routerpic.x/initialize.cpp  -------------------------------------------
1:                   #include <xc.h>
2:                   #define _SUPPRESS_PLIB_WARNING
3:                   #include <plib.h>
4:                   #include "constants.h"
5:                   #include "initialize.h"
6:                   #include "queue.h"
7:                   #include "buffer.h"
8:                   #include "FastTransfer.h"
9:                   #include "variables.h"
10:                  
11:                  struct dmaSettings
12:                  {
13:                      unsigned char *dma_array;
14:                      volatile unsigned int *dmacon;
15:                      unsigned int con_busy_mask;
16:                      unsigned int con_en_mask;
17:                      volatile unsigned int *dmasize;
18:                      volatile unsigned int *dmaecon;
19:                      unsigned int econ_force_mask;
20:                  };
21:                  
22:                  void initialize(void)
23:                  {
9D000050  27BDFFA0   ADDIU SP, SP, -96
9D000054  AFBF005C   SW RA, 92(SP)
9D000058  AFBE0058   SW S8, 88(SP)
9D00005C  03A0F021   ADDU S8, SP, ZERO
9D000060  3C0204C4   LUI V0, 1220
9D000064  3442B400   ORI V0, V0, -19456
9D000068  AFC20010   SW V0, 16(S8)
9D00006C  2402FFFF   ADDIU V0, ZERO, -1
9D000070  AFC20014   SW V0, 20(S8)
24:                      SYSTEMConfig(SYS_FREQ, SYS_CFG_ALL); // sets up perifiral and clock configuration
25:                  
26:                      DMA(); //initialize dma settings
9D000344  0F400124   JAL 0x9D000490
9D000348  00000000   NOP
27:                      Buffers(); //initialize buffers
9D00034C  0F4001ED   JAL 0x9D0007B4
9D000350  00000000   NOP
28:                      Settings(); // initialize settings
9D000354  0F40020F   JAL 0x9D00083C
9D000358  00000000   NOP
29:                      Queue(); // initialize queue
9D00035C  0F4002D7   JAL 0x9D000B5C
9D000360  00000000   NOP
30:                      UART(); // initialize uart settings
9D000364  0F4000E1   JAL 0x9D000384
9D000368  00000000   NOP
31:                  }
9D00036C  03C0E821   ADDU SP, S8, ZERO
9D000370  8FBF005C   LW RA, 92(SP)
9D000374  8FBE0058   LW S8, 88(SP)
9D000378  27BD0060   ADDIU SP, SP, 96
9D00037C  03E00008   JR RA
9D000380  00000000   NOP
32:                  
33:                  void UART(void)
34:                  {
9D000384  27BDFFE8   ADDIU SP, SP, -24
9D000388  AFBF0014   SW RA, 20(SP)
9D00038C  AFBE0010   SW S8, 16(SP)
9D000390  03A0F021   ADDU S8, SP, ZERO
35:                      INTEnableSystemMultiVectoredInt();
9D000394  0F400DD4   JAL INTEnableSystemMultiVectoredInt
9D000398  00000000   NOP
36:                  
37:                      // uart 1
38:                      U1MODEbits.BRGH = 0; // set to standard speed mode
9D00039C  3C03BF80   LUI V1, -16512
9D0003A0  8C626000   LW V0, 24576(V1)
9D0003A4  7C0218C4   INS V0, ZERO, 3, 1
9D0003A8  AC626000   SW V0, 24576(V1)
39:                      U1BRG = 85; // 57600 baud
9D0003AC  3C02BF80   LUI V0, -16512
9D0003B0  24030055   ADDIU V1, ZERO, 85
9D0003B4  AC436040   SW V1, 24640(V0)
40:                      U1MODEbits.PDSEL = 0b00; // 8-bit no parity
9D0003B8  3C03BF80   LUI V1, -16512
9D0003BC  8C626000   LW V0, 24576(V1)
9D0003C0  7C021044   INS V0, ZERO, 1, 2
9D0003C4  AC626000   SW V0, 24576(V1)
41:                      U1MODEbits.STSEL = 0; // 1 stop bit
9D0003C8  3C03BF80   LUI V1, -16512
9D0003CC  8C626000   LW V0, 24576(V1)
9D0003D0  7C020004   INS V0, ZERO, 0, 1
9D0003D4  AC626000   SW V0, 24576(V1)
42:                      IEC0bits.U1RXIE = 1; // recieve interrupt enable
9D0003D8  3C03BF88   LUI V1, -16504
9D0003DC  8C621060   LW V0, 4192(V1)
9D0003E0  24040001   ADDIU A0, ZERO, 1
9D0003E4  7C82DEC4   INS V0, A0, 27, 1
9D0003E8  AC621060   SW V0, 4192(V1)
43:                      IPC6bits.U1IP = 1; // priority 1
9D0003EC  3C03BF88   LUI V1, -16504
9D0003F0  8C6210F0   LW V0, 4336(V1)
9D0003F4  24040001   ADDIU A0, ZERO, 1
9D0003F8  7C822084   INS V0, A0, 2, 3
9D0003FC  AC6210F0   SW V0, 4336(V1)
44:                      IPC6bits.U1IS = 1; // sub priority 1
9D000400  3C03BF88   LUI V1, -16504
9D000404  8C6210F0   LW V0, 4336(V1)
9D000408  24040001   ADDIU A0, ZERO, 1
9D00040C  7C820804   INS V0, A0, 0, 2
9D000410  AC6210F0   SW V0, 4336(V1)
45:                      U1STAbits.UTXISEL = 0; // interrupt when transmit complete
9D000414  3C03BF80   LUI V1, -16512
9D000418  8C626010   LW V0, 24592(V1)
9D00041C  7C027B84   INS V0, ZERO, 14, 2
9D000420  AC626010   SW V0, 24592(V1)
46:                      U1STAbits.URXISEL = 0; // interrupt generated with every reception
9D000424  3C03BF80   LUI V1, -16512
9D000428  8C626010   LW V0, 24592(V1)
9D00042C  7C023984   INS V0, ZERO, 6, 2
9D000430  AC626010   SW V0, 24592(V1)
47:                      U1STAbits.URXEN = 1; // enable uart recieve
9D000434  3C03BF80   LUI V1, -16512
9D000438  8C626010   LW V0, 24592(V1)
9D00043C  24040001   ADDIU A0, ZERO, 1
9D000440  7C826304   INS V0, A0, 12, 1
9D000444  AC626010   SW V0, 24592(V1)
48:                      U1STAbits.UTXEN = 1; // enable uart transmit
9D000448  3C03BF80   LUI V1, -16512
9D00044C  8C626010   LW V0, 24592(V1)
9D000450  24040001   ADDIU A0, ZERO, 1
9D000454  7C825284   INS V0, A0, 10, 1
9D000458  AC626010   SW V0, 24592(V1)
49:                      U1MODEbits.ON = 1; // enable whole uart module
9D00045C  3C03BF80   LUI V1, -16512
9D000460  8C626000   LW V0, 24576(V1)
9D000464  24040001   ADDIU A0, ZERO, 1
9D000468  7C827BC4   INS V0, A0, 15, 1
9D00046C  AC626000   SW V0, 24576(V1)
50:                  
51:                  
52:                  
53:                  //    // uart 2
54:                  //    U2MODEbits.BRGH = 0; // set to standard speed mode
55:                  //    U2BRG = 85; // 57600 baud
56:                  //    U2MODEbits.PDSEL = 0b00; // 8-bit no parity
57:                  //    U2MODEbits.STSEL = 0; // 1 stop bit
58:                  //    IEC1bits.U2RXIE = 1; // enable uart recieve
59:                  //    IPC8bits.U2IP = 1; // priority 1
60:                  //    IPC8bits.U2IS = 2; // sub priority 2
61:                  //    U2STAbits.URXEN = 1; // enable uart recieve
62:                  //    U2STAbits.URXISEL = 0b00; // interrupt generated with every reception
63:                  //    U2STAbits.UTXEN = 1; // enable uart transmit
64:                  //    U2MODEbits.ON = 1; // enable whole uart module
65:                  //
66:                  //
67:                  //
68:                  //    // uart 3
69:                  //    U3MODEbits.BRGH = 0; // set to standard speed mode
70:                  //    U3BRG = 85; // 57600 baud
71:                  //    U3MODEbits.PDSEL = 0b00; // 8-bit no parity
72:                  //    U3MODEbits.STSEL = 0; // 1 stop bit
73:                  //    IEC1bits.U3RXIE = 1; // enable uart recieve
74:                  //    IPC7bits.U3IP = 1; // priority 1
75:                  //    IPC7bits.U3IS = 2; // sub priority 2
76:                  //    U3STAbits.URXEN = 1; // enable uart recieve
77:                  //    U3STAbits.URXISEL = 0b00; // interrupt generated with every reception
78:                  //    U3STAbits.UTXEN = 1; // enable uart transmit
79:                  //    U3MODEbits.ON = 1; // enable whole uart module
80:                  //
81:                  //
82:                  //    // uart 4
83:                  //    U4MODEbits.BRGH = 0; // set to standard speed mode
84:                  //    U4BRG = 85; // 57600 baud
85:                  //    U4MODEbits.PDSEL = 0b00; // 8-bit no parity
86:                  //    U4MODEbits.STSEL = 0; // 1 stop bit
87:                  //    IEC2bits.U4RXIE = 1; // enable uart recieve
88:                  //    IPC12bits.U4IP = 1; // priority 1
89:                  //    IPC12bits.U4IS = 2; // sub priority 2
90:                  //    U4STAbits.URXEN = 1; // enable uart recieve
91:                  //    U4STAbits.URXISEL = 0b00; // interrupt generated with every reception
92:                  //    U4STAbits.UTXEN = 1; // enable uart transmit
93:                  //    U4MODEbits.ON = 1; // enable whole uart module
94:                  //
95:                  //
96:                  //
97:                  //    // uart 5
98:                  //    U5MODEbits.BRGH = 0; // set to standard speed mode
99:                  //    U5BRG = 85; // 57600 baud
100:                 //    U5MODEbits.PDSEL = 0b00; // 8-bit no parity
101:                 //    U5MODEbits.STSEL = 0; // 1 stop bit
102:                 //    IEC2bits.U5RXIE = 1; // enable uart recieve
103:                 //    IPC12bits.U5IP = 1; // priority 1
104:                 //    IPC12bits.U5IS = 2; // sub priority 2
105:                 //    U5STAbits.URXEN = 1; // enable uart recieve
106:                 //    U5STAbits.URXISEL = 0b00; // interrupt generated with every reception
107:                 //    U5STAbits.UTXEN = 1; // enable uart transmit
108:                 //    U5MODEbits.ON = 1; // enable whole uart module
109:                 //
110:                 //
111:                 //    // uart 6
112:                 //    U6MODEbits.BRGH = 0; // set to standard speed mode
113:                 //    U6BRG = 85; // 57600 baud
114:                 //    U6MODEbits.PDSEL = 0b00; // 8-bit no parity
115:                 //    U6MODEbits.STSEL = 0; // 1 stop bit
116:                 //    IEC2bits.U6RXIE = 1; // enable uart recieve
117:                 //    IPC12bits.U6IP = 1; // priority 1
118:                 //    IPC12bits.U6IS = 2; // sub priority 2
119:                 //    U6STAbits.URXEN = 1; // enable uart recieve
120:                 //    U6STAbits.URXISEL = 0b00; // interrupt generated with every reception
121:                 //    U6STAbits.UTXEN = 1; // enable uart transmit
122:                 //    U6MODEbits.ON = 1; // enable whole uart module
123:                 
124:                     INTEnableInterrupts(); // enable interrupts
9D000470  0F400E12   JAL INTEnableInterrupts
9D000474  00000000   NOP
125:                 }
9D000478  03C0E821   ADDU SP, S8, ZERO
9D00047C  8FBF0014   LW RA, 20(SP)
9D000480  8FBE0010   LW S8, 16(SP)
9D000484  27BD0018   ADDIU SP, SP, 24
9D000488  03E00008   JR RA
9D00048C  00000000   NOP
126:                 
127:                 void DMA(void)
128:                 {
9D000490  27BDFFF8   ADDIU SP, SP, -8
9D000494  AFBE0004   SW S8, 4(SP)
9D000498  03A0F021   ADDU S8, SP, ZERO
129:                     DMACONbits.ON = 1; // dma module enabled
9D00049C  3C03BF88   LUI V1, -16504
9D0004A0  8C623000   LW V0, 12288(V1)
9D0004A4  24040001   ADDIU A0, ZERO, 1
9D0004A8  7C827BC4   INS V0, A0, 15, 1
9D0004AC  AC623000   SW V0, 12288(V1)
130:                     DCRCCON = 0; // crc module disabled
9D0004B0  3C02BF88   LUI V0, -16504
9D0004B4  AC403030   SW ZERO, 12336(V0)
131:                 
132:                     //dam  1
133:                     DCH1CONbits.CHPRI = 2; // channel priority 2
9D0004B8  3C03BF88   LUI V1, -16504
9D0004BC  8C623120   LW V0, 12576(V1)
9D0004C0  24040002   ADDIU A0, ZERO, 2
9D0004C4  7C820804   INS V0, A0, 0, 2
9D0004C8  AC623120   SW V0, 12576(V1)
134:                     DCH1ECONbits.CHSIRQ = 28; // uart 1 tx IRQ
9D0004CC  3C02BF88   LUI V0, -16504
9D0004D0  2403001C   ADDIU V1, ZERO, 28
9D0004D4  A0433131   SB V1, 12593(V0)
135:                     DCH1ECONbits.SIRQEN = 1; // enable cell transfer when IRQ triggered
9D0004D8  3C03BF88   LUI V1, -16504
9D0004DC  8C623130   LW V0, 12592(V1)
9D0004E0  24040001   ADDIU A0, ZERO, 1
9D0004E4  7C822104   INS V0, A0, 4, 1
9D0004E8  AC623130   SW V0, 12592(V1)
136:                     DCH1INT = 0; // clear all existing flags, disable all interrupts
9D0004EC  3C02BF88   LUI V0, -16504
9D0004F0  AC403140   SW ZERO, 12608(V0)
137:                     DCH1SSA = (unsigned int) &dma_one_array & 0x1FFFFFFF; // physical address convertion for transmit buffer
9D0004F4  3C02A000   LUI V0, -24576
9D0004F8  244203F8   ADDIU V0, V0, 1016
9D0004FC  7C43E000   EXT V1, V0, 0, 29
9D000500  3C02BF88   LUI V0, -16504
9D000504  AC433150   SW V1, 12624(V0)
138:                     DCH1DSA = (unsigned int) &U1TXREG & 0x1FFFFFFF; // physical address convertion for uart send buffer
9D000508  3C02BF80   LUI V0, -16512
9D00050C  24426020   ADDIU V0, V0, 24608
9D000510  7C43E000   EXT V1, V0, 0, 29
9D000514  3C02BF88   LUI V0, -16504
9D000518  AC433160   SW V1, 12640(V0)
139:                     DCH1DSIZ = 1;
9D00051C  3C02BF88   LUI V0, -16504
9D000520  24030001   ADDIU V1, ZERO, 1
9D000524  AC433180   SW V1, 12672(V0)
140:                     DCH1CSIZ = 1;
9D000528  3C02BF88   LUI V0, -16504
9D00052C  24030001   ADDIU V1, ZERO, 1
9D000530  AC4331B0   SW V1, 12720(V0)
141:                 
142:                     //dam  2
143:                     DCH2CONbits.CHPRI = 2; // channel priority 2
9D000534  3C03BF88   LUI V1, -16504
9D000538  8C6231E0   LW V0, 12768(V1)
9D00053C  24040002   ADDIU A0, ZERO, 2
9D000540  7C820804   INS V0, A0, 0, 2
9D000544  AC6231E0   SW V0, 12768(V1)
144:                     DCH2ECONbits.CHSIRQ = 42; // uart 2 tx IRQ
9D000548  3C02BF88   LUI V0, -16504
9D00054C  2403002A   ADDIU V1, ZERO, 42
9D000550  A04331F1   SB V1, 12785(V0)
145:                     DCH2ECONbits.SIRQEN = 1; // enable cell transfer when IRQ triggered
9D000554  3C03BF88   LUI V1, -16504
9D000558  8C6231F0   LW V0, 12784(V1)
9D00055C  24040001   ADDIU A0, ZERO, 1
9D000560  7C822104   INS V0, A0, 4, 1
9D000564  AC6231F0   SW V0, 12784(V1)
146:                     DCH2INT = 0; // clear all existing flags, disable all interrupts
9D000568  3C02BF88   LUI V0, -16504
9D00056C  AC403200   SW ZERO, 12800(V0)
147:                     DCH2SSA = (unsigned int) &dma_two_array & 0x1FFFFFFF; // physical address convertion for transmit buffer
9D000570  3C02A000   LUI V0, -24576
9D000574  244204C0   ADDIU V0, V0, 1216
9D000578  7C43E000   EXT V1, V0, 0, 29
9D00057C  3C02BF88   LUI V0, -16504
9D000580  AC433210   SW V1, 12816(V0)
148:                     DCH2DSA = (unsigned int) &U2TXREG & 0x1FFFFFFF; // physical address convertion for uart send buffer
9D000584  3C02BF80   LUI V0, -16512
9D000588  24426820   ADDIU V0, V0, 26656
9D00058C  7C43E000   EXT V1, V0, 0, 29
9D000590  3C02BF88   LUI V0, -16504
9D000594  AC433220   SW V1, 12832(V0)
149:                     DCH2DSIZ = 1;
9D000598  3C02BF88   LUI V0, -16504
9D00059C  24030001   ADDIU V1, ZERO, 1
9D0005A0  AC433240   SW V1, 12864(V0)
150:                     DCH2CSIZ = 1;
9D0005A4  3C02BF88   LUI V0, -16504
9D0005A8  24030001   ADDIU V1, ZERO, 1
9D0005AC  AC433270   SW V1, 12912(V0)
151:                 
152:                 
153:                     //dam  3
154:                     DCH3CONbits.CHPRI = 2; // channel priority 2
9D0005B0  3C03BF88   LUI V1, -16504
9D0005B4  8C6232A0   LW V0, 12960(V1)
9D0005B8  24040002   ADDIU A0, ZERO, 2
9D0005BC  7C820804   INS V0, A0, 0, 2
9D0005C0  AC6232A0   SW V0, 12960(V1)
155:                     DCH3ECONbits.CHSIRQ = 39; // uart 3 tx IRQ
9D0005C4  3C02BF88   LUI V0, -16504
9D0005C8  24030027   ADDIU V1, ZERO, 39
9D0005CC  A04332B1   SB V1, 12977(V0)
156:                     DCH3ECONbits.SIRQEN = 1; // enable cell transfer when IRQ triggered
9D0005D0  3C03BF88   LUI V1, -16504
9D0005D4  8C6232B0   LW V0, 12976(V1)
9D0005D8  24040001   ADDIU A0, ZERO, 1
9D0005DC  7C822104   INS V0, A0, 4, 1
9D0005E0  AC6232B0   SW V0, 12976(V1)
157:                     DCH3INT = 0; // clear all existing flags, disable all interrupts
9D0005E4  3C02BF88   LUI V0, -16504
9D0005E8  AC4032C0   SW ZERO, 12992(V0)
158:                     DCH3SSA = (unsigned int) &dma_three_array & 0x1FFFFFFF; // physical address convertion for transmit buffer
9D0005EC  3C02A000   LUI V0, -24576
9D0005F0  24420588   ADDIU V0, V0, 1416
9D0005F4  7C43E000   EXT V1, V0, 0, 29
9D0005F8  3C02BF88   LUI V0, -16504
9D0005FC  AC4332D0   SW V1, 13008(V0)
159:                     DCH3DSA = (unsigned int) &U3TXREG & 0x1FFFFFFF; // physical address convertion for uart send buffer
9D000600  3C02BF80   LUI V0, -16512
9D000604  24426420   ADDIU V0, V0, 25632
9D000608  7C43E000   EXT V1, V0, 0, 29
9D00060C  3C02BF88   LUI V0, -16504
9D000610  AC4332E0   SW V1, 13024(V0)
160:                     DCH3DSIZ = 1;
9D000614  3C02BF88   LUI V0, -16504
9D000618  24030001   ADDIU V1, ZERO, 1
9D00061C  AC433300   SW V1, 13056(V0)
161:                     DCH3CSIZ = 1;
9D000620  3C02BF88   LUI V0, -16504
9D000624  24030001   ADDIU V1, ZERO, 1
9D000628  AC433330   SW V1, 13104(V0)
162:                 
163:                 
164:                     //dam  4
165:                     DCH4CONbits.CHPRI = 2; // channel priority 2
9D00062C  3C03BF88   LUI V1, -16504
9D000630  8C623360   LW V0, 13152(V1)
9D000634  24040002   ADDIU A0, ZERO, 2
9D000638  7C820804   INS V0, A0, 0, 2
9D00063C  AC623360   SW V0, 13152(V1)
166:                     DCH4ECONbits.CHSIRQ = 69; // uart 4 tx IRQ
9D000640  3C02BF88   LUI V0, -16504
9D000644  24030045   ADDIU V1, ZERO, 69
9D000648  A0433371   SB V1, 13169(V0)
167:                     DCH4ECONbits.SIRQEN = 1; // enable cell transfer when IRQ triggered
9D00064C  3C03BF88   LUI V1, -16504
9D000650  8C623370   LW V0, 13168(V1)
9D000654  24040001   ADDIU A0, ZERO, 1
9D000658  7C822104   INS V0, A0, 4, 1
9D00065C  AC623370   SW V0, 13168(V1)
168:                     DCH4INT = 0; // clear all existing flags, disable all interrupts
9D000660  3C02BF88   LUI V0, -16504
9D000664  AC403380   SW ZERO, 13184(V0)
169:                     DCH4SSA = (unsigned int) &dma_four_array & 0x1FFFFFFF; // physical address convertion for transmit buffer
9D000668  3C02A000   LUI V0, -24576
9D00066C  24420650   ADDIU V0, V0, 1616
9D000670  7C43E000   EXT V1, V0, 0, 29
9D000674  3C02BF88   LUI V0, -16504
9D000678  AC433390   SW V1, 13200(V0)
170:                     DCH4DSA = (unsigned int) &U4TXREG & 0x1FFFFFFF; // physical address convertion for uart send buffer
9D00067C  3C02BF80   LUI V0, -16512
9D000680  24426220   ADDIU V0, V0, 25120
9D000684  7C43E000   EXT V1, V0, 0, 29
9D000688  3C02BF88   LUI V0, -16504
9D00068C  AC4333A0   SW V1, 13216(V0)
171:                     DCH4DSIZ = 1;
9D000690  3C02BF88   LUI V0, -16504
9D000694  24030001   ADDIU V1, ZERO, 1
9D000698  AC4333C0   SW V1, 13248(V0)
172:                     DCH4CSIZ = 1;
9D00069C  3C02BF88   LUI V0, -16504
9D0006A0  24030001   ADDIU V1, ZERO, 1
9D0006A4  AC4333F0   SW V1, 13296(V0)
173:                 
174:                 
175:                     //dam  5
176:                     DCH5CONbits.CHPRI = 2; // channel priority 2
9D0006A8  3C03BF88   LUI V1, -16504
9D0006AC  8C623420   LW V0, 13344(V1)
9D0006B0  24040002   ADDIU A0, ZERO, 2
9D0006B4  7C820804   INS V0, A0, 0, 2
9D0006B8  AC623420   SW V0, 13344(V1)
177:                     DCH5ECONbits.CHSIRQ = 75; // uart 5 tx IRQ
9D0006BC  3C02BF88   LUI V0, -16504
9D0006C0  2403004B   ADDIU V1, ZERO, 75
9D0006C4  A0433431   SB V1, 13361(V0)
178:                     DCH5ECONbits.SIRQEN = 1; // enable cell transfer when IRQ triggered
9D0006C8  3C03BF88   LUI V1, -16504
9D0006CC  8C623430   LW V0, 13360(V1)
9D0006D0  24040001   ADDIU A0, ZERO, 1
9D0006D4  7C822104   INS V0, A0, 4, 1
9D0006D8  AC623430   SW V0, 13360(V1)
179:                     DCH5INT = 0; // clear all existing flags, disable all interrupts
9D0006DC  3C02BF88   LUI V0, -16504
9D0006E0  AC403440   SW ZERO, 13376(V0)
180:                     DCH5SSA = (unsigned int) &dma_five_array & 0x1FFFFFFF; // physical address convertion for transmit buffer
9D0006E4  3C02A000   LUI V0, -24576
9D0006E8  24420718   ADDIU V0, V0, 1816
9D0006EC  7C43E000   EXT V1, V0, 0, 29
9D0006F0  3C02BF88   LUI V0, -16504
9D0006F4  AC433450   SW V1, 13392(V0)
181:                     DCH5DSA = (unsigned int) &U5TXREG & 0x1FFFFFFF; // physical address convertion for uart send buffer
9D0006F8  3C02BF80   LUI V0, -16512
9D0006FC  24426A20   ADDIU V0, V0, 27168
9D000700  7C43E000   EXT V1, V0, 0, 29
9D000704  3C02BF88   LUI V0, -16504
9D000708  AC433460   SW V1, 13408(V0)
182:                     DCH5DSIZ = 1;
9D00070C  3C02BF88   LUI V0, -16504
9D000710  24030001   ADDIU V1, ZERO, 1
9D000714  AC433480   SW V1, 13440(V0)
183:                     DCH5CSIZ = 1;
9D000718  3C02BF88   LUI V0, -16504
9D00071C  24030001   ADDIU V1, ZERO, 1
9D000720  AC4334B0   SW V1, 13488(V0)
184:                 
185:                 
186:                     //dam  6
187:                     DCH6CONbits.CHPRI = 2; // channel priority 2
9D000724  3C03BF88   LUI V1, -16504
9D000728  8C6234E0   LW V0, 13536(V1)
9D00072C  24040002   ADDIU A0, ZERO, 2
9D000730  7C820804   INS V0, A0, 0, 2
9D000734  AC6234E0   SW V0, 13536(V1)
188:                     DCH6ECONbits.CHSIRQ = 72; // uart 6 tx IRQ
9D000738  3C02BF88   LUI V0, -16504
9D00073C  24030048   ADDIU V1, ZERO, 72
9D000740  A04334F1   SB V1, 13553(V0)
189:                     DCH6ECONbits.SIRQEN = 1; // enable cell transfer when IRQ triggered
9D000744  3C03BF88   LUI V1, -16504
9D000748  8C6234F0   LW V0, 13552(V1)
9D00074C  24040001   ADDIU A0, ZERO, 1
9D000750  7C822104   INS V0, A0, 4, 1
9D000754  AC6234F0   SW V0, 13552(V1)
190:                     DCH6INT = 0; // clear all existing flags, disable all interrupts
9D000758  3C02BF88   LUI V0, -16504
9D00075C  AC403500   SW ZERO, 13568(V0)
191:                     DCH6SSA = (unsigned int) &dma_six_array & 0x1FFFFFFF; // physical address convertion for transmit buffer
9D000760  3C02A000   LUI V0, -24576
9D000764  244207E0   ADDIU V0, V0, 2016
9D000768  7C43E000   EXT V1, V0, 0, 29
9D00076C  3C02BF88   LUI V0, -16504
9D000770  AC433510   SW V1, 13584(V0)
192:                     DCH6DSA = (unsigned int) &U6TXREG & 0x1FFFFFFF; // physical address convertion for uart send buffer
9D000774  3C02BF80   LUI V0, -16512
9D000778  24426620   ADDIU V0, V0, 26144
9D00077C  7C43E000   EXT V1, V0, 0, 29
9D000780  3C02BF88   LUI V0, -16504
9D000784  AC433520   SW V1, 13600(V0)
193:                     DCH6DSIZ = 1;
9D000788  3C02BF88   LUI V0, -16504
9D00078C  24030001   ADDIU V1, ZERO, 1
9D000790  AC433540   SW V1, 13632(V0)
194:                     DCH6CSIZ = 1;
9D000794  3C02BF88   LUI V0, -16504
9D000798  24030001   ADDIU V1, ZERO, 1
9D00079C  AC433570   SW V1, 13680(V0)
195:                 }
9D0007A0  03C0E821   ADDU SP, S8, ZERO
9D0007A4  8FBE0004   LW S8, 4(SP)
9D0007A8  27BD0008   ADDIU SP, SP, 8
9D0007AC  03E00008   JR RA
9D0007B0  00000000   NOP
196:                 
197:                 void Buffers(void)
198:                 {
9D0007B4  27BDFFE8   ADDIU SP, SP, -24
9D0007B8  AFBF0014   SW RA, 20(SP)
9D0007BC  AFBE0010   SW S8, 16(SP)
9D0007C0  03A0F021   ADDU S8, SP, ZERO
199:                     ring_buff_init(&buffer_one);
9D0007C4  3C02A000   LUI V0, -24576
9D0007C8  24440230   ADDIU A0, V0, 560
9D0007CC  0F400A5E   JAL 0x9D002978
9D0007D0  00000000   NOP
200:                     ring_buff_init(&buffer_two);
9D0007D4  3C02A000   LUI V0, -24576
9D0007D8  2444027C   ADDIU A0, V0, 636
9D0007DC  0F400A5E   JAL 0x9D002978
9D0007E0  00000000   NOP
201:                     ring_buff_init(&buffer_three);
9D0007E4  3C02A000   LUI V0, -24576
9D0007E8  244402C8   ADDIU A0, V0, 712
9D0007EC  0F400A5E   JAL 0x9D002978
9D0007F0  00000000   NOP
202:                     ring_buff_init(&buffer_four);
9D0007F4  3C02A000   LUI V0, -24576
9D0007F8  24440314   ADDIU A0, V0, 788
9D0007FC  0F400A5E   JAL 0x9D002978
9D000800  00000000   NOP
203:                     ring_buff_init(&buffer_five);
9D000804  3C02A000   LUI V0, -24576
9D000808  24440360   ADDIU A0, V0, 864
9D00080C  0F400A5E   JAL 0x9D002978
9D000810  00000000   NOP
204:                     ring_buff_init(&buffer_six);
9D000814  3C02A000   LUI V0, -24576
9D000818  244403AC   ADDIU A0, V0, 940
9D00081C  0F400A5E   JAL 0x9D002978
9D000820  00000000   NOP
205:                 }
9D000824  03C0E821   ADDU SP, S8, ZERO
9D000828  8FBF0014   LW RA, 20(SP)
9D00082C  8FBE0010   LW S8, 16(SP)
9D000830  27BD0018   ADDIU SP, SP, 24
9D000834  03E00008   JR RA
9D000838  00000000   NOP
206:                 
207:                 void Settings(void)
208:                 {
9D00083C  27BDFFF8   ADDIU SP, SP, -8
9D000840  AFBE0004   SW S8, 4(SP)
9D000844  03A0F021   ADDU S8, SP, ZERO
209:                 
210:                 
211:                 
212:                     //DMA 1 settings
213:                     arrayOFdmaSetting[1].dma_array = (unsigned char*) &dma_one_array;
9D000848  3C02A000   LUI V0, -24576
9D00084C  244208A8   ADDIU V0, V0, 2216
9D000850  3C03A000   LUI V1, -24576
9D000854  246303F8   ADDIU V1, V1, 1016
9D000858  AC43001C   SW V1, 28(V0)
214:                     arrayOFdmaSetting[1].dmacon = &DCH1CON;
9D00085C  3C02A000   LUI V0, -24576
9D000860  244208A8   ADDIU V0, V0, 2216
9D000864  3C03BF88   LUI V1, -16504
9D000868  24633120   ADDIU V1, V1, 12576
9D00086C  AC430020   SW V1, 32(V0)
215:                     arrayOFdmaSetting[1].con_busy_mask = _DCH1CON_CHBUSY_MASK;
9D000870  3C02A000   LUI V0, -24576
9D000874  244208A8   ADDIU V0, V0, 2216
9D000878  34038000   ORI V1, ZERO, -32768
9D00087C  AC430024   SW V1, 36(V0)
216:                     arrayOFdmaSetting[1].con_en_mask = _DCH1CON_CHEN_MASK;
9D000880  3C02A000   LUI V0, -24576
9D000884  244208A8   ADDIU V0, V0, 2216
9D000888  24030080   ADDIU V1, ZERO, 128
9D00088C  AC430028   SW V1, 40(V0)
217:                     arrayOFdmaSetting[1].dmasize = &DCH1SSIZ;
9D000890  3C02A000   LUI V0, -24576
9D000894  244208A8   ADDIU V0, V0, 2216
9D000898  3C03BF88   LUI V1, -16504
9D00089C  24633170   ADDIU V1, V1, 12656
9D0008A0  AC43002C   SW V1, 44(V0)
218:                     arrayOFdmaSetting[1].dmaecon = &DCH1ECON;
9D0008A4  3C02A000   LUI V0, -24576
9D0008A8  244208A8   ADDIU V0, V0, 2216
9D0008AC  3C03BF88   LUI V1, -16504
9D0008B0  24633130   ADDIU V1, V1, 12592
9D0008B4  AC430030   SW V1, 48(V0)
219:                     arrayOFdmaSetting[1].econ_force_mask = _DCH1ECON_CFORCE_MASK;
9D0008B8  3C02A000   LUI V0, -24576
9D0008BC  244208A8   ADDIU V0, V0, 2216
9D0008C0  24030080   ADDIU V1, ZERO, 128
9D0008C4  AC430034   SW V1, 52(V0)
220:                 
221:                 
222:                 
223:                     //DMA 2 settings
224:                     arrayOFdmaSetting[2].dma_array = (unsigned char*) &dma_two_array;
9D0008C8  3C02A000   LUI V0, -24576
9D0008CC  244208A8   ADDIU V0, V0, 2216
9D0008D0  3C03A000   LUI V1, -24576
9D0008D4  246304C0   ADDIU V1, V1, 1216
9D0008D8  AC430038   SW V1, 56(V0)
225:                     arrayOFdmaSetting[2].dmacon = &DCH2CON;
9D0008DC  3C02A000   LUI V0, -24576
9D0008E0  244208A8   ADDIU V0, V0, 2216
9D0008E4  3C03BF88   LUI V1, -16504
9D0008E8  246331E0   ADDIU V1, V1, 12768
9D0008EC  AC43003C   SW V1, 60(V0)
226:                     arrayOFdmaSetting[2].con_busy_mask = _DCH2CON_CHBUSY_MASK;
9D0008F0  3C02A000   LUI V0, -24576
9D0008F4  244208A8   ADDIU V0, V0, 2216
9D0008F8  34038000   ORI V1, ZERO, -32768
9D0008FC  AC430040   SW V1, 64(V0)
227:                     arrayOFdmaSetting[2].con_en_mask = _DCH2CON_CHEN_MASK;
9D000900  3C02A000   LUI V0, -24576
9D000904  244208A8   ADDIU V0, V0, 2216
9D000908  24030080   ADDIU V1, ZERO, 128
9D00090C  AC430044   SW V1, 68(V0)
228:                     arrayOFdmaSetting[2].dmasize = &DCH2SSIZ;
9D000910  3C02A000   LUI V0, -24576
9D000914  244208A8   ADDIU V0, V0, 2216
9D000918  3C03BF88   LUI V1, -16504
9D00091C  24633230   ADDIU V1, V1, 12848
9D000920  AC430048   SW V1, 72(V0)
229:                     arrayOFdmaSetting[2].dmaecon = &DCH2ECON;
9D000924  3C02A000   LUI V0, -24576
9D000928  244208A8   ADDIU V0, V0, 2216
9D00092C  3C03BF88   LUI V1, -16504
9D000930  246331F0   ADDIU V1, V1, 12784
9D000934  AC43004C   SW V1, 76(V0)
230:                     arrayOFdmaSetting[2].econ_force_mask = _DCH2ECON_CFORCE_MASK;
9D000938  3C02A000   LUI V0, -24576
9D00093C  244208A8   ADDIU V0, V0, 2216
9D000940  24030080   ADDIU V1, ZERO, 128
9D000944  AC430050   SW V1, 80(V0)
231:                 
232:                 
233:                     //DMA 3 settings
234:                     arrayOFdmaSetting[3].dma_array = (unsigned char*) &dma_three_array;
9D000948  3C02A000   LUI V0, -24576
9D00094C  244208A8   ADDIU V0, V0, 2216
9D000950  3C03A000   LUI V1, -24576
9D000954  24630588   ADDIU V1, V1, 1416
9D000958  AC430054   SW V1, 84(V0)
235:                     arrayOFdmaSetting[3].dmacon = &DCH3CON;
9D00095C  3C02A000   LUI V0, -24576
9D000960  244208A8   ADDIU V0, V0, 2216
9D000964  3C03BF88   LUI V1, -16504
9D000968  246332A0   ADDIU V1, V1, 12960
9D00096C  AC430058   SW V1, 88(V0)
236:                     arrayOFdmaSetting[3].con_busy_mask = _DCH3CON_CHBUSY_MASK;
9D000970  3C02A000   LUI V0, -24576
9D000974  244208A8   ADDIU V0, V0, 2216
9D000978  34038000   ORI V1, ZERO, -32768
9D00097C  AC43005C   SW V1, 92(V0)
237:                     arrayOFdmaSetting[3].con_en_mask = _DCH3CON_CHEN_MASK;
9D000980  3C02A000   LUI V0, -24576
9D000984  244208A8   ADDIU V0, V0, 2216
9D000988  24030080   ADDIU V1, ZERO, 128
9D00098C  AC430060   SW V1, 96(V0)
238:                     arrayOFdmaSetting[3].dmasize = &DCH3SSIZ;
9D000990  3C02A000   LUI V0, -24576
9D000994  244208A8   ADDIU V0, V0, 2216
9D000998  3C03BF88   LUI V1, -16504
9D00099C  246332F0   ADDIU V1, V1, 13040
9D0009A0  AC430064   SW V1, 100(V0)
239:                     arrayOFdmaSetting[3].dmaecon = &DCH3ECON;
9D0009A4  3C02A000   LUI V0, -24576
9D0009A8  244208A8   ADDIU V0, V0, 2216
9D0009AC  3C03BF88   LUI V1, -16504
9D0009B0  246332B0   ADDIU V1, V1, 12976
9D0009B4  AC430068   SW V1, 104(V0)
240:                     arrayOFdmaSetting[3].econ_force_mask = _DCH3ECON_CFORCE_MASK;
9D0009B8  3C02A000   LUI V0, -24576
9D0009BC  244208A8   ADDIU V0, V0, 2216
9D0009C0  24030080   ADDIU V1, ZERO, 128
9D0009C4  AC43006C   SW V1, 108(V0)
241:                 
242:                 
243:                     //DMA 4 settings
244:                     arrayOFdmaSetting[4].dma_array = (unsigned char*) &dma_four_array;
9D0009C8  3C02A000   LUI V0, -24576
9D0009CC  244208A8   ADDIU V0, V0, 2216
9D0009D0  3C03A000   LUI V1, -24576
9D0009D4  24630650   ADDIU V1, V1, 1616
9D0009D8  AC430070   SW V1, 112(V0)
245:                     arrayOFdmaSetting[4].dmacon = &DCH4CON;
9D0009DC  3C02A000   LUI V0, -24576
9D0009E0  244208A8   ADDIU V0, V0, 2216
9D0009E4  3C03BF88   LUI V1, -16504
9D0009E8  24633360   ADDIU V1, V1, 13152
9D0009EC  AC430074   SW V1, 116(V0)
246:                     arrayOFdmaSetting[4].con_busy_mask = _DCH4CON_CHBUSY_MASK;
9D0009F0  3C02A000   LUI V0, -24576
9D0009F4  244208A8   ADDIU V0, V0, 2216
9D0009F8  34038000   ORI V1, ZERO, -32768
9D0009FC  AC430078   SW V1, 120(V0)
247:                     arrayOFdmaSetting[4].con_en_mask = _DCH4CON_CHEN_MASK;
9D000A00  3C02A000   LUI V0, -24576
9D000A04  244208A8   ADDIU V0, V0, 2216
9D000A08  24030080   ADDIU V1, ZERO, 128
9D000A0C  AC43007C   SW V1, 124(V0)
248:                     arrayOFdmaSetting[4].dmasize = &DCH4SSIZ;
9D000A10  3C02A000   LUI V0, -24576
9D000A14  244208A8   ADDIU V0, V0, 2216
9D000A18  3C03BF88   LUI V1, -16504
9D000A1C  246333B0   ADDIU V1, V1, 13232
9D000A20  AC430080   SW V1, 128(V0)
249:                     arrayOFdmaSetting[4].dmaecon = &DCH4ECON;
9D000A24  3C02A000   LUI V0, -24576
9D000A28  244208A8   ADDIU V0, V0, 2216
9D000A2C  3C03BF88   LUI V1, -16504
9D000A30  24633370   ADDIU V1, V1, 13168
9D000A34  AC430084   SW V1, 132(V0)
250:                     arrayOFdmaSetting[4].econ_force_mask = _DCH4ECON_CFORCE_MASK;
9D000A38  3C02A000   LUI V0, -24576
9D000A3C  244208A8   ADDIU V0, V0, 2216
9D000A40  24030080   ADDIU V1, ZERO, 128
9D000A44  AC430088   SW V1, 136(V0)
251:                 
252:                 
253:                     //DMA 5 settings
254:                     arrayOFdmaSetting[5].dma_array = (unsigned char*) &dma_five_array;
9D000A48  3C02A000   LUI V0, -24576
9D000A4C  244208A8   ADDIU V0, V0, 2216
9D000A50  3C03A000   LUI V1, -24576
9D000A54  24630718   ADDIU V1, V1, 1816
9D000A58  AC43008C   SW V1, 140(V0)
255:                     arrayOFdmaSetting[5].dmacon = &DCH5CON;
9D000A5C  3C02A000   LUI V0, -24576
9D000A60  244208A8   ADDIU V0, V0, 2216
9D000A64  3C03BF88   LUI V1, -16504
9D000A68  24633420   ADDIU V1, V1, 13344
9D000A6C  AC430090   SW V1, 144(V0)
256:                     arrayOFdmaSetting[5].con_busy_mask = _DCH5CON_CHBUSY_MASK;
9D000A70  3C02A000   LUI V0, -24576
9D000A74  244208A8   ADDIU V0, V0, 2216
9D000A78  34038000   ORI V1, ZERO, -32768
9D000A7C  AC430094   SW V1, 148(V0)
257:                     arrayOFdmaSetting[5].con_en_mask = _DCH5CON_CHEN_MASK;
9D000A80  3C02A000   LUI V0, -24576
9D000A84  244208A8   ADDIU V0, V0, 2216
9D000A88  24030080   ADDIU V1, ZERO, 128
9D000A8C  AC430098   SW V1, 152(V0)
258:                     arrayOFdmaSetting[5].dmasize = &DCH5SSIZ;
9D000A90  3C02A000   LUI V0, -24576
9D000A94  244208A8   ADDIU V0, V0, 2216
9D000A98  3C03BF88   LUI V1, -16504
9D000A9C  24633470   ADDIU V1, V1, 13424
9D000AA0  AC43009C   SW V1, 156(V0)
259:                     arrayOFdmaSetting[5].dmaecon = &DCH5ECON;
9D000AA4  3C02A000   LUI V0, -24576
9D000AA8  244208A8   ADDIU V0, V0, 2216
9D000AAC  3C03BF88   LUI V1, -16504
9D000AB0  24633430   ADDIU V1, V1, 13360
9D000AB4  AC4300A0   SW V1, 160(V0)
260:                     arrayOFdmaSetting[5].econ_force_mask = _DCH5ECON_CFORCE_MASK;
9D000AB8  3C02A000   LUI V0, -24576
9D000ABC  244208A8   ADDIU V0, V0, 2216
9D000AC0  24030080   ADDIU V1, ZERO, 128
9D000AC4  AC4300A4   SW V1, 164(V0)
261:                 
262:                 
263:                     //DMA 6 settings
264:                     arrayOFdmaSetting[6].dma_array = (unsigned char*) &dma_six_array;
9D000AC8  3C02A000   LUI V0, -24576
9D000ACC  244208A8   ADDIU V0, V0, 2216
9D000AD0  3C03A000   LUI V1, -24576
9D000AD4  246307E0   ADDIU V1, V1, 2016
9D000AD8  AC4300A8   SW V1, 168(V0)
265:                     arrayOFdmaSetting[6].dmacon = &DCH6CON;
9D000ADC  3C02A000   LUI V0, -24576
9D000AE0  244208A8   ADDIU V0, V0, 2216
9D000AE4  3C03BF88   LUI V1, -16504
9D000AE8  246334E0   ADDIU V1, V1, 13536
9D000AEC  AC4300AC   SW V1, 172(V0)
266:                     arrayOFdmaSetting[6].con_busy_mask = _DCH6CON_CHBUSY_MASK;
9D000AF0  3C02A000   LUI V0, -24576
9D000AF4  244208A8   ADDIU V0, V0, 2216
9D000AF8  34038000   ORI V1, ZERO, -32768
9D000AFC  AC4300B0   SW V1, 176(V0)
267:                     arrayOFdmaSetting[6].con_en_mask = _DCH6CON_CHEN_MASK;
9D000B00  3C02A000   LUI V0, -24576
9D000B04  244208A8   ADDIU V0, V0, 2216
9D000B08  24030080   ADDIU V1, ZERO, 128
9D000B0C  AC4300B4   SW V1, 180(V0)
268:                     arrayOFdmaSetting[6].dmasize = &DCH6SSIZ;
9D000B10  3C02A000   LUI V0, -24576
9D000B14  244208A8   ADDIU V0, V0, 2216
9D000B18  3C03BF88   LUI V1, -16504
9D000B1C  24633530   ADDIU V1, V1, 13616
9D000B20  AC4300B8   SW V1, 184(V0)
269:                     arrayOFdmaSetting[6].dmaecon = &DCH6ECON;
9D000B24  3C02A000   LUI V0, -24576
9D000B28  244208A8   ADDIU V0, V0, 2216
9D000B2C  3C03BF88   LUI V1, -16504
9D000B30  246334F0   ADDIU V1, V1, 13552
9D000B34  AC4300BC   SW V1, 188(V0)
270:                     arrayOFdmaSetting[6].econ_force_mask = _DCH6ECON_CFORCE_MASK;
9D000B38  3C02A000   LUI V0, -24576
9D000B3C  244208A8   ADDIU V0, V0, 2216
9D000B40  24030080   ADDIU V1, ZERO, 128
9D000B44  AC4300C0   SW V1, 192(V0)
271:                 }
9D000B48  03C0E821   ADDU SP, S8, ZERO
9D000B4C  8FBE0004   LW S8, 4(SP)
9D000B50  27BD0008   ADDIU SP, SP, 8
9D000B54  03E00008   JR RA
9D000B58  00000000   NOP
272:                 
273:                 void Queue(void)
274:                 {
9D000B5C  27BDFFE8   ADDIU SP, SP, -24
9D000B60  AFBF0014   SW RA, 20(SP)
9D000B64  AFBE0010   SW S8, 16(SP)
9D000B68  03A0F021   ADDU S8, SP, ZERO
275:                 
276:                 
277:                     DMA_one.queue_begin(arrayOFdmaSetting, 1);
9D000B6C  3C02A000   LUI V0, -24576
9D000B70  24440B20   ADDIU A0, V0, 2848
9D000B74  3C02A000   LUI V0, -24576
9D000B78  244508A8   ADDIU A1, V0, 2216
9D000B7C  24060001   ADDIU A2, ZERO, 1
9D000B80  0F400359   JAL 0x9D000D64
9D000B84  00000000   NOP
278:                     DMA_two.queue_begin(arrayOFdmaSetting, 2);
9D000B88  3C02A000   LUI V0, -24576
9D000B8C  24440F5C   ADDIU A0, V0, 3932
9D000B90  3C02A000   LUI V0, -24576
9D000B94  244508A8   ADDIU A1, V0, 2216
9D000B98  24060002   ADDIU A2, ZERO, 2
9D000B9C  0F400359   JAL 0x9D000D64
9D000BA0  00000000   NOP
279:                     DMA_three.queue_begin(arrayOFdmaSetting, 3);
9D000BA4  3C02A000   LUI V0, -24576
9D000BA8  24441398   ADDIU A0, V0, 5016
9D000BAC  3C02A000   LUI V0, -24576
9D000BB0  244508A8   ADDIU A1, V0, 2216
9D000BB4  24060003   ADDIU A2, ZERO, 3
9D000BB8  0F400359   JAL 0x9D000D64
9D000BBC  00000000   NOP
280:                     DMA_four.queue_begin(arrayOFdmaSetting, 4);
9D000BC0  3C02A000   LUI V0, -24576
9D000BC4  244417D4   ADDIU A0, V0, 6100
9D000BC8  3C02A000   LUI V0, -24576
9D000BCC  244508A8   ADDIU A1, V0, 2216
9D000BD0  24060004   ADDIU A2, ZERO, 4
9D000BD4  0F400359   JAL 0x9D000D64
9D000BD8  00000000   NOP
281:                     DMA_five.queue_begin(arrayOFdmaSetting, 5);
9D000BDC  3C02A000   LUI V0, -24576
9D000BE0  24441C10   ADDIU A0, V0, 7184
9D000BE4  3C02A000   LUI V0, -24576
9D000BE8  244508A8   ADDIU A1, V0, 2216
9D000BEC  24060005   ADDIU A2, ZERO, 5
9D000BF0  0F400359   JAL 0x9D000D64
9D000BF4  00000000   NOP
282:                     DMA_six.queue_begin(arrayOFdmaSetting, 6);
9D000BF8  3C02A000   LUI V0, -24576
9D000BFC  2444204C   ADDIU A0, V0, 8268
9D000C00  3C02A000   LUI V0, -24576
9D000C04  244508A8   ADDIU A1, V0, 2216
9D000C08  24060006   ADDIU A2, ZERO, 6
9D000C0C  0F400359   JAL 0x9D000D64
9D000C10  00000000   NOP
283:                 
284:                     queue_pointer[1] = &DMA_one;
9D000C14  3C02A000   LUI V0, -24576
9D000C18  2442096C   ADDIU V0, V0, 2412
9D000C1C  3C03A000   LUI V1, -24576
9D000C20  24630B20   ADDIU V1, V1, 2848
9D000C24  AC430004   SW V1, 4(V0)
285:                     queue_pointer[2] = &DMA_two;
9D000C28  3C02A000   LUI V0, -24576
9D000C2C  2442096C   ADDIU V0, V0, 2412
9D000C30  3C03A000   LUI V1, -24576
9D000C34  24630F5C   ADDIU V1, V1, 3932
9D000C38  AC430008   SW V1, 8(V0)
286:                     queue_pointer[3] = &DMA_three;
9D000C3C  3C02A000   LUI V0, -24576
9D000C40  2442096C   ADDIU V0, V0, 2412
9D000C44  3C03A000   LUI V1, -24576
9D000C48  24631398   ADDIU V1, V1, 5016
9D000C4C  AC43000C   SW V1, 12(V0)
287:                     queue_pointer[4] = &DMA_four;
9D000C50  3C02A000   LUI V0, -24576
9D000C54  2442096C   ADDIU V0, V0, 2412
9D000C58  3C03A000   LUI V1, -24576
9D000C5C  246317D4   ADDIU V1, V1, 6100
9D000C60  AC430010   SW V1, 16(V0)
288:                     queue_pointer[5] = &DMA_five;
9D000C64  3C02A000   LUI V0, -24576
9D000C68  2442096C   ADDIU V0, V0, 2412
9D000C6C  3C03A000   LUI V1, -24576
9D000C70  24631C10   ADDIU V1, V1, 7184
9D000C74  AC430014   SW V1, 20(V0)
289:                     queue_pointer[6] = &DMA_six;
9D000C78  3C02A000   LUI V0, -24576
9D000C7C  2442096C   ADDIU V0, V0, 2412
9D000C80  3C03A000   LUI V1, -24576
9D000C84  2463204C   ADDIU V1, V1, 8268
9D000C88  AC430018   SW V1, 24(V0)
290:                 
291:                 
292:                 
293:                     receive_one.begin(&buffer_one, queue_pointer);
9D000C8C  3C02A000   LUI V0, -24576
9D000C90  24440988   ADDIU A0, V0, 2440
9D000C94  3C02A000   LUI V0, -24576
9D000C98  24450230   ADDIU A1, V0, 560
9D000C9C  3C02A000   LUI V0, -24576
9D000CA0  2446096C   ADDIU A2, V0, 2412
9D000CA4  0F400879   JAL 0x9D0021E4
9D000CA8  00000000   NOP
294:                     receive_two.begin(&buffer_two, queue_pointer);
9D000CAC  3C02A000   LUI V0, -24576
9D000CB0  244409CC   ADDIU A0, V0, 2508
9D000CB4  3C02A000   LUI V0, -24576
9D000CB8  2445027C   ADDIU A1, V0, 636
9D000CBC  3C02A000   LUI V0, -24576
9D000CC0  2446096C   ADDIU A2, V0, 2412
9D000CC4  0F400879   JAL 0x9D0021E4
9D000CC8  00000000   NOP
295:                     receive_three.begin(&buffer_three, queue_pointer);
9D000CCC  3C02A000   LUI V0, -24576
9D000CD0  24440A10   ADDIU A0, V0, 2576
9D000CD4  3C02A000   LUI V0, -24576
9D000CD8  244502C8   ADDIU A1, V0, 712
9D000CDC  3C02A000   LUI V0, -24576
9D000CE0  2446096C   ADDIU A2, V0, 2412
9D000CE4  0F400879   JAL 0x9D0021E4
9D000CE8  00000000   NOP
296:                     receive_four.begin(&buffer_four, queue_pointer);
9D000CEC  3C02A000   LUI V0, -24576
9D000CF0  24440A54   ADDIU A0, V0, 2644
9D000CF4  3C02A000   LUI V0, -24576
9D000CF8  24450314   ADDIU A1, V0, 788
9D000CFC  3C02A000   LUI V0, -24576
9D000D00  2446096C   ADDIU A2, V0, 2412
9D000D04  0F400879   JAL 0x9D0021E4
9D000D08  00000000   NOP
297:                     receive_five.begin(&buffer_five, queue_pointer);
9D000D0C  3C02A000   LUI V0, -24576
9D000D10  24440A98   ADDIU A0, V0, 2712
9D000D14  3C02A000   LUI V0, -24576
9D000D18  24450360   ADDIU A1, V0, 864
9D000D1C  3C02A000   LUI V0, -24576
9D000D20  2446096C   ADDIU A2, V0, 2412
9D000D24  0F400879   JAL 0x9D0021E4
9D000D28  00000000   NOP
298:                     receive_six.begin(&buffer_six, queue_pointer);
9D000D2C  3C02A000   LUI V0, -24576
9D000D30  24440ADC   ADDIU A0, V0, 2780
9D000D34  3C02A000   LUI V0, -24576
9D000D38  244503AC   ADDIU A1, V0, 940
9D000D3C  3C02A000   LUI V0, -24576
9D000D40  2446096C   ADDIU A2, V0, 2412
9D000D44  0F400879   JAL 0x9D0021E4
9D000D48  00000000   NOP
299:                 }
9D000D4C  03C0E821   ADDU SP, S8, ZERO
9D000D50  8FBF0014   LW RA, 20(SP)
9D000D54  8FBE0010   LW S8, 16(SP)
9D000D58  27BD0018   ADDIU SP, SP, 24
9D000D5C  03E00008   JR RA
9D000D60  00000000   NOP
300:                 
301:                 //void Timer1(void) {
302:                 //    T1CONbits.TCS = 0; // perifial clock as source
303:                 //    T1CONbits.TCKPS = 0b11; //256 prescalar
304:                 //    T1CONbits.TGATE = 0;
305:                 //    TMR1 = 31250;
306:                 //    IEC0SET = _IEC0_T1IE_MASK;
307:                 //    IPC1SET = ((0x7 << _IPC1_T1IP_POSITION) | (0x3 << _IPC1_T1IS_POSITION));
308:                 //    T1CONbits.ON = 1;
309:                 //
310:                 //
311:                 //}
---  c:/users/igor/mplabxprojects/routerpic.x/fasttransfer.cpp  -----------------------------------------
1:                   #include <xc.h>
2:                   #include <math.h>
3:                   #include <stdio.h>
4:                   #include <stdint.h>
5:                   #include <stdbool.h>
6:                   #include "queue.h"
7:                   #include "FastTransfer.h"
8:                   
9:                   struct ringBuff
10:                  { // this is where the send data is stored before sending
11:                      unsigned char buf[BUFFER_SIZE];
12:                      int head;
13:                      int tail;
14:                      int count;
15:                  };
16:                  
17:                  
18:                  //Captures address of receive array, the max data address, the address of the module, true/false if AKNAKs are wanted and the Serial address
19:                  
20:                  void FastTransfer::begin(struct ringBuff *buff, Queue_handler * queue_to_hand_over[7])
21:                  {
9D0021E4  27BDFFF0   ADDIU SP, SP, -16
9D0021E8  AFBE000C   SW S8, 12(SP)
9D0021EC  03A0F021   ADDU S8, SP, ZERO
9D0021F0  AFC40010   SW A0, 16(S8)
9D0021F4  AFC50014   SW A1, 20(S8)
9D0021F8  AFC60018   SW A2, 24(S8)
22:                  
23:                      input_buffer = buff;
9D0021FC  8FC20010   LW V0, 16(S8)
9D002200  8FC30014   LW V1, 20(S8)
9D002204  AC430020   SW V1, 32(V0)
24:                      int t;
25:                      for (t = 0; t >= 8; t++)
9D002208  AFC00000   SW ZERO, 0(S8)
9D00220C  0B400893   J 0x9D00224C
9D002210  00000000   NOP
9D002240  8FC20000   LW V0, 0(S8)
9D002244  24420001   ADDIU V0, V0, 1
9D002248  AFC20000   SW V0, 0(S8)
9D00224C  8FC20000   LW V0, 0(S8)
9D002250  28420008   SLTI V0, V0, 8
9D002254  38420001   XORI V0, V0, 1
9D002258  304200FF   ANDI V0, V0, 255
9D00225C  1440FFED   BNE V0, ZERO, 0x9D002214
9D002260  00000000   NOP
26:                      {
27:                          queue_to_send[t] = queue_to_hand_over[t];
9D002214  8FC20000   LW V0, 0(S8)
9D002218  00021080   SLL V0, V0, 2
9D00221C  8FC30018   LW V1, 24(S8)
9D002220  00621021   ADDU V0, V1, V0
9D002224  8C430000   LW V1, 0(V0)
9D002228  8FC40010   LW A0, 16(S8)
9D00222C  8FC20000   LW V0, 0(S8)
9D002230  2442000A   ADDIU V0, V0, 10
9D002234  00021080   SLL V0, V0, 2
9D002238  00821021   ADDU V0, A0, V0
9D00223C  AC430000   SW V1, 0(V0)
28:                      }
29:                  
30:                  }
9D002264  03C0E821   ADDU SP, S8, ZERO
9D002268  8FBE000C   LW S8, 12(SP)
9D00226C  27BD0010   ADDIU SP, SP, 16
9D002270  03E00008   JR RA
9D002274  00000000   NOP
31:                  
32:                  //CRC Calculator
33:                  
34:                  unsigned char FastTransfer::CRC8(const unsigned char * data, unsigned char len)
35:                  {
9D002278  27BDFFF0   ADDIU SP, SP, -16
9D00227C  AFBE000C   SW S8, 12(SP)
9D002280  03A0F021   ADDU S8, SP, ZERO
9D002284  AFC40010   SW A0, 16(S8)
9D002288  AFC50014   SW A1, 20(S8)
9D00228C  00C01021   ADDU V0, A2, ZERO
9D002290  A3C20018   SB V0, 24(S8)
36:                      unsigned char crc = 0x00;
9D002294  A3C00000   SB ZERO, 0(S8)
37:                      while (len--)
9D002298  0B4008CD   J 0x9D002334
9D00229C  00000000   NOP
9D002334  93C20018   LBU V0, 24(S8)
9D002338  0002102B   SLTU V0, ZERO, V0
9D00233C  304200FF   ANDI V0, V0, 255
9D002340  93C30018   LBU V1, 24(S8)
9D002344  2463FFFF   ADDIU V1, V1, -1
9D002348  A3C30018   SB V1, 24(S8)
9D00234C  1440FFD4   BNE V0, ZERO, 0x9D0022A0
9D002350  00000000   NOP
38:                      {
39:                          unsigned char extract = *data++;
9D0022A0  8FC20014   LW V0, 20(S8)
9D0022A4  90420000   LBU V0, 0(V0)
9D0022A8  A3C20001   SB V0, 1(S8)
9D0022AC  8FC20014   LW V0, 20(S8)
9D0022B0  24420001   ADDIU V0, V0, 1
9D0022B4  AFC20014   SW V0, 20(S8)
40:                          for (unsigned char tempI = 8; tempI; tempI--)
9D0022B8  24020008   ADDIU V0, ZERO, 8
9D0022BC  A3C20002   SB V0, 2(S8)
9D0022C0  0B4008C8   J 0x9D002320
9D0022C4  00000000   NOP
9D002314  93C20002   LBU V0, 2(S8)
9D002318  2442FFFF   ADDIU V0, V0, -1
9D00231C  A3C20002   SB V0, 2(S8)
9D002320  93C20002   LBU V0, 2(S8)
9D002324  0002102B   SLTU V0, ZERO, V0
9D002328  304200FF   ANDI V0, V0, 255
9D00232C  1440FFE6   BNE V0, ZERO, 0x9D0022C8
9D002330  00000000   NOP
41:                          {
42:                              unsigned char sum = (crc ^ extract) & 0x01;
9D0022C8  93C30000   LBU V1, 0(S8)
9D0022CC  93C20001   LBU V0, 1(S8)
9D0022D0  00621026   XOR V0, V1, V0
9D0022D4  304200FF   ANDI V0, V0, 255
9D0022D8  30420001   ANDI V0, V0, 1
9D0022DC  A3C20003   SB V0, 3(S8)
43:                              crc >>= 1;
9D0022E0  93C20000   LBU V0, 0(S8)
9D0022E4  00021043   SRA V0, V0, 1
9D0022E8  A3C20000   SB V0, 0(S8)
44:                              if (sum)
9D0022EC  93C20003   LBU V0, 3(S8)
9D0022F0  10400005   BEQ V0, ZERO, 0x9D002308
9D0022F4  00000000   NOP
45:                              {
46:                                  crc ^= polynomial;
9D0022F8  93C30000   LBU V1, 0(S8)
9D0022FC  2402FF8C   ADDIU V0, ZERO, -116
9D002300  00621026   XOR V0, V1, V0
9D002304  A3C20000   SB V0, 0(S8)
47:                              }
48:                              extract >>= 1;
9D002308  93C20001   LBU V0, 1(S8)
9D00230C  00021043   SRA V0, V0, 1
9D002310  A3C20001   SB V0, 1(S8)
49:                          }
50:                      }
51:                      return crc;
9D002354  93C20000   LBU V0, 0(S8)
52:                  }
9D002358  03C0E821   ADDU SP, S8, ZERO
9D00235C  8FBE000C   LW S8, 12(SP)
9D002360  27BD0010   ADDIU SP, SP, 16
9D002364  03E00008   JR RA
9D002368  00000000   NOP
53:                  
54:                  bool FastTransfer::receiveData()
55:                  {
9D00236C  27BDFFD0   ADDIU SP, SP, -48
9D002370  AFBF002C   SW RA, 44(SP)
9D002374  AFBE0028   SW S8, 40(SP)
9D002378  AFB10024   SW S1, 36(SP)
9D00237C  AFB00020   SW S0, 32(SP)
9D002380  03A0F021   ADDU S8, SP, ZERO
9D002384  AFC40030   SW A0, 48(S8)
56:                  
57:                      //start off by looking for the header bytes. If they were already found in a previous call, skip it.
58:                      if (rx_len == 0)
9D002388  8FC20030   LW V0, 48(S8)
9D00238C  90420005   LBU V0, 5(V0)
9D002390  14400088   BNE V0, ZERO, 0x9D0025B4
9D002394  00000000   NOP
59:                      {
60:                          //this size check may be redundant due to the size check below, but for now I'll leave it the way it is.
61:                          if (ringBufS_size(input_buffer) > 4)
9D002398  8FC20030   LW V0, 48(S8)
9D00239C  8C420020   LW V0, 32(V0)
9D0023A0  8FC40030   LW A0, 48(S8)
9D0023A4  00402821   ADDU A1, V0, ZERO
9D0023A8  0F400A1C   JAL 0x9D002870
9D0023AC  00000000   NOP
9D0023B0  28420005   SLTI V0, V0, 5
9D0023B4  38420001   XORI V0, V0, 1
9D0023B8  304200FF   ANDI V0, V0, 255
9D0023BC  1040007D   BEQ V0, ZERO, 0x9D0025B4
9D0023C0  00000000   NOP
62:                          {
63:                              //this will block until a 0x06 is found or buffer size becomes less then 3.
64:                              while (ringBufS_get(input_buffer) != 0x06)
9D0023C4  0B400905   J 0x9D002414
9D0023C8  00000000   NOP
9D002414  8FC20030   LW V0, 48(S8)
9D002418  8C420020   LW V0, 32(V0)
9D00241C  8FC40030   LW A0, 48(S8)
9D002420  00402821   ADDU A1, V0, ZERO
9D002424  0F4009F3   JAL 0x9D0027CC
9D002428  00000000   NOP
9D00242C  38420006   XORI V0, V0, 6
9D002430  0002102B   SLTU V0, ZERO, V0
9D002434  304200FF   ANDI V0, V0, 255
9D002438  1440FFE4   BNE V0, ZERO, 0x9D0023CC
9D00243C  00000000   NOP
65:                              {
66:                                  //This will trash any preamble junk in the serial buffer
67:                                  //but we need to make sure there is enough in the buffer to process while we trash the rest
68:                                  //if the buffer becomes too empty, we will escape and try again on the next call
69:                                  alignErrorCounter++; //increments the counter whenever a byte is trashed
9D0023CC  8FC20030   LW V0, 48(S8)
9D0023D0  8C420010   LW V0, 16(V0)
9D0023D4  24430001   ADDIU V1, V0, 1
9D0023D8  8FC20030   LW V0, 48(S8)
9D0023DC  AC430010   SW V1, 16(V0)
70:                                  if (ringBufS_size(input_buffer) < 5)
9D0023E0  8FC20030   LW V0, 48(S8)
9D0023E4  8C420020   LW V0, 32(V0)
9D0023E8  8FC40030   LW A0, 48(S8)
9D0023EC  00402821   ADDU A1, V0, ZERO
9D0023F0  0F400A1C   JAL 0x9D002870
9D0023F4  00000000   NOP
9D0023F8  28420005   SLTI V0, V0, 5
9D0023FC  304200FF   ANDI V0, V0, 255
9D002400  10400004   BEQ V0, ZERO, 0x9D002414
9D002404  00000000   NOP
71:                                      return false;
9D002408  00001021   ADDU V0, ZERO, ZERO
9D00240C  0B4009EB   J 0x9D0027AC
9D002410  00000000   NOP
72:                              }
73:                              if (ringBufS_get(input_buffer) == 0x85)
9D002440  8FC20030   LW V0, 48(S8)
9D002444  8C420020   LW V0, 32(V0)
9D002448  8FC40030   LW A0, 48(S8)
9D00244C  00402821   ADDU A1, V0, ZERO
9D002450  0F4009F3   JAL 0x9D0027CC
9D002454  00000000   NOP
9D002458  38420085   XORI V0, V0, 133
9D00245C  2C420001   SLTIU V0, V0, 1
9D002460  304200FF   ANDI V0, V0, 255
9D002464  10400053   BEQ V0, ZERO, 0x9D0025B4
9D002468  00000000   NOP
74:                              {
75:                                  rx_address = ringBufS_get(input_buffer); // pulls the address
9D00246C  8FC20030   LW V0, 48(S8)
9D002470  8C420020   LW V0, 32(V0)
9D002474  8FC40030   LW A0, 48(S8)
9D002478  00402821   ADDU A1, V0, ZERO
9D00247C  0F4009F3   JAL 0x9D0027CC
9D002480  00000000   NOP
9D002484  00401821   ADDU V1, V0, ZERO
9D002488  8FC20030   LW V0, 48(S8)
9D00248C  A043001C   SB V1, 28(V0)
76:                                  returnAddress = ringBufS_get(input_buffer); // pulls where the message came from
9D002490  8FC20030   LW V0, 48(S8)
9D002494  8C420020   LW V0, 32(V0)
9D002498  8FC40030   LW A0, 48(S8)
9D00249C  00402821   ADDU A1, V0, ZERO
9D0024A0  0F4009F3   JAL 0x9D0027CC
9D0024A4  00000000   NOP
9D0024A8  00401821   ADDU V1, V0, ZERO
9D0024AC  8FC20030   LW V0, 48(S8)
9D0024B0  A0430008   SB V1, 8(V0)
77:                                  rx_len = ringBufS_get(input_buffer); // pulls the length
9D0024B4  8FC20030   LW V0, 48(S8)
9D0024B8  8C420020   LW V0, 32(V0)
9D0024BC  8FC40030   LW A0, 48(S8)
9D0024C0  00402821   ADDU A1, V0, ZERO
9D0024C4  0F4009F3   JAL 0x9D0027CC
9D0024C8  00000000   NOP
9D0024CC  00401821   ADDU V1, V0, ZERO
9D0024D0  8FC20030   LW V0, 48(S8)
9D0024D4  A0430005   SB V1, 5(V0)
78:                                  //make sure the address received is a match for this module if not throw the packet away
79:                                  if ((rx_address > 6) || (rx_address < 1))
9D0024D8  8FC20030   LW V0, 48(S8)
9D0024DC  9042001C   LBU V0, 28(V0)
9D0024E0  2C420007   SLTIU V0, V0, 7
9D0024E4  10400005   BEQ V0, ZERO, 0x9D0024FC
9D0024E8  00000000   NOP
9D0024EC  8FC20030   LW V0, 48(S8)
9D0024F0  9042001C   LBU V0, 28(V0)
9D0024F4  14400020   BNE V0, ZERO, 0x9D002578
9D0024F8  00000000   NOP
80:                                  {
81:                                      rx_len = 0;
9D0024FC  8FC20030   LW V0, 48(S8)
9D002500  A0400005   SB ZERO, 5(V0)
82:                                      addressErrorCounter++; // increments a counter whenever the wrong address is received
9D002504  8FC20030   LW V0, 48(S8)
9D002508  8C420018   LW V0, 24(V0)
9D00250C  24430001   ADDIU V1, V0, 1
9D002510  8FC20030   LW V0, 48(S8)
9D002514  AC430018   SW V1, 24(V0)
83:                                      //if the address does not match the buffer is flushed for the size of
84:                                      //the data packet plus one for the CRC
85:                                      for (int u = 0; u <= (rx_len + 3); u++)
9D002518  AFC00018   SW ZERO, 24(S8)
9D00251C  0B400952   J 0x9D002548
9D002520  00000000   NOP
9D00253C  8FC20018   LW V0, 24(S8)
9D002540  24420001   ADDIU V0, V0, 1
9D002544  AFC20018   SW V0, 24(S8)
9D002548  8FC20030   LW V0, 48(S8)
9D00254C  90420005   LBU V0, 5(V0)
9D002550  24430003   ADDIU V1, V0, 3
9D002554  8FC20018   LW V0, 24(S8)
9D002558  0062102A   SLT V0, V1, V0
9D00255C  38420001   XORI V0, V0, 1
9D002560  304200FF   ANDI V0, V0, 255
9D002564  1440FFEF   BNE V0, ZERO, 0x9D002524
9D002568  00000000   NOP
86:                                      {
87:                                          ringBufS_get(input_buffer);
9D002524  8FC20030   LW V0, 48(S8)
9D002528  8C420020   LW V0, 32(V0)
9D00252C  8FC40030   LW A0, 48(S8)
9D002530  00402821   ADDU A1, V0, ZERO
9D002534  0F4009F3   JAL 0x9D0027CC
9D002538  00000000   NOP
88:                                      }
89:                                      return false;
9D00256C  00001021   ADDU V0, ZERO, ZERO
9D002570  0B4009EB   J 0x9D0027AC
9D002574  00000000   NOP
90:                                  }
91:                                  // if the address matches the a dynamic buffer is created to store the received data
92:                                  rx_buffer = (unsigned char*) malloc(rx_len + 1);
9D002578  8FC20030   LW V0, 48(S8)
9D00257C  90420005   LBU V0, 5(V0)
9D002580  24420001   ADDIU V0, V0, 1
9D002584  00402021   ADDU A0, V0, ZERO
9D002588  0F400B1D   JAL malloc
9D00258C  00000000   NOP
9D002590  00401821   ADDU V1, V0, ZERO
9D002594  8FC20030   LW V0, 48(S8)
9D002598  AC430000   SW V1, 0(V0)
93:                                  if (rx_buffer == NULL)
9D00259C  8FC20030   LW V0, 48(S8)
9D0025A0  8C420000   LW V0, 0(V0)
9D0025A4  14400003   BNE V0, ZERO, 0x9D0025B4
9D0025A8  00000000   NOP
94:                                  { //oops!
95:                                      while(1);
9D0025AC  0B40096B   J 0x9D0025AC
9D0025B0  00000000   NOP
96:                                  }
97:                              }
98:                          }
99:                      }
100:                 
101:                     //we get here if we already found the header bytes, the address matched what we know, and now we are byte aligned.
102:                     if (rx_len != 0)
9D0025B4  8FC20030   LW V0, 48(S8)
9D0025B8  90420005   LBU V0, 5(V0)
9D0025BC  1040007A   BEQ V0, ZERO, 0x9D0027A8
9D0025C0  00000000   NOP
103:                     {
104:                 
105:                         while (ringBufS_size(input_buffer) && rx_array_inx <= rx_len)
9D0025C4  0B400984   J 0x9D002610
9D0025C8  00000000   NOP
9D002610  8FC20030   LW V0, 48(S8)
9D002614  8C420020   LW V0, 32(V0)
9D002618  8FC40030   LW A0, 48(S8)
9D00261C  00402821   ADDU A1, V0, ZERO
9D002620  0F400A1C   JAL 0x9D002870
9D002624  00000000   NOP
9D002628  1040000B   BEQ V0, ZERO, 0x9D002658
9D00262C  00000000   NOP
9D002630  8FC20030   LW V0, 48(S8)
9D002634  90430004   LBU V1, 4(V0)
9D002638  8FC20030   LW V0, 48(S8)
9D00263C  90420005   LBU V0, 5(V0)
9D002640  0043102B   SLTU V0, V0, V1
9D002644  14400004   BNE V0, ZERO, 0x9D002658
9D002648  00000000   NOP
9D00264C  24020001   ADDIU V0, ZERO, 1
9D002650  0B400997   J 0x9D00265C
9D002654  00000000   NOP
9D002658  00001021   ADDU V0, ZERO, ZERO
9D00265C  1440FFDB   BNE V0, ZERO, 0x9D0025CC
9D002660  00000000   NOP
106:                         {
107:                             rx_buffer[rx_array_inx++] = ringBufS_get(input_buffer);
9D0025CC  8FC20030   LW V0, 48(S8)
9D0025D0  8C430000   LW V1, 0(V0)
9D0025D4  8FC20030   LW V0, 48(S8)
9D0025D8  90500004   LBU S0, 4(V0)
9D0025DC  02001021   ADDU V0, S0, ZERO
9D0025E0  00628821   ADDU S1, V1, V0
9D0025E4  8FC20030   LW V0, 48(S8)
9D0025E8  8C420020   LW V0, 32(V0)
9D0025EC  8FC40030   LW A0, 48(S8)
9D0025F0  00402821   ADDU A1, V0, ZERO
9D0025F4  0F4009F3   JAL 0x9D0027CC
9D0025F8  00000000   NOP
9D0025FC  A2220000   SB V0, 0(S1)
9D002600  26020001   ADDIU V0, S0, 1
9D002604  304300FF   ANDI V1, V0, 255
9D002608  8FC20030   LW V0, 48(S8)
9D00260C  A0430004   SB V1, 4(V0)
108:                         }
109:                 
110:                         if (rx_len == (rx_array_inx - 1))
9D002664  8FC20030   LW V0, 48(S8)
9D002668  90420005   LBU V0, 5(V0)
9D00266C  00401821   ADDU V1, V0, ZERO
9D002670  8FC20030   LW V0, 48(S8)
9D002674  90420004   LBU V0, 4(V0)
9D002678  2442FFFF   ADDIU V0, V0, -1
9D00267C  1462004A   BNE V1, V0, 0x9D0027A8
9D002680  00000000   NOP
111:                         {
112:                             //seem to have got whole message
113:                             //last unsigned char is CS
114:                             calc_CS = CRC8(rx_buffer, rx_len);
9D002684  8FC20030   LW V0, 48(S8)
9D002688  8C430000   LW V1, 0(V0)
9D00268C  8FC20030   LW V0, 48(S8)
9D002690  90420005   LBU V0, 5(V0)
9D002694  8FC40030   LW A0, 48(S8)
9D002698  00602821   ADDU A1, V1, ZERO
9D00269C  00403021   ADDU A2, V0, ZERO
9D0026A0  0F40089E   JAL 0x9D002278
9D0026A4  00000000   NOP
9D0026A8  00401821   ADDU V1, V0, ZERO
9D0026AC  8FC20030   LW V0, 48(S8)
9D0026B0  A0430006   SB V1, 6(V0)
115:                 
116:                 
117:                 
118:                             if (calc_CS == rx_buffer[rx_array_inx - 1])
9D0026B4  8FC20030   LW V0, 48(S8)
9D0026B8  90430006   LBU V1, 6(V0)
9D0026BC  8FC20030   LW V0, 48(S8)
9D0026C0  8C440000   LW A0, 0(V0)
9D0026C4  8FC20030   LW V0, 48(S8)
9D0026C8  90420004   LBU V0, 4(V0)
9D0026CC  2442FFFF   ADDIU V0, V0, -1
9D0026D0  00821021   ADDU V0, A0, V0
9D0026D4  90420000   LBU V0, 0(V0)
9D0026D8  14620022   BNE V1, V0, 0x9D002764
9D0026DC  00000000   NOP
119:                             {//CS good
120:                                 queue_to_send[rx_address]->queue_put(rx_buffer, rx_len, rx_address, returnAddress);
9D0026E0  8FC20030   LW V0, 48(S8)
9D0026E4  9042001C   LBU V0, 28(V0)
9D0026E8  8FC30030   LW V1, 48(S8)
9D0026EC  2442000A   ADDIU V0, V0, 10
9D0026F0  00021080   SLL V0, V0, 2
9D0026F4  00621021   ADDU V0, V1, V0
9D0026F8  8C440000   LW A0, 0(V0)
9D0026FC  8FC20030   LW V0, 48(S8)
9D002700  8C450000   LW A1, 0(V0)
9D002704  8FC20030   LW V0, 48(S8)
9D002708  90420005   LBU V0, 5(V0)
9D00270C  00401821   ADDU V1, V0, ZERO
9D002710  8FC20030   LW V0, 48(S8)
9D002714  9042001C   LBU V0, 28(V0)
9D002718  8FC60030   LW A2, 48(S8)
9D00271C  90C60008   LBU A2, 8(A2)
9D002720  AFA60010   SW A2, 16(SP)
9D002724  00603021   ADDU A2, V1, ZERO
9D002728  00403821   ADDU A3, V0, ZERO
9D00272C  0F4003EE   JAL 0x9D000FB8
9D002730  00000000   NOP
121:                                 rx_len = 0;
9D002734  8FC20030   LW V0, 48(S8)
9D002738  A0400005   SB ZERO, 5(V0)
122:                                 rx_array_inx = 0;
9D00273C  8FC20030   LW V0, 48(S8)
9D002740  A0400004   SB ZERO, 4(V0)
123:                                 free(rx_buffer);
9D002744  8FC20030   LW V0, 48(S8)
9D002748  8C420000   LW V0, 0(V0)
9D00274C  00402021   ADDU A0, V0, ZERO
9D002750  0F400C86   JAL free
9D002754  00000000   NOP
124:                                 return true;
9D002758  24020001   ADDIU V0, ZERO, 1
9D00275C  0B4009EB   J 0x9D0027AC
9D002760  00000000   NOP
125:                             } else
126:                             {
127:                                 crcErrorCounter++; //increments the counter every time a crc fails
9D002764  8FC20030   LW V0, 48(S8)
9D002768  8C420014   LW V0, 20(V0)
9D00276C  24430001   ADDIU V1, V0, 1
9D002770  8FC20030   LW V0, 48(S8)
9D002774  AC430014   SW V1, 20(V0)
128:                                 //failed checksum, need to clear this out
129:                                 rx_len = 0;
9D002778  8FC20030   LW V0, 48(S8)
9D00277C  A0400005   SB ZERO, 5(V0)
130:                                 rx_array_inx = 0;
9D002780  8FC20030   LW V0, 48(S8)
9D002784  A0400004   SB ZERO, 4(V0)
131:                                 free(rx_buffer);
9D002788  8FC20030   LW V0, 48(S8)
9D00278C  8C420000   LW V0, 0(V0)
9D002790  00402021   ADDU A0, V0, ZERO
9D002794  0F400C86   JAL free
9D002798  00000000   NOP
132:                                 return false;
9D00279C  00001021   ADDU V0, ZERO, ZERO
9D0027A0  0B4009EB   J 0x9D0027AC
9D0027A4  00000000   NOP
133:                             }
134:                         }
135:                     }
136:                 
137:                 
138:                     return false;
9D0027A8  00001021   ADDU V0, ZERO, ZERO
139:                 }
9D0027AC  03C0E821   ADDU SP, S8, ZERO
9D0027B0  8FBF002C   LW RA, 44(SP)
9D0027B4  8FBE0028   LW S8, 40(SP)
9D0027B8  8FB10024   LW S1, 36(SP)
9D0027BC  8FB00020   LW S0, 32(SP)
9D0027C0  27BD0030   ADDIU SP, SP, 48
9D0027C4  03E00008   JR RA
9D0027C8  00000000   NOP
140:                 
141:                 
142:                 //pulls info out of the send buffer in a first in first out fashion
143:                 
144:                 unsigned char FastTransfer::ringBufS_get(struct ringBuff* _this)
145:                 {
9D0027CC  27BDFFE0   ADDIU SP, SP, -32
9D0027D0  AFBF001C   SW RA, 28(SP)
9D0027D4  AFBE0018   SW S8, 24(SP)
9D0027D8  03A0F021   ADDU S8, SP, ZERO
9D0027DC  AFC40020   SW A0, 32(S8)
9D0027E0  AFC50024   SW A1, 36(S8)
146:                     unsigned char c;
147:                     if (_this->count > 0)
9D0027E4  8FC20024   LW V0, 36(S8)
9D0027E8  8C420048   LW V0, 72(V0)
9D0027EC  18400018   BLEZ V0, 0x9D002850
9D0027F0  00000000   NOP
148:                     {
149:                         c = _this->buf[_this->tail];
9D0027F4  8FC20024   LW V0, 36(S8)
9D0027F8  8C420044   LW V0, 68(V0)
9D0027FC  8FC30024   LW V1, 36(S8)
9D002800  00621021   ADDU V0, V1, V0
9D002804  90420000   LBU V0, 0(V0)
9D002808  A3C20010   SB V0, 16(S8)
150:                         _this->tail = modulo_inc(_this->tail, BUFFER_SIZE);
9D00280C  8FC20024   LW V0, 36(S8)
9D002810  8C420044   LW V0, 68(V0)
9D002814  8FC40020   LW A0, 32(S8)
9D002818  00402821   ADDU A1, V0, ZERO
9D00281C  24060040   ADDIU A2, ZERO, 64
9D002820  0F400A28   JAL 0x9D0028A0
9D002824  00000000   NOP
9D002828  00401821   ADDU V1, V0, ZERO
9D00282C  8FC20024   LW V0, 36(S8)
9D002830  AC430044   SW V1, 68(V0)
151:                         --_this->count;
9D002834  8FC20024   LW V0, 36(S8)
9D002838  8C420048   LW V0, 72(V0)
9D00283C  2443FFFF   ADDIU V1, V0, -1
9D002840  8FC20024   LW V0, 36(S8)
9D002844  AC430048   SW V1, 72(V0)
9D002848  0B400A15   J 0x9D002854
9D00284C  00000000   NOP
152:                     } else
153:                     {
154:                         c = 0;
9D002850  A3C00010   SB ZERO, 16(S8)
155:                     }
156:                     return (c);
9D002854  93C20010   LBU V0, 16(S8)
157:                 }
9D002858  03C0E821   ADDU SP, S8, ZERO
9D00285C  8FBF001C   LW RA, 28(SP)
9D002860  8FBE0018   LW S8, 24(SP)
9D002864  27BD0020   ADDIU SP, SP, 32
9D002868  03E00008   JR RA
9D00286C  00000000   NOP
158:                 
159:                 int FastTransfer::ringBufS_size(struct ringBuff* _this)
160:                 {
9D002870  27BDFFF8   ADDIU SP, SP, -8
9D002874  AFBE0004   SW S8, 4(SP)
9D002878  03A0F021   ADDU S8, SP, ZERO
9D00287C  AFC40008   SW A0, 8(S8)
9D002880  AFC5000C   SW A1, 12(S8)
161:                     return (_this->count);
9D002884  8FC2000C   LW V0, 12(S8)
9D002888  8C420048   LW V0, 72(V0)
162:                 }
9D00288C  03C0E821   ADDU SP, S8, ZERO
9D002890  8FBE0004   LW S8, 4(SP)
9D002894  27BD0008   ADDIU SP, SP, 8
9D002898  03E00008   JR RA
9D00289C  00000000   NOP
163:                 
164:                 
165:                 // increments counters for the buffer functions
166:                 
167:                 unsigned int FastTransfer::modulo_inc(const unsigned int value, const unsigned int modulus)
168:                 {
9D0028A0  27BDFFF0   ADDIU SP, SP, -16
9D0028A4  AFBE000C   SW S8, 12(SP)
9D0028A8  03A0F021   ADDU S8, SP, ZERO
9D0028AC  AFC40010   SW A0, 16(S8)
9D0028B0  AFC50014   SW A1, 20(S8)
9D0028B4  AFC60018   SW A2, 24(S8)
169:                     unsigned int my_value = value + 1;
9D0028B8  8FC20014   LW V0, 20(S8)
9D0028BC  24420001   ADDIU V0, V0, 1
9D0028C0  AFC20000   SW V0, 0(S8)
170:                     if (my_value >= modulus)
9D0028C4  8FC30000   LW V1, 0(S8)
9D0028C8  8FC20018   LW V0, 24(S8)
9D0028CC  0062102B   SLTU V0, V1, V0
9D0028D0  14400002   BNE V0, ZERO, 0x9D0028DC
9D0028D4  00000000   NOP
171:                     {
172:                         my_value = 0;
9D0028D8  AFC00000   SW ZERO, 0(S8)
173:                     }
174:                     return (my_value);
9D0028DC  8FC20000   LW V0, 0(S8)
175:                 }
9D0028E0  03C0E821   ADDU SP, S8, ZERO
9D0028E4  8FBE000C   LW S8, 12(SP)
9D0028E8  27BD0010   ADDIU SP, SP, 16
9D0028EC  03E00008   JR RA
9D0028F0  00000000   NOP
176:                 
177:                 
178:                 //returns align error
179:                 
180:                 unsigned int FastTransfer::alignError(void)
181:                 {
9D0028F4  27BDFFF8   ADDIU SP, SP, -8
9D0028F8  AFBE0004   SW S8, 4(SP)
9D0028FC  03A0F021   ADDU S8, SP, ZERO
9D002900  AFC40008   SW A0, 8(S8)
182:                     return alignErrorCounter;
9D002904  8FC20008   LW V0, 8(S8)
9D002908  8C420010   LW V0, 16(V0)
183:                 }
9D00290C  03C0E821   ADDU SP, S8, ZERO
9D002910  8FBE0004   LW S8, 4(SP)
9D002914  27BD0008   ADDIU SP, SP, 8
9D002918  03E00008   JR RA
9D00291C  00000000   NOP
184:                 
185:                 
186:                 //returns CRC error
187:                 
188:                 unsigned int FastTransfer::CRCError(void)
189:                 {
9D002920  27BDFFF8   ADDIU SP, SP, -8
9D002924  AFBE0004   SW S8, 4(SP)
9D002928  03A0F021   ADDU S8, SP, ZERO
9D00292C  AFC40008   SW A0, 8(S8)
190:                     return crcErrorCounter;
9D002930  8FC20008   LW V0, 8(S8)
9D002934  8C420014   LW V0, 20(V0)
191:                 }
9D002938  03C0E821   ADDU SP, S8, ZERO
9D00293C  8FBE0004   LW S8, 4(SP)
9D002940  27BD0008   ADDIU SP, SP, 8
9D002944  03E00008   JR RA
9D002948  00000000   NOP
192:                 
193:                 
194:                 //returns address error
195:                 
196:                 unsigned int FastTransfer::addressError(void)
197:                 {
9D00294C  27BDFFF8   ADDIU SP, SP, -8
9D002950  AFBE0004   SW S8, 4(SP)
9D002954  03A0F021   ADDU S8, SP, ZERO
9D002958  AFC40008   SW A0, 8(S8)
198:                     return addressErrorCounter;
9D00295C  8FC20008   LW V0, 8(S8)
9D002960  8C420018   LW V0, 24(V0)
199:                 }
9D002964  03C0E821   ADDU SP, S8, ZERO
9D002968  8FBE0004   LW S8, 4(SP)
9D00296C  27BD0008   ADDIU SP, SP, 8
9D002970  03E00008   JR RA
9D002974  00000000   NOP
200:                 
---  c:/users/igor/mplabxprojects/routerpic.x/buffer.cpp  -----------------------------------------------
1:                   #include <xc.h>
2:                   #include <string.h>
3:                   #include "constants.h"
4:                   #include "main.h"
5:                   #include "buffer.h"
6:                   
7:                   struct ringBuff
8:                   {
9:                       unsigned char buf[RING_BUF_SIZE];
10:                      int head;
11:                      int tail;
12:                      int count;
13:                  };
14:                  
15:                  
16:                  // initiate ring buffer
17:                  
18:                  void ring_buff_init(struct ringBuff* _this)
19:                  {
9D002978  27BDFFE8   ADDIU SP, SP, -24
9D00297C  AFBF0014   SW RA, 20(SP)
9D002980  AFBE0010   SW S8, 16(SP)
9D002984  03A0F021   ADDU S8, SP, ZERO
9D002988  AFC40018   SW A0, 24(S8)
20:                      /*****
21:                        The following clears:
22:                          -> buf
23:                          -> head
24:                          -> tail
25:                          -> count
26:                        and sets head = tail
27:                       ***/
28:                      memset(_this, 0, sizeof (*_this));
9D00298C  8FC40018   LW A0, 24(S8)
9D002990  00002821   ADDU A1, ZERO, ZERO
9D002994  2406004C   ADDIU A2, ZERO, 76
9D002998  0F400DE1   JAL memset
9D00299C  00000000   NOP
29:                  }
9D0029A0  03C0E821   ADDU SP, S8, ZERO
9D0029A4  8FBF0014   LW RA, 20(SP)
9D0029A8  8FBE0010   LW S8, 16(SP)
9D0029AC  27BD0018   ADDIU SP, SP, 24
9D0029B0  03E00008   JR RA
9D0029B4  00000000   NOP
30:                  
31:                  
32:                  //place a charecter into the ring buffer
33:                  
34:                  void ring_buff_put(struct ringBuff* _this, const unsigned char c)
35:                  {
9D0029B8  27BDFFE8   ADDIU SP, SP, -24
9D0029BC  AFBF0014   SW RA, 20(SP)
9D0029C0  AFBE0010   SW S8, 16(SP)
9D0029C4  03A0F021   ADDU S8, SP, ZERO
9D0029C8  AFC40018   SW A0, 24(S8)
9D0029CC  00A01021   ADDU V0, A1, ZERO
9D0029D0  A3C2001C   SB V0, 28(S8)
36:                      if (_this->count < RING_BUF_SIZE)
9D0029D4  8FC20018   LW V0, 24(S8)
9D0029D8  8C420048   LW V0, 72(V0)
9D0029DC  28420040   SLTI V0, V0, 64
9D0029E0  10400017   BEQ V0, ZERO, 0x9D002A40
9D0029E4  00000000   NOP
37:                      {
38:                          _this->buf[_this->head] = c;
9D0029E8  8FC20018   LW V0, 24(S8)
9D0029EC  8C420040   LW V0, 64(V0)
9D0029F0  8FC30018   LW V1, 24(S8)
9D0029F4  00621021   ADDU V0, V1, V0
9D0029F8  93C3001C   LBU V1, 28(S8)
9D0029FC  A0430000   SB V1, 0(V0)
39:                          _this->head = modulo_inc(_this->head, RING_BUF_SIZE);
9D002A00  8FC20018   LW V0, 24(S8)
9D002A04  8C420040   LW V0, 64(V0)
9D002A08  00402021   ADDU A0, V0, ZERO
9D002A0C  24050040   ADDIU A1, ZERO, 64
9D002A10  0F400B09   JAL 0x9D002C24
9D002A14  00000000   NOP
9D002A18  00401821   ADDU V1, V0, ZERO
9D002A1C  8FC20018   LW V0, 24(S8)
9D002A20  AC430040   SW V1, 64(V0)
40:                          ++_this->count;
9D002A24  8FC20018   LW V0, 24(S8)
9D002A28  8C420048   LW V0, 72(V0)
9D002A2C  24430001   ADDIU V1, V0, 1
9D002A30  8FC20018   LW V0, 24(S8)
9D002A34  AC430048   SW V1, 72(V0)
9D002A38  0B400AA8   J 0x9D002AA0
9D002A3C  00000000   NOP
41:                      } else
42:                      {
43:                          _this->buf[_this->head] = c;
9D002A40  8FC20018   LW V0, 24(S8)
9D002A44  8C420040   LW V0, 64(V0)
9D002A48  8FC30018   LW V1, 24(S8)
9D002A4C  00621021   ADDU V0, V1, V0
9D002A50  93C3001C   LBU V1, 28(S8)
9D002A54  A0430000   SB V1, 0(V0)
44:                          _this->head = modulo_inc(_this->head, RING_BUF_SIZE);
9D002A58  8FC20018   LW V0, 24(S8)
9D002A5C  8C420040   LW V0, 64(V0)
9D002A60  00402021   ADDU A0, V0, ZERO
9D002A64  24050040   ADDIU A1, ZERO, 64
9D002A68  0F400B09   JAL 0x9D002C24
9D002A6C  00000000   NOP
9D002A70  00401821   ADDU V1, V0, ZERO
9D002A74  8FC20018   LW V0, 24(S8)
9D002A78  AC430040   SW V1, 64(V0)
45:                          _this->tail = modulo_inc(_this->tail, RING_BUF_SIZE);
9D002A7C  8FC20018   LW V0, 24(S8)
9D002A80  8C420044   LW V0, 68(V0)
9D002A84  00402021   ADDU A0, V0, ZERO
9D002A88  24050040   ADDIU A1, ZERO, 64
9D002A8C  0F400B09   JAL 0x9D002C24
9D002A90  00000000   NOP
9D002A94  00401821   ADDU V1, V0, ZERO
9D002A98  8FC20018   LW V0, 24(S8)
9D002A9C  AC430044   SW V1, 68(V0)
46:                  
47:                      }
48:                  }
9D002AA0  03C0E821   ADDU SP, S8, ZERO
9D002AA4  8FBF0014   LW RA, 20(SP)
9D002AA8  8FBE0010   LW S8, 16(SP)
9D002AAC  27BD0018   ADDIU SP, SP, 24
9D002AB0  03E00008   JR RA
9D002AB4  00000000   NOP
49:                  
50:                  
51:                  //get a character from the ring buffer
52:                  
53:                  unsigned char ring_buff_get(struct ringBuff* _this)
54:                  {
9D002AB8  27BDFFE0   ADDIU SP, SP, -32
9D002ABC  AFBF001C   SW RA, 28(SP)
9D002AC0  AFBE0018   SW S8, 24(SP)
9D002AC4  03A0F021   ADDU S8, SP, ZERO
9D002AC8  AFC40020   SW A0, 32(S8)
55:                      unsigned char c;
56:                      if (_this->count > 0)
9D002ACC  8FC20020   LW V0, 32(S8)
9D002AD0  8C420048   LW V0, 72(V0)
9D002AD4  18400017   BLEZ V0, 0x9D002B34
9D002AD8  00000000   NOP
57:                      {
58:                          c = _this->buf[_this->tail];
9D002ADC  8FC20020   LW V0, 32(S8)
9D002AE0  8C420044   LW V0, 68(V0)
9D002AE4  8FC30020   LW V1, 32(S8)
9D002AE8  00621021   ADDU V0, V1, V0
9D002AEC  90420000   LBU V0, 0(V0)
9D002AF0  A3C20010   SB V0, 16(S8)
59:                          _this->tail = modulo_inc(_this->tail, RING_BUF_SIZE);
9D002AF4  8FC20020   LW V0, 32(S8)
9D002AF8  8C420044   LW V0, 68(V0)
9D002AFC  00402021   ADDU A0, V0, ZERO
9D002B00  24050040   ADDIU A1, ZERO, 64
9D002B04  0F400B09   JAL 0x9D002C24
9D002B08  00000000   NOP
9D002B0C  00401821   ADDU V1, V0, ZERO
9D002B10  8FC20020   LW V0, 32(S8)
9D002B14  AC430044   SW V1, 68(V0)
60:                          --_this->count;
9D002B18  8FC20020   LW V0, 32(S8)
9D002B1C  8C420048   LW V0, 72(V0)
9D002B20  2443FFFF   ADDIU V1, V0, -1
9D002B24  8FC20020   LW V0, 32(S8)
9D002B28  AC430048   SW V1, 72(V0)
9D002B2C  0B400ACE   J 0x9D002B38
9D002B30  00000000   NOP
61:                      } else
62:                      {
63:                          c = 0;
9D002B34  A3C00010   SB ZERO, 16(S8)
64:                      }
65:                      return (c);
9D002B38  93C20010   LBU V0, 16(S8)
66:                  }
9D002B3C  03C0E821   ADDU SP, S8, ZERO
9D002B40  8FBF001C   LW RA, 28(SP)
9D002B44  8FBE0018   LW S8, 24(SP)
9D002B48  27BD0020   ADDIU SP, SP, 32
9D002B4C  03E00008   JR RA
9D002B50  00000000   NOP
67:                  
68:                  
69:                  //returns the tail caracter without removing it from the buffer
70:                  
71:                  unsigned char ring_buff_peek(struct ringBuff* _this)
72:                  {
9D002B54  27BDFFF8   ADDIU SP, SP, -8
9D002B58  AFBE0004   SW S8, 4(SP)
9D002B5C  03A0F021   ADDU S8, SP, ZERO
9D002B60  AFC40008   SW A0, 8(S8)
73:                      return (_this->buf[_this->tail]);
9D002B64  8FC20008   LW V0, 8(S8)
9D002B68  8C420044   LW V0, 68(V0)
9D002B6C  8FC30008   LW V1, 8(S8)
9D002B70  00621021   ADDU V0, V1, V0
9D002B74  90420000   LBU V0, 0(V0)
74:                  }
9D002B78  03C0E821   ADDU SP, S8, ZERO
9D002B7C  8FBE0004   LW S8, 4(SP)
9D002B80  27BD0008   ADDIU SP, SP, 8
9D002B84  03E00008   JR RA
9D002B88  00000000   NOP
75:                  
76:                  
77:                  // flushes the ring buffer
78:                  
79:                  void ring_buff_flush(struct ringBuff* _this, const int clearBuffer)
80:                  {
9D002B8C  27BDFFE8   ADDIU SP, SP, -24
9D002B90  AFBF0014   SW RA, 20(SP)
9D002B94  AFBE0010   SW S8, 16(SP)
9D002B98  03A0F021   ADDU S8, SP, ZERO
9D002B9C  AFC40018   SW A0, 24(S8)
9D002BA0  AFC5001C   SW A1, 28(S8)
81:                      _this->count = 0;
9D002BA4  8FC20018   LW V0, 24(S8)
9D002BA8  AC400048   SW ZERO, 72(V0)
82:                      _this->head = 0;
9D002BAC  8FC20018   LW V0, 24(S8)
9D002BB0  AC400040   SW ZERO, 64(V0)
83:                      _this->tail = 0;
9D002BB4  8FC20018   LW V0, 24(S8)
9D002BB8  AC400044   SW ZERO, 68(V0)
84:                      if (clearBuffer)
9D002BBC  8FC2001C   LW V0, 28(S8)
9D002BC0  10400007   BEQ V0, ZERO, 0x9D002BE0
9D002BC4  00000000   NOP
85:                      {
86:                          memset(_this->buf, 0, sizeof (_this->buf));
9D002BC8  8FC20018   LW V0, 24(S8)
9D002BCC  00402021   ADDU A0, V0, ZERO
9D002BD0  00002821   ADDU A1, ZERO, ZERO
9D002BD4  24060040   ADDIU A2, ZERO, 64
9D002BD8  0F400DE1   JAL memset
9D002BDC  00000000   NOP
87:                      }
88:                  }
9D002BE0  03C0E821   ADDU SP, S8, ZERO
9D002BE4  8FBF0014   LW RA, 20(SP)
9D002BE8  8FBE0010   LW S8, 16(SP)
9D002BEC  27BD0018   ADDIU SP, SP, 24
9D002BF0  03E00008   JR RA
9D002BF4  00000000   NOP
89:                  
90:                  
91:                  // returns the size of the data in the buffer
92:                  
93:                  int ring_buff_size(struct ringBuff* _this)
94:                  {
9D002BF8  27BDFFF8   ADDIU SP, SP, -8
9D002BFC  AFBE0004   SW S8, 4(SP)
9D002C00  03A0F021   ADDU S8, SP, ZERO
9D002C04  AFC40008   SW A0, 8(S8)
95:                      return (_this->count);
9D002C08  8FC20008   LW V0, 8(S8)
9D002C0C  8C420048   LW V0, 72(V0)
96:                  }
9D002C10  03C0E821   ADDU SP, S8, ZERO
9D002C14  8FBE0004   LW S8, 4(SP)
9D002C18  27BD0008   ADDIU SP, SP, 8
9D002C1C  03E00008   JR RA
9D002C20  00000000   NOP
97:                  
98:                  
99:                  // used to service the subrutiens of the ring buffer
100:                 
101:                 unsigned int modulo_inc(const unsigned int value, const unsigned int modulus)
102:                 {
9D002C24  27BDFFF0   ADDIU SP, SP, -16
9D002C28  AFBE000C   SW S8, 12(SP)
9D002C2C  03A0F021   ADDU S8, SP, ZERO
9D002C30  AFC40010   SW A0, 16(S8)
9D002C34  AFC50014   SW A1, 20(S8)
103:                     unsigned int my_value = value + 1;
9D002C38  8FC20010   LW V0, 16(S8)
9D002C3C  24420001   ADDIU V0, V0, 1
9D002C40  AFC20000   SW V0, 0(S8)
104:                     if (my_value >= modulus)
9D002C44  8FC30000   LW V1, 0(S8)
9D002C48  8FC20014   LW V0, 20(S8)
9D002C4C  0062102B   SLTU V0, V1, V0
9D002C50  14400002   BNE V0, ZERO, 0x9D002C5C
9D002C54  00000000   NOP
105:                     {
106:                         my_value = 0;
9D002C58  AFC00000   SW ZERO, 0(S8)
107:                     }
108:                     return (my_value);
9D002C5C  8FC20000   LW V0, 0(S8)
109:                 }
9D002C60  03C0E821   ADDU SP, S8, ZERO
9D002C64  8FBE000C   LW S8, 12(SP)
9D002C68  27BD0010   ADDIU SP, SP, 16
9D002C6C  03E00008   JR RA
9D002C70  00000000   NOP
110:                 
---  c:/program files/microchip/xc32/v1.32/pic32mx/include/peripheral/system.h  -------------------------
1:                   /********************************************************************
2:                   
3:                   	System Library Interface Definition
4:                   	
5:                   	Summary:
6:                   		This file contains the interface definition for the System
7:                   		peripheral library.
8:                   		
9:                   	Description:
10:                  		This library provides functions for configuring the peripheral
11:                  		clock, cache settings, and wait states.  For details on the
12:                  		register and bit settings used by these functions, refer to the
13:                  		PIC32 Family Reference Manual.
14:                  
15:                  
16:                   ********************************************************************/
17:                  //DOM-IGNORE-BEGIN
18:                  /********************************************************************
19:                   * FileName:		System.h
20:                   * Dependencies:
21:                   * Processor:		PIC32
22:                   * Hardware:		N/A
23:                   * Assembler:		N/A
24:                   * Linker:		    N/A
25:                   * Company:		    Microchip Technology Inc.
26:                   *
27:                   * Software License Agreement:
28:                   * The software supplied herewith by Microchip Technology Incorporated
29:                   * (the ?Company?) for its PICmicro Microcontroller is intended and
30:                   * supplied to you, the Company?s customer, for use solely and
31:                   * exclusively on Microchip PICmicro Microcontroller products. The
32:                   * software is owned by the Company and/or its supplier, and is
33:                   * protected under applicable copyright laws. All rights are reserved.
34:                   * Any use in violation of the foregoing restrictions may subject the
35:                   * user to criminal sanctions under applicable laws, as well as to
36:                   * civil liability for the breach of the terms and conditions of this
37:                   * license.
38:                   *
39:                   * THIS SOFTWARE IS PROVIDED IN AN ?AS IS? CONDITION. NO WARRANTIES,
40:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
41:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
42:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
43:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
44:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
45:                   *
46:                   * $Id: CoreTimer.h,v 1.2 2006/11/03 15:07:21 C12923 Exp $
47:                   * $Name:  $
48:                   ********************************************************************/
49:                  //DOM-IGNORE-END
50:                   
51:                   
52:                  #ifndef _SYSTEM_HEADER_FILE
53:                  #define _SYSTEM_HEADER_FILE
54:                  
55:                  #include <xc.h>
56:                  #include <peripheral/int.h>
57:                  #include <peripheral/pcache.h>
58:                  #include <peripheral/osc.h>
59:                  #include <peripheral/dma.h>
60:                  #include <peripheral/bmx.h>
61:                  #include <peripheral/lock.h>
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  
67:                  /*
68:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file, 
69:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.  
70:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
71:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
72:                  */
73:                  #ifndef _SUPPRESS_PLIB_WARNING
74:                  #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
75:                  #endif
76:                  
77:                  
78:                  
79:                  #define FLASH_SPEED_HZ          30000000 //Max Flash speed
80:                  #define PB_BUS_MAX_FREQ_HZ      80000000 //Max Peripheral bus speed
81:                  
82:                  /*********************************************************************
83:                   * SYSTEMConfig Flags
84:                   *********************************************************************/
85:                  #define SYS_CFG_WAIT_STATES     0x00000001 //SYSTEMConfig wait states
86:                  #define SYS_CFG_PB_BUS          0x00000002 //SYSTEMConfig pb bus
87:                  #define SYS_CFG_PCACHE          0x00000004 //SYSTEMConfig cache
88:                  #define SYS_CFG_ALL             0xFFFFFFFF //SYSTEMConfig All
89:                  
90:                  /*********************************************************************
91:                   Function:       
92:                  	unsigned int SYSTEMConfigPB(unsigned int sys_clock)
93:                   
94:                   Description:
95:                  	The function sets the PB divider to the optimum value.
96:                   
97:                   PreCondition:    
98:                  	None
99:                   
100:                  Parameters:           
101:                 	sys_clock - system clock in Hz
102:                  
103:                  Returns:          
104:                 	the PB clock frequency in Hz
105:                  
106:                  Side Effects:
107:                 	The PB clock may be changed
108:                 	
109:                  Overview:	    
110:                 	The function sets the PB divider to the optimum value.
111:                  
112:                  Remarks:            
113:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
114:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
115:                  
116:                  Example:
117:                 	<code>
118:                 	SYSTEMConfigPB(72000000);
119:                 	</code>
120:                  ********************************************************************/
121:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPB(unsigned int sys_clock)
122:                 {
123:                     unsigned int pb_div;
124:                     unsigned int pb_clock;
125:                 
126:                     pb_clock = sys_clock;
9D000130  8FC20028   LW V0, 40(S8)
9D000134  AFC2002C   SW V0, 44(S8)
127:                 
128:                     if(sys_clock > PB_BUS_MAX_FREQ_HZ)
9D000138  8FC30028   LW V1, 40(S8)
9D00013C  3C0204C4   LUI V0, 1220
9D000140  3442B401   ORI V0, V0, -19455
9D000144  0062102B   SLTU V0, V1, V0
9D000148  14400008   BNE V0, ZERO, 0x9D00016C
9D00014C  00000000   NOP
129:                     {
130:                         pb_div=OSC_PB_DIV_2;
9D000150  3C020008   LUI V0, 8
9D000154  AFC20030   SW V0, 48(S8)
131:                         pb_clock >>= 1;
9D000158  8FC2002C   LW V0, 44(S8)
9D00015C  00021042   SRL V0, V0, 1
9D000160  AFC2002C   SW V0, 44(S8)
9D000164  0B40005C   J 0x9D000170
9D000168  00000000   NOP
132:                     }
133:                     else
134:                     {
135:                         pb_div=OSC_PB_DIV_1;
9D00016C  AFC00030   SW ZERO, 48(S8)
9D000170  8FC20030   LW V0, 48(S8)
9D000174  AFC20034   SW V0, 52(S8)
136:                     }
137:                 
138:                     OSCSetPBDIV(pb_div);
139:                 
140:                     return pb_clock;
141:                 }
142:                 
143:                 
144:                 /*********************************************************************
145:                   Function:        
146:                 	void SYSTEMConfigWaitStates(unsigned int sys_clock)
147:                  
148:                   Description:
149:                 	The function sets the Flash Wait states to the optimum value.
150:                  
151:                   PreCondition:    
152:                 	None
153:                  
154:                   Parameters:           
155:                 	sys_clock - system clock in Hz
156:                  
157:                   Returns:          
158:                 	None
159:                  
160:                   Side Effects:    
161:                 	The Wait States may be changed  
162:                  
163:                   Remarks:         
164:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
165:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
166:                  
167:                   Example:
168:                 	<code>
169:                 	SYSTEMConfigWaitStates(72000000);
170:                 	</code>
171:                  ********************************************************************/
172:                 extern inline void __attribute__((always_inline)) SYSTEMConfigWaitStates(unsigned int sys_clock)
173:                 {
174:                 #ifdef _PCACHE
175:                     unsigned int wait_states;
176:                     unsigned int int_status;
177:                 #endif
178:                 
179:                 #ifdef _PCACHE
180:                     wait_states = 0;
9D0000A8  AFC00020   SW ZERO, 32(S8)
9D0000AC  0B400035   J 0x9D0000D4
9D0000B0  00000000   NOP
181:                 
182:                     while(sys_clock > FLASH_SPEED_HZ)
9D0000D4  8FC3001C   LW V1, 28(S8)
9D0000D8  3C0201C9   LUI V0, 457
9D0000DC  3442C381   ORI V0, V0, -15487
9D0000E0  0062102B   SLTU V0, V1, V0
9D0000E4  38420001   XORI V0, V0, 1
9D0000E8  304200FF   ANDI V0, V0, 255
9D0000EC  1440FFF1   BNE V0, ZERO, 0x9D0000B4
9D0000F0  00000000   NOP
183:                     {
184:                         wait_states++;
9D0000B4  8FC20020   LW V0, 32(S8)
9D0000B8  24420001   ADDIU V0, V0, 1
9D0000BC  AFC20020   SW V0, 32(S8)
185:                         sys_clock -= FLASH_SPEED_HZ;
9D0000C0  8FC3001C   LW V1, 28(S8)
9D0000C4  3C02FE36   LUI V0, -458
9D0000C8  34423C80   ORI V0, V0, 15488
9D0000CC  00621021   ADDU V0, V1, V0
9D0000D0  AFC2001C   SW V0, 28(S8)
186:                     }
187:                 
188:                     int_status=INTDisableInterrupts();
9D0000F4  0F400E14   JAL INTDisableInterrupts
9D0000F8  00000000   NOP
9D0000FC  AFC20024   SW V0, 36(S8)
189:                     mCheConfigure(wait_states);
9D000100  3C02BF88   LUI V0, -16504
9D000104  8FC30020   LW V1, 32(S8)
9D000108  AC434000   SW V1, 16384(V0)
190:                     INTRestoreInterrupts(int_status);
9D00010C  8FC40024   LW A0, 36(S8)
9D000110  0F400DF7   JAL INTRestoreInterrupts
9D000114  00000000   NOP
191:                 
192:                 #endif
193:                 }
194:                 
195:                 /*********************************************************************
196:                   Function:        
197:                 		unsigned int SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
198:                   
199:                   Description:
200:                 	The function sets the PB divider and the Flash Wait states to the optimum value.
201:                  
202:                   PreCondition:    
203:                 	None
204:                  
205:                   Parameters:           
206:                 	sys_clock - system clock in Hz
207:                  
208:                   Returns:          
209:                 	the PB clock frequency in Hz
210:                  
211:                   Side Effects:    
212:                 	The PB clock and wait states may be changed
213:                 
214:                   Remarks:            
215:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
216:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
217:                  
218:                   Example:
219:                 	<code>
220:                 	SYSTEMConfigWaitStatesAndPB(72000000);
221:                 	</code>
222:                  ********************************************************************/
223:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
224:                 {
225:                 #ifdef _PCACHE
226:                     unsigned int wait_states;
227:                 #endif
228:                     unsigned int pb_clock;
229:                     unsigned int int_status;
230:                 
231:                     pb_clock = SYSTEMConfigPB(sys_clock);
232:                 
233:                 
234:                     // set the flash wait states based on 1 wait state
235:                     // for every 20 MHz
236:                 #ifdef _PCACHE
237:                     wait_states = 0;
238:                 
239:                     while(sys_clock > FLASH_SPEED_HZ)
240:                     {
241:                         wait_states++;
242:                         sys_clock -= FLASH_SPEED_HZ;
243:                     }
244:                 
245:                     int_status=INTDisableInterrupts();
246:                     mCheConfigure(wait_states);
247:                     INTRestoreInterrupts(int_status);
248:                 
249:                 #endif
250:                 
251:                     return pb_clock;
252:                 }
253:                 /*********************************************************************
254:                   Function:       
255:                 	unsigned int SYSTEMConfigPerformance(unsigned int sys_clock)
256:                  
257:                   Description:
258:                 	The function sets the PB divider, the Flash Wait states and the DRM wait states to the optimum value.
259:                     It also enables the cacheability for the K0 segment.
260:                 	
261:                   PreCondition:    
262:                 	None
263:                  
264:                   Parameters:           
265:                 	sys_clock - system clock in Hz
266:                  
267:                   Output:          
268:                 	the PB clock frequency in Hz
269:                  
270:                   Side Effects:    
271:                 	Sets the PB and Flash Wait states
272:                  	
273:                   Remarks:            
274:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
275:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
276:                  
277:                   Example:
278:                 	<code>
279:                 	SYSTEMConfigPerformance(72000000);
280:                 	</code>
281:                  ********************************************************************/
282:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPerformance(unsigned int sys_clock)
283:                 {
284:                     // set up the wait states
285:                     unsigned int pb_clk;
286:                 #ifdef _PCACHE
287:                     unsigned int cache_status;
288:                 #endif
289:                     unsigned int int_status;
290:                 
291:                     pb_clk = SYSTEMConfigWaitStatesAndPB(sys_clock);
292:                 
293:                     int_status=INTDisableInterrupts();
294:                 
295:                     mBMXDisableDRMWaitState();
296:                 
297:                 #ifdef _PCACHE
298:                     cache_status = mCheGetCon();
299:                     cache_status |= CHE_CONF_PF_ALL;
300:                     mCheConfigure(cache_status);
301:                     CheKseg0CacheOn();
302:                 #endif
303:                 
304:                     INTRestoreInterrupts(int_status);
305:                 
306:                     return pb_clk;
307:                 
308:                 }
309:                 /*********************************************************************
310:                   Function:       
311:                 	unsigned int SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
312:                  
313:                   Description:
314:                 	The function sets the PB divider, the Flash Wait states or the DRM wait states to the optimum value, 
315:                 	based on the flags selected and on the frequency of the system clock.
316:                     It also enables the cacheability for the K0 segment.
317:                 				   
318:                   PreCondition:    
319:                 	None
320:                  
321:                   Parameters:           
322:                 	sys_clock - system clock frequency in Hz
323:                     flags -
324:                 		*    SYS_CFG_WAIT_STATES  - configure the flash wait states from the system clock
325:                         *    SYS_CFG_PB_BUS       - configure the PB bus from the system clock
326:                         *    SYS_CFG_PCACHE      - configure the pCache (if used)
327:                         *    SYS_CFG_ALL          - configure all based on system clock
328:                  
329:                   Returns:          
330:                 	the PB clock frequency in Hz
331:                  
332:                   Side Effects:    
333:                 	Could change the wait state, pb clock and turn on the pre-fetch buffer and cache. Sets the RAM
334:                     wait state to 0.
335:                   
336:                  
337:                   Remarks:
338:                 	The interrupts are disabled shortly, the DMA is suspended and the system is unlocked while performing the operation.
339:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
340:                  
341:                   Example:
342:                 	<code>
343:                 	SYSTEMConfig(72000000, SYS_CFG_ALL);
344:                 	</code>
345:                  ********************************************************************/
346:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
347:                 {
348:                     unsigned int pb_clk;
349:                     unsigned int int_status;
350:                 #ifdef _PCACHE
351:                     unsigned int cache_status;
352:                 #endif
353:                 
354:                     int_status=INTDisableInterrupts();
9D000074  0F400E14   JAL INTDisableInterrupts
9D000078  00000000   NOP
9D00007C  AFC20018   SW V0, 24(S8)
355:                 
356:                     mBMXDisableDRMWaitState();
9D000080  3C02BF88   LUI V0, -16504
9D000084  24030040   ADDIU V1, ZERO, 64
9D000088  AC432004   SW V1, 8196(V0)
357:                 
358:                     if(flags & SYS_CFG_WAIT_STATES)
9D00008C  8FC20014   LW V0, 20(S8)
9D000090  30420001   ANDI V0, V0, 1
9D000094  304200FF   ANDI V0, V0, 255
9D000098  1040001F   BEQ V0, ZERO, 0x9D000118
9D00009C  00000000   NOP
9D0000A0  8FC20010   LW V0, 16(S8)
9D0000A4  AFC2001C   SW V0, 28(S8)
359:                     {
360:                         SYSTEMConfigWaitStates(sys_clock);
361:                     }
362:                 
363:                     if(flags & SYS_CFG_PB_BUS)
9D000118  8FC20014   LW V0, 20(S8)
9D00011C  30420002   ANDI V0, V0, 2
9D000120  1040006D   BEQ V0, ZERO, 0x9D0002D8
9D000124  00000000   NOP
9D000128  8FC20010   LW V0, 16(S8)
9D00012C  AFC20028   SW V0, 40(S8)
364:                     {
365:                         SYSTEMConfigPB(sys_clock);
366:                     }
367:                 
368:                 
369:                 #ifdef _PCACHE
370:                     if(flags & SYS_CFG_PCACHE)
9D0002D8  8FC20014   LW V0, 20(S8)
9D0002DC  30420004   ANDI V0, V0, 4
9D0002E0  1040000C   BEQ V0, ZERO, 0x9D000314
9D0002E4  00000000   NOP
371:                     {
372:                         cache_status = mCheGetCon();
9D0002E8  3C02BF88   LUI V0, -16504
9D0002EC  8C424000   LW V0, 16384(V0)
9D0002F0  AFC2004C   SW V0, 76(S8)
373:                         cache_status |= CHE_CONF_PF_ALL;
9D0002F4  8FC2004C   LW V0, 76(S8)
9D0002F8  34420030   ORI V0, V0, 48
9D0002FC  AFC2004C   SW V0, 76(S8)
374:                         mCheConfigure(cache_status);
9D000300  3C02BF88   LUI V0, -16504
9D000304  8FC3004C   LW V1, 76(S8)
9D000308  AC434000   SW V1, 16384(V0)
375:                         CheKseg0CacheOn();
9D00030C  0F400E04   JAL CheKseg0CacheOn
9D000310  00000000   NOP
376:                     }
377:                 #endif
378:                 
379:                     pb_clk = sys_clock;
9D000314  8FC20010   LW V0, 16(S8)
9D000318  AFC20050   SW V0, 80(S8)
380:                     pb_clk >>= OSCCONbits.PBDIV;
9D00031C  3C02BF81   LUI V0, -16511
9D000320  8C42F000   LW V0, -4096(V0)
9D000324  7C420CC0   EXT V0, V0, 19, 2
9D000328  304200FF   ANDI V0, V0, 255
9D00032C  8FC30050   LW V1, 80(S8)
9D000330  00431006   SRLV V0, V1, V0
9D000334  AFC20050   SW V0, 80(S8)
381:                 
382:                     INTRestoreInterrupts(int_status);
9D000338  8FC40018   LW A0, 24(S8)
9D00033C  0F400DF7   JAL INTRestoreInterrupts
9D000340  00000000   NOP
383:                 
384:                     return pb_clk;
385:                 
386:                 }
387:                 #ifdef __cplusplus
388:                   }
389:                 #endif
390:                 #endif
391:                 
---  c:/program files/microchip/xc32/v1.32/pic32mx/include/peripheral/osc.h  ----------------------------
1:                   /*********************************************************************
2:                    *
3:                    *                  OSC API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        OSC.h
7:                    * Dependencies:
8:                    * Processor:       PIC32
9:                    *
10:                   *
11:                   * Compiler:        MPLAB XC32
12:                   *                  MPLAB IDE
13:                   * Company:         Microchip Technology Inc.
14:                   *
15:                   * Software License Agreement
16:                   *
17:                   * The software supplied herewith by Microchip Technology Incorporated
18:                   * (the ?Company?) for its PIC Microcontroller is intended
19:                   * and supplied to you, the Company?s customer, for use solely and
20:                   * exclusively on Microchip PIC Microcontroller products.
21:                   * The software is owned by the Company and/or its supplier, and is
22:                   * protected under applicable copyright laws. All rights are reserved.
23:                   * Any use in violation of the foregoing restrictions may subject the
24:                   * user to criminal sanctions under applicable laws, as well as to
25:                   * civil liability for the breach of the terms and conditions of this
26:                   * license.
27:                   *
28:                   * THIS SOFTWARE IS PROVIDED IN AN ?AS IS? CONDITION. NO WARRANTIES,
29:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
30:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
31:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
32:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
33:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
34:                   *
35:                   *
36:                   * $Id: OSC.h,v 1.6 2006/10/13 21:24:31 C12532 Exp $
37:                   * $Name:  $
38:                   ********************************************************************/
39:                  
40:                  #ifndef OSC_H_
41:                  #define OSC_H_
42:                  
43:                  #include <xc.h>
44:                  #include <peripheral/lock.h>
45:                  
46:                  /*
47:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file, 
48:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.  
49:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
50:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
51:                  */
52:                  #ifndef _SUPPRESS_PLIB_WARNING
53:                  #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
54:                  #endif
55:                  
56:                  
57:                  #define _OSC_
58:                  
59:                  /*********************************************************************
60:                   * Function:        OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div)
61:                   *
62:                   * Description:	    Sets Osc options and clock source
63:                   *
64:                   * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
65:                   *
66:                   * Inputs:	    	Clock source, PLL multiplier, PLL postscaler, FRC divisor - see below
67:                   *
68:                   * Output:          None
69:                   *
70:                   * Example:	    	OSCConfig( OSC_POSC, OSC_PLL_MULT_24, OSC_PLL_POST_256, OSC_FRC_POST_64 )
71:                   *
72:                   * Note:	    	Forces cpu clock source to FRC(no divisor, no PLL), configures new clock
73:                   * 		     		source and then switches to the new clock source
74:                   *
75:                   *		    		Unused parameters are set to zero/default values.
76:                   ********************************************************************/
77:                  void OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div);
78:                  
79:                  	/******************************************************************************
80:                  	 * Available options for source parameter
81:                  	 *****************************************************************************/
82:                  		// CPU Oscillator modes - values are mutually exclusive
83:                  		#define OSC_FRC_DIV 	(7 << _OSCCON_NOSC_POSITION)
84:                  		#define OSC_FRC_DIV16 	(6 << _OSCCON_NOSC_POSITION)
85:                  		#define OSC_LPRC        (5 << _OSCCON_NOSC_POSITION)
86:                  		#define OSC_SOSC        (4 << _OSCCON_NOSC_POSITION)
87:                  		#define OSC_POSC_PLL 	(3 << _OSCCON_NOSC_POSITION)
88:                  		#define OSC_POSC        (2 << _OSCCON_NOSC_POSITION)
89:                  		#define OSC_FRC_PLL 	(1 << _OSCCON_NOSC_POSITION)
90:                  		#define OSC_FRC         (0 << _OSCCON_NOSC_POSITION)
91:                  
92:                  	/******************************************************************************
93:                  	 * Available options for mult parameter
94:                  	 *****************************************************************************/
95:                  		// CPU PLL multiplier values - values are mutually exclusive
96:                  		#define OSC_PLL_MULT_24 (7 << _OSCCON_PLLMULT_POSITION)
97:                  		#define OSC_PLL_MULT_21 (6 << _OSCCON_PLLMULT_POSITION)
98:                  		#define OSC_PLL_MULT_20 (5 << _OSCCON_PLLMULT_POSITION)
99:                  		#define OSC_PLL_MULT_19 (4 << _OSCCON_PLLMULT_POSITION)
100:                 		#define OSC_PLL_MULT_18 (3 << _OSCCON_PLLMULT_POSITION)
101:                 		#define OSC_PLL_MULT_17 (2 << _OSCCON_PLLMULT_POSITION)
102:                 		#define OSC_PLL_MULT_16 (1 << _OSCCON_PLLMULT_POSITION)
103:                 		#define OSC_PLL_MULT_15 (0 << _OSCCON_PLLMULT_POSITION)
104:                 
105:                 	/******************************************************************************
106:                 	 * Available options for post parameter
107:                 	 *****************************************************************************/
108:                 		// CPU PLL output divisor values - values are mutuallye exclusive
109:                 		#define OSC_PLL_POST_256 (7 << _OSCCON_PLLODIV_POSITION)
110:                 		#define OSC_PLL_POST_64  (6 << _OSCCON_PLLODIV_POSITION)
111:                 		#define OSC_PLL_POST_32  (5 << _OSCCON_PLLODIV_POSITION)
112:                 		#define OSC_PLL_POST_16  (4 << _OSCCON_PLLODIV_POSITION)
113:                 		#define OSC_PLL_POST_8   (3 << _OSCCON_PLLODIV_POSITION)
114:                 		#define OSC_PLL_POST_4   (2 << _OSCCON_PLLODIV_POSITION)
115:                 		#define OSC_PLL_POST_2   (1 << _OSCCON_PLLODIV_POSITION)
116:                 		#define OSC_PLL_POST_1   (0 << _OSCCON_PLLODIV_POSITION)
117:                 
118:                 	/******************************************************************************
119:                 	 * Available options for div parameter
120:                 	 *****************************************************************************/
121:                 		// CPU FRC output divisor values - values are mutually exclusive
122:                 		#define OSC_FRC_POST_256 (7 << _OSCCON_FRCDIV_POSITION)
123:                 		#define OSC_FRC_POST_64  (6 << _OSCCON_FRCDIV_POSITION)
124:                 		#define OSC_FRC_POST_32  (5 << _OSCCON_FRCDIV_POSITION)
125:                 		#define OSC_FRC_POST_16  (4 << _OSCCON_FRCDIV_POSITION)
126:                 		#define OSC_FRC_POST_8   (3 << _OSCCON_FRCDIV_POSITION)
127:                 		#define OSC_FRC_POST_4   (2 << _OSCCON_FRCDIV_POSITION)
128:                 		#define OSC_FRC_POST_2   (1 << _OSCCON_FRCDIV_POSITION)
129:                 		#define OSC_FRC_POST_1   (0 << _OSCCON_FRCDIV_POSITION)
130:                 	/***********************************
131:                 	 * End parameter values
132:                 	 ************************************/
133:                 
134:                 #if (((__PIC32_FEATURE_SET__ >= 100) && (__PIC32_FEATURE_SET__ <= 299)) || \
135:                     (__PIC32_FEATURE_SET__ == 330) || (__PIC32_FEATURE_SET__ == 350) || (__PIC32_FEATURE_SET__ == 370) || (__PIC32_FEATURE_SET__ == 430) || (__PIC32_FEATURE_SET__ == 450) || (__PIC32_FEATURE_SET__ == 470))
136:                 	
137:                 		// Reference Oscillator Source Select bits - values are mutually exclusive
138:                 	#define OSC_REFOCON_REFCLKI	 	(7 << _REFOCON_ROSEL_POSITION )
139:                 	#define OSC_REFOCON_SYSPLL 		(7 << _REFOCON_ROSEL_POSITION )
140:                 	#define OSC_REFOCON_USBPLL 		(6 << _REFOCON_ROSEL_POSITION )
141:                 	#define OSC_REFOCON_SOSC        (5 << _REFOCON_ROSEL_POSITION )
142:                 	#define OSC_REFOCON_LPRC        (4 << _REFOCON_ROSEL_POSITION )
143:                 	#define OSC_REFOCON_FRC 		(3 << _REFOCON_ROSEL_POSITION )
144:                 	#define OSC_REFOCON_POSC        (2 << _REFOCON_ROSEL_POSITION )
145:                 	#define OSC_REFOCON_PBCLK 		(1 << _REFOCON_ROSEL_POSITION )
146:                 	#define OSC_REFOCON_SYSCLK      (0 << _REFOCON_ROSEL_POSITION )
147:                 		
148:                 	typedef enum
149:                 	{		
150:                 		OSC_REFOCON_RLSPEN		=(1 << _REFOCON_RSLP_POSITION )	,
151:                 		OSC_REFOCON_OE			=(1 << _REFOCON_OE_POSITION ),
152:                 		OSC_REFOCON_SIDLEN		=(1 << _REFOCON_SIDL_POSITION ),
153:                 		OSC_REFOCON_ON			=(1 << _REFOCON_ON_POSITION )
154:                 	} OSCREFConfigFlags;
155:                 	
156:                 	void OSCREFConfig(unsigned long int source, OSCREFConfigFlags config, unsigned long int div);
157:                 	 
158:                 
159:                 	#define mOSCREFOTRIMSet(trim) 		(REFOTRIM = (trim << _REFOTRIM_ROTRIM_POSITION))
160:                 
161:                 #endif
162:                 
163:                 	 
164:                 	 
165:                 	 
166:                 /*********************************************************************
167:                  * Function:    OSCSetPBDIV(unsigned int oscPbDiv)
168:                  *
169:                  * Description:	Configures peripheral bus divisor
170:                  *
171:                  * PreCondition: oscPbDiv one of the OSC_PB_DIV_X valid values
172:                  *
173:                  * Inputs:    oscPbDiv - desired PB divider
174:                  *
175:                  * Output:      None
176:                  *
177:                  * Example:   OSCSetPBDIV(  OSC_PB_DIV_8 )
178:                  *
179:                  ********************************************************************/
180:                 extern inline void __attribute__((always_inline)) OSCSetPBDIV(unsigned int oscPbDiv)
181:                 {
182:                 	unsigned int dma_status;
183:                 	unsigned int int_status;
184:                 	__OSCCONbits_t oscBits;
185:                 
186:                 	mSYSTEMUnlock(int_status, dma_status);
9D000178  0F400E14   JAL INTDisableInterrupts
9D00017C  00000000   NOP
9D000180  AFC20038   SW V0, 56(S8)
9D0001D8  AFC20040   SW V0, 64(S8)
9D0001DC  3C02BF81   LUI V0, -16511
9D0001E0  AC40F230   SW ZERO, -3536(V0)
9D0001E4  3C02BF81   LUI V0, -16511
9D0001E8  3C03AA99   LUI V1, -21863
9D0001EC  34636655   ORI V1, V1, 26197
9D0001F0  AC43F230   SW V1, -3536(V0)
9D0001F4  3C02BF81   LUI V0, -16511
9D0001F8  3C035566   LUI V1, 21862
9D0001FC  346399AA   ORI V1, V1, -26198
9D000200  AC43F230   SW V1, -3536(V0)
187:                 	
188:                 	oscBits.w=OSCCON;		// read to be in sync. flush any pending write
9D000204  3C02BF81   LUI V0, -16511
9D000208  8C42F000   LW V0, -4096(V0)
9D00020C  AFC20054   SW V0, 84(S8)
189:                 	oscBits.PBDIV=0;
9D000210  8FC20054   LW V0, 84(S8)
9D000214  7C02A4C4   INS V0, ZERO, 19, 2
9D000218  AFC20054   SW V0, 84(S8)
190:                 	oscBits.w|=oscPbDiv;	
9D00021C  8FC30054   LW V1, 84(S8)
9D000220  8FC20034   LW V0, 52(S8)
9D000224  00621025   OR V0, V1, V0
9D000228  AFC20054   SW V0, 84(S8)
191:                 	OSCCON=oscBits.w;		// write back
9D00022C  8FC30054   LW V1, 84(S8)
9D000230  3C02BF81   LUI V0, -16511
9D000234  AC43F000   SW V1, -4096(V0)
192:                 	oscBits.w=OSCCON;		// make sure the write occurred before returning from this function
9D000238  3C02BF81   LUI V0, -16511
9D00023C  8C42F000   LW V0, -4096(V0)
9D000240  AFC20054   SW V0, 84(S8)
193:                 	
194:                 	mSYSTEMLock(int_status, dma_status);
9D000244  3C02BF81   LUI V0, -16511
9D000248  3C033333   LUI V1, 13107
9D00024C  34633333   ORI V1, V1, 13107
9D000250  AC43F230   SW V1, -3536(V0)
9D000254  8FC20040   LW V0, 64(S8)
9D000258  AFC20044   SW V0, 68(S8)
9D0002CC  8FC40038   LW A0, 56(S8)
9D0002D0  0F400DF7   JAL INTRestoreInterrupts
9D0002D4  00000000   NOP
195:                 }
196:                 
197:                 #define		mOSCSetPBDIV		OSCSetPBDIV		// backward compatibility
198:                 
199:                 
200:                 
201:                 	/******************************************************************************
202:                 	 * Available options for config parameter
203:                 	 *****************************************************************************/
204:                 		// CPU Peripheral Bus divisor values - values are mutually exclusive
205:                 		#define OSC_PB_DIV_8    (3 << _OSCCON_PBDIV_POSITION)
206:                 		#define OSC_PB_DIV_4    (2 << _OSCCON_PBDIV_POSITION)
207:                 		#define OSC_PB_DIV_2    (1 << _OSCCON_PBDIV_POSITION)
208:                 		#define OSC_PB_DIV_1    (0 << _OSCCON_PBDIV_POSITION)
209:                 	/***********************************
210:                 	 * End config parameter values
211:                 	 ************************************/
212:                 
213:                 
214:                 /*********************************************************************
215:                  * Function:    mOSCGetPBDIV()
216:                  *
217:                  * Description:	Reads peripheral bus divisor
218:                  *
219:                  * PreCondition:None
220:                  *
221:                  * Inputs:	  	None
222:                  *
223:                  * Output:      None
224:                  *
225:                  * Example:	  	mOSCGetPBDIV()
226:                  *
227:                  ********************************************************************/
228:                 #define mOSCGetPBDIV() (OSCCONbits.PBDIV)
229:                 
230:                 
231:                 /*********************************************************************
232:                  * Function:    mOSCClockFailStatus()
233:                  *
234:                  * Description:	Returns Clock Fail status. 1 = clock fail, 0 = no clock fail
235:                  *
236:                  * PreCondition: None
237:                  *
238:                  * Inputs:	  	None
239:                  *
240:                  * Output:      None
241:                  *
242:                  * Example:	  	mOSCClockFailStatus()
243:                  *
244:                  ********************************************************************/
245:                 #define mOSCClockFailStatus (OSCCONbits.CF)
246:                 
247:                 
248:                 /*********************************************************************
249:                  * Function:      	mOSCEnableSOSC()
250:                  *
251:                  * Description:	  	Enables the LPRC
252:                  *
253:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
254:                  *
255:                  * Inputs:	  		None
256:                  *
257:                  * Output:        	None
258:                  *
259:                  * Example:	  		mOSCEnableSOSC()
260:                  *
261:                  ********************************************************************/
262:                 #define mOSCEnableSOSC() mSysUnlockOpLock(OSCCONSET = _OSCCON_SOSCEN_MASK)
263:                 
264:                 
265:                 /*********************************************************************
266:                  * Function:      	mOSCDisableSOSC(config)
267:                  *
268:                  * Description:	  	Disables SOSC
269:                  *
270:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
271:                  *
272:                  * Inputs:	  		None
273:                  *
274:                  * Output:        	None
275:                  *
276:                  * Example:	  		mOSCDisableSOSC()
277:                  *
278:                  ********************************************************************/
279:                 #define mOSCDisableSOSC() mSysUnlockOpLock(OSCCONCLR = _OSCCON_SOSCEN_MASK)
280:                 
281:                 
282:                 
283:                 #endif
---  c:/program files/microchip/xc32/v1.32/pic32mx/include/peripheral/dma_5xx_6xx_7xx.h  ----------------
1:                   /*********************************************************************
2:                    *
3:                    *                  DMA API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        Dma.h
7:                    * Dependencies:	xc.h
8:                    * 					int.h
9:                    *
10:                   * Processor:       PIC32
11:                   *
12:                   * Complier:        MPLAB C32
13:                   *                  MPLAB IDE
14:                   * Company:         Microchip Technology Inc.
15:                   *
16:                   * Software License Agreement
17:                   *
18:                   * The software supplied herewith by Microchip Technology Incorporated
19:                   * (the ?Company?) for its PIC32/PIC24F Microcontroller is intended
20:                   * and supplied to you, the Company?s customer, for use solely and
21:                   * exclusively on Microchip PIC32/PIC24F Microcontroller products.
22:                   * The software is owned by the Company and/or its supplier, and is
23:                   * protected under applicable copyright laws. All rights are reserved.
24:                   * Any use in violation of the foregoing restrictions may subject the
25:                   * user to criminal sanctions under applicable laws, as well as to
26:                   * civil liability for the breach of the terms and conditions of this
27:                   * license.
28:                   *
29:                   * THIS SOFTWARE IS PROVIDED IN AN ?AS IS? CONDITION. NO WARRANTIES,
30:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
31:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
32:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
33:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
34:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
35:                   *
36:                   *
37:                   * $Id: Dma.h,v 1.9 2007/01/17 21:35:46 C12878 Exp $
38:                   * $Name:  $
39:                   *
40:                   ********************************************************************/
41:                  
42:                  #ifndef _DMA_H_
43:                  #define _DMA_H_
44:                  
45:                  #include <xc.h>
46:                  
47:                  /*
48:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file, 
49:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.  
50:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
51:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
52:                  */
53:                  #ifndef _SUPPRESS_PLIB_WARNING
54:                  #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
55:                  #endif
56:                  
57:                  
58:                  // DMA definitions
59:                  
60:                  #ifdef _DMAC0
61:                  	#define _DMA_CHANNELS		// DMA channels exist
62:                  
63:                  
64:                  // existent DMA channels
65:                  	typedef enum
66:                  	{
67:                  		DMA_CHANNEL0,
68:                  	#ifdef _DMAC1
69:                  		DMA_CHANNEL1,
70:                  	#ifdef _DMAC2
71:                  		DMA_CHANNEL2,
72:                  	#ifdef _DMAC3
73:                  		DMA_CHANNEL3,
74:                  	#ifdef _DMAC4
75:                  		DMA_CHANNEL4,
76:                  	#ifdef _DMAC5
77:                  		DMA_CHANNEL5,
78:                  	#ifdef _DMAC6
79:                  		DMA_CHANNEL6,
80:                  	#ifdef _DMAC7
81:                  		DMA_CHANNEL7,
82:                  	#endif	// _DMAC7
83:                  	#endif	// _DMAC6
84:                  	#endif	// _DMAC5
85:                  	#endif	// _DMAC4
86:                  	#endif	// _DMAC3
87:                  	#endif	// _DMAC2
88:                  	#endif	// _DMAC1
89:                  		//	add/remove DMA channel as needed here
90:                  
91:                  		DMA_CHANNELS	// number of current available channels
92:                  	}DmaChannel;
93:                  
94:                  
95:                  	// Relative Dma channels priority, between each other
96:                  	typedef enum
97:                  	{
98:                  		DMA_CHN_PRI0,
99:                  		DMA_CHN_PRI1,
100:                 		DMA_CHN_PRI2,
101:                 		DMA_CHN_PRI3
102:                 	}DmaChannelPri;
103:                 
104:                 
105:                 
106:                 	// high level definitions for the API functions
107:                 
108:                 	typedef enum
109:                 	{
110:                 		DMA_OPEN_DEFAULT = 0,							        // DMA default operation
111:                 		DMA_OPEN_AUTO	= _DCH0CON_CHAEN_MASK,					// DMA channel is auto enabled
112:                 		DMA_OPEN_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK),	// DMA channel is chained to lower channel
113:                 		DMA_OPEN_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),				// DMA channel is chained to higher channel
114:                 		DMA_OPEN_DET_EN = _DCH0CON_CHAED_MASK,					// events detection enabled while channel off
115:                 		DMA_OPEN_ENABLE = _DCH0CON_CHEN_MASK,					// DMA channel is enabled after open
116:                 		DMA_OPEN_MATCH	= 0x80000000,						    // DMA channel stops on match
117:                 	}DmaOpenFlags;	// flags for the channel open
118:                 
119:                 
120:                 	typedef enum
121:                 	{
122:                 		DMA_EV_ERR =			0x1,		// address error event
123:                 		DMA_EV_ABORT = 			0x2,		// transfer abort event
124:                 		DMA_EV_CELL_DONE =		0x4,		// cell transfer complete event
125:                 		DMA_EV_BLOCK_DONE =		0x8,		// block transfer complete event
126:                 		DMA_EV_DST_HALF =		0x10,		// destination half event
127:                 		DMA_EV_DST_FULL =		0x20,		// destination full event
128:                 		DMA_EV_SRC_HALF =		0x40,		// source half event
129:                 		DMA_EV_SRC_FULL =		0x80,		// source full event
130:                 
131:                 		DMA_EV_ALL_EVNTS=		(DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_CELL_DONE|DMA_EV_BLOCK_DONE|DMA_EV_DST_HALF|
132:                 									DMA_EV_DST_FULL|DMA_EV_SRC_HALF|DMA_EV_SRC_FULL)				// all available events
133:                 	}DmaEvFlags;	// flags for controlling the DMA channel events; Bit fields from the processor header file.
134:                 
135:                 
136:                 	typedef enum
137:                 	{
138:                 		DMA_TXFER_OK,			// the transfer was performed successfully
139:                 		DMA_TXFER_ADD_ERR,		// address error while performing the transfer
140:                 		DMA_TXFER_ABORT,		// the DMA transfer was aborted
141:                 		DMA_TXFER_BC_ERR,		// block complete not set after the DMA transfer performed
142:                 		DMA_TXFER_CC_ERR,		// cell complete not set after the DMA transfer performed
143:                 		DMA_TXFER_TMO			// DMA transfer timeout
144:                 	}DmaTxferRes;		// DMA transfer result
145:                 
146:                 	typedef enum
147:                 	{
148:                 		DMA_WAIT_NOT,		// don't wait for the transfer to complete, return immediately
149:                 		DMA_WAIT_CELL,		// wait for the cell transfer to complete, than return
150:                 		DMA_WAIT_BLOCK		// wait for the block transfer to complete, than return
151:                 	}DmaWaitMode;		// DMA transfer wait mode
152:                 
153:                 	typedef enum
154:                 	{
155:                 		DMA_CHKSUM_CRC,		// LFSR CRC
156:                 		DMA_CHKSUM_IP,		// IP Checksum
157:                 	}DmaChksumType;		// DMA SFM supported checksum types
158:                 
159:                 	typedef enum
160:                 	{
161:                 		DMA_BITO_MSb,		// MSb first (not reflected)
162:                 		DMA_BITO_LSb,		// LSb first (reflected)
163:                 	}DmaBitOrder;		// DMA SFM supported bit ordering
164:                 
165:                 	typedef enum
166:                 	{
167:                 		DMA_REORDER_NOT,	// no reordering, destination matches the source
168:                 		DMA_REORDER_ENDIAN,	// change endianess on word (32 bit) boundaries: LE<->BE
169:                 		DMA_REORDER_SWAP_HALF,	// swap half words (16 bit) within word (32 bit)		
170:                 		DMA_REORDER_SWAP_BYTE,	// swap bytes within half word (16 bit)				
171:                 	}DmaReorderMode;	// DMA SFM supported re-ordering modes
172:                 
173:                 
174:                 	/*********************************************************************
175:                 	 * Function:        void DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags)
176:                 	 *
177:                 	 * PreCondition:    chPri  - valid channel priority, 0-3
178:                 	 *
179:                 	 * Input:           chn    - channel to be configured in the DMA controller
180:                 	 *                  chPri  - the priority given to the channel, 0-3
181:                 	 *                  oFlags - orred flags specifying the open mode:
182:                 	 *                           DMA_OPEN_DEFAULT: DMA default operation mode
183:                 	 *                           DMA_OPEN_AUTO:	DMA channel is auto enabled
184:                 	 *                           DMA_OPEN_CHAIN_LOW: DMA channel is chained to lower channel
185:                 	 *                           DMA_OPEN_CHAIN_HI: DMA channel is chained to higher channel
186:                 	 *                           DMA_OPEN_DET_EN: events detection enabled while channel off
187:                 	 *                           DMA_OPEN_ENABLE: DMA channel is enabled when opened
188:                 	 *                           DMA_OPEN_MATCH:	DMA channel stops on match
189:                 	 *
190:                 	 *
191:                 	 *
192:                 	 * Output:          None
193:                 	 *
194:                 	 * Side Effects:    None
195:                 	 *
196:                 	 * Overview:        The function opens and configures the selected DMA channel using the supplied user flags and priority.
197:                 	 *
198:                 	 * Note:            - This is a high level access function that doesn't give access to all the settings possible for a DMA channel.
199:                 	 *                  Use the low level functions to address special settings.
200:                 	 *                  - The channel is turned off, the pending interrupts are cleared, interrupts are disabled.
201:                 	 *                  After that the channel is configured.
202:                 	 *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
203:                 	 *                  if DMA_OPEN_ENABLE flag was not specified.
204:                 	 *                  - If the CRC is attached to the submitted channel, the CRC append mode will be turned off.
205:                 	 *                  This way, the transfer will occur correctly together with CRC calculation.
206:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
207:                 	 *                  User has to call event channel functions to enable the event flags if needed.
208:                 	 *
209:                 	 * Example:         DmaChnOpen(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_OPEN_AUTO|DMA_OPEN_MATCH|DMA_OPEN_ENABLE);
210:                 	 ********************************************************************/
211:                 	 void			DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags);
212:                 
213:                 	/*********************************************************************
214:                 	 * Function:        void DmaChnEnable(DmaChannel chn)
215:                 	 *
216:                 	 * PreCondition:    None
217:                 	 *
218:                 	 * Input:			chn		- channel to be enabled
219:                 	 *
220:                 	 * Output:          None
221:                 	 *
222:                 	 * Side Effects:    None
223:                 	 *
224:                 	 * Overview:		The function enables a previously configured DMA channel.
225:                 	 *
226:                 	 * Note:            DmaChnOpen()/DmaChnConfigure() should have been called before.
227:                 	 *
228:                 	 * Example:			DmaChnEnable(DMA_CHANNEL3);
229:                 	 ********************************************************************/
230:                 	 void			DmaChnEnable(DmaChannel chn);
231:                 
232:                 	/*********************************************************************
233:                 	 * Function:        void DmaChnDisable(DmaChannel chn)
234:                 	 *
235:                 	 * PreCondition:    None
236:                 	 *
237:                 	 * Input:			chn		- selected channel in the DMA controller
238:                 	 *
239:                 	 * Output:          None
240:                 	 *
241:                 	 * Side Effects:    None
242:                 	 *
243:                 	 * Overview:		The function disables a DMA channel. The channel operation stops.
244:                 	 *
245:                 	 * Note:            None.
246:                 	 *
247:                 	 * Example:			DmaChnDisable(DMA_CHANNEL3);
248:                 	 ********************************************************************/
249:                 	 void			DmaChnDisable(DmaChannel chn);
250:                 
251:                 	/*********************************************************************
252:                 	 * Function:        void DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize)
253:                 	 *
254:                 	 * PreCondition:    chn		- valid DMA channel
255:                 	 * 				- vSrcAdd, vDstAdd	- valid pointers
256:                 	 *                              - 0 < srcSize <= DmaGetMaxTxferSize()
257:                 	 *                              - 0 < dstSize <= DmaGetMaxTxferSize()
258:                 	 *                              - 0 < cellSize <= DmaGetMaxTxferSize()
259:                 	 *
260:                 	 * Input:			chn			- DMA channel number
261:                 	 * 								- vSrcAdd: source of the DMA transfer
262:                 	 * 								- vDstAdd: destination of the DMA transfer
263:                 	 * 								- srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
264:                 	 * 								- dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
265:                 	 * 								- cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
266:                 	 *
267:                 	 * Output:          None
268:                 	 *
269:                 	 * Side Effects:    None
270:                 	 *
271:                 	 * Overview:		The function sets the transfer characteristics for a DMA channel transfer:
272:                 	 * 					the source and the destination addresses.
273:                 	 * 					the source and destination lengths
274:                 	 * 					and the number of bytes	transferred per event.
275:                 	 *
276:                 	 * Note:            The function clears the existing DMA channel event flags.
277:                 	 *                  The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
278:                 	 *
279:                 	 * Example:			DmaChnSetTxfer(DMA_CHANNEL3, &U2RXREG, dstBuff, 1, 200, 1);
280:                 	 ********************************************************************/
281:                 	 void			DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize);
282:                 
283:                 
284:                 	/*********************************************************************
285:                 	 * Function:        void DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd)
286:                 	 *
287:                 	 * PreCondition:    chn		- valid DMA channel
288:                 	 *
289:                 	 * Input:           chn		- DMA channel number
290:                 	 * 				- vSrcAdd: source (virtual) of the DMA transfer
291:                 	 * Output:          None
292:                 	 *
293:                 	 * Side Effects:    None
294:                 	 *
295:                 	 * Overview:        The function is a helper to set directly the transfer source address.
296:                 	 *
297:                 	 * Note:            None.
298:                 	 *
299:                 	 * Example:         DmaChnSetSrcAdd(DMA_CHANNEL2, srcBuff+sizeof(srcBuff));
300:                 	 ********************************************************************/
301:                 	 void			DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd);
302:                 
303:                 	/*********************************************************************
304:                 	 * Function:        void DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd)
305:                 	 *
306:                 	 * PreCondition:    chn		- valid DMA channel
307:                 	 *
308:                 	 * Input:			chn			- DMA channel number
309:                 	 * 								- vDstAdd: destination (virtual) of the DMA transfer
310:                 	 * Output:          None
311:                 	 *
312:                 	 * Side Effects:    None
313:                 	 *
314:                 	 * Overview:		The function is a helper to set directly the transfer destination address.
315:                 	 *
316:                 	 * Note:            None
317:                 	 *
318:                 	 * Example:         DmaChnSetDstAdd(DMA_CHANNEL2, dstBuff+sizeof(dstBuff));
319:                 	 ********************************************************************/
320:                 	 void			DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd);
321:                 
322:                 	/*********************************************************************
323:                 	 * Function:        void DmaChnSetMatchPattern(DmaChannel chn, int pattern)
324:                 	 *
325:                 	 * PreCondition:    chn	- valid DMA channel
326:                 	 *
327:                 	 * Input:			chn		- DMA channel number
328:                 	 * 					pattern	-  the match pattern
329:                 	 *
330:                 	 * Output:          None
331:                 	 *
332:                 	 * Side Effects:    None
333:                 	 *
334:                 	 * Overview:		The function sets the curent match pattern for the selected DMA channel.
335:                 	 *
336:                 	 * Note:            None.
337:                 	 *
338:                 	 * Example:			DmaChnSetMatchPattern(DMA_CHANNEL3, '\r');
339:                 	 ********************************************************************/
340:                 	 void			DmaChnSetMatchPattern(DmaChannel chn, int pattern);
341:                 
342:                 	/*********************************************************************
343:                 	 * Function:        int DmaChnGetMatchPattern(DmaChannel chn)
344:                 	 *
345:                 	 * PreCondition:    chn	- valid DMA channel
346:                 	 *
347:                 	 * Input:			chn		- DMA channel number
348:                 	 *
349:                 	 * Output:          The channel match pattern.
350:                 	 *
351:                 	 * Side Effects:    None
352:                 	 *
353:                 	 * Overview:		The function retrieves the curent match pattern for the selected DMA channel.
354:                 	 *
355:                 	 * Note:            None.
356:                 	 *
357:                 	 * Example:			int pattern=DmaChnGetMatchPattern(DMA_CHANNEL3);
358:                 	 ********************************************************************/
359:                 	 int			DmaChnGetMatchPattern(DmaChannel chn);
360:                 
361:                 	/*********************************************************************
362:                 	 * Function:        DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries)
363:                 	 *
364:                 	 * PreCondition:    chn	- valid DMA channel
365:                 	 *
366:                 	 * Input:			chn		- DMA channel number
367:                 	 * 					wMode	- if DMA_WAIT_NOT, return immediately
368:                 	 * 							- if DMA_WAIT_CELL, return after the cell transfer complete
369:                 	 * 							- if DMA_WAIT_BLOCK, return after the whole transfer is done
370:                 	 * 					retries	- retry counter: if transfer not complete after so many retries, return with tmo.
371:                 	 * 								If 0, wait forever.
372:                 	 *
373:                 	 * Output:          DMA_TXFER_OK if not waiting for the transfer completion or if the transfer ended normally,
374:                 	 * 					an DmaTxferRes error code  otherwise
375:                 	 *
376:                 	 * Side Effects:    None
377:                 	 *
378:                 	 * Overview:		The function initiates (forces) a DMA transfer for the selected DMA channel.
379:                 	 * 					The DMA channel is enabled.
380:                 	 * 					If waiting for the transfer completion needed (user doesn't use an ISR to catch
381:                 	 * 					this event) the function will periodically query the DMA controller for the
382:                 	 * 					transfer completion status.
383:                      * 					If DMA_WAIT_BLOCK is specified and multiple cell transfers are needed to complete
384:                      * 					the block transfer than the function will re-force the transfer for each cell.
385:                 	 *
386:                 	 * Note:            This function can not ne used when the DMA channel is triggerred
387:                      *                  by hardware interrupt requests.
388:                      *                  This is because the transfers are software forced, theere is no
389:                      *                  wait for the occurrence of the hardware trigger. 
390:                 	 *
391:                 	 * Example:         DmaChnStartTxfer(DMA_CHANNEL2, DMA_WAIT_BLOCK, 0);
392:                 	 ********************************************************************/
393:                 	 DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries);
394:                 
395:                 	/*********************************************************************
396:                 	 * Function:        void DmaChnForceTxfer(DmaChannel chn)
397:                 	 *
398:                 	 * PreCondition:    chn	- valid DMA channel
399:                 	 *
400:                 	 * Input:			chn		- DMA channel number
401:                 	 *
402:                 	 * Output:          None
403:                 	 *
404:                 	 * Side Effects:    None
405:                 	 *
406:                 	 * Overview:		The function forces a DMA transfer to occur for the selected DMA channel.
407:                 	 *
408:                 	 * Note:            None.
409:                 	 *
410:                 	 * Example:			DmaChnForceTxfer(DMA_CHANNEL3);
411:                 	 ********************************************************************/
412:                 	 void			DmaChnForceTxfer(DmaChannel chn);
413:                 
414:                 	/*********************************************************************
415:                 	 * Function:        void DmaChnAbortTxfer(DmaChannel chn)
416:                 	 *
417:                 	 * PreCondition:    chn	- valid DMA channel
418:                 	 *
419:                 	 * Input:			chn		- DMA channel number
420:                 	 *
421:                 	 * Output:          None
422:                 	 *
423:                 	 * Side Effects:    None
424:                 	 *
425:                 	 * Overview:		The function aborts a current undergoing DMA transfer for the selected DMA channel.
426:                 	 *
427:                 	 * Note:            None.
428:                 	 *
429:                 	 * Example:			DmaChnAbortTxfer(DMA_CHANNEL3);
430:                 	 ********************************************************************/
431:                 	 void			DmaChnAbortTxfer(DmaChannel chn);
432:                 
433:                 	// High level channel event and interrupt control functions
434:                 
435:                 	/*********************************************************************
436:                 	 * Function:        void DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
437:                 	 *
438:                 	 * PreCondition:    chn	- valid DMA channel
439:                 	 *
440:                 	 * Input:			chn		- DMA channel number
441:                 	 * 					eFlags	- event flags with the following significance:
442:                 	 * 								- DMA_EV_ERR: address error event
443:                 	 * 								- DMA_EV_ABORT: transfer abort event
444:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
445:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
446:                 	 * 								- DMA_EV_DST_HALF: destination half event
447:                 	 * 								- DMA_EV_DST_FULL: destination full event
448:                 	 * 								- DMA_EV_SRC_HALF: source half event
449:                 	 * 								- DMA_EV_SRC_FULL: source full event
450:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
451:                 	 *
452:                 	 * Output:          None
453:                 	 *
454:                 	 * Side Effects:    None
455:                 	 *
456:                 	 * Overview:		The function sets the event enable flags for the selected DMA channel.
457:                 	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
458:                 	 * 					enabled for the selected channel, the other channel event flags won't be touched.
459:                 	 *
460:                 	 * Note:            None.
461:                 	 *
462:                 	 * Example:			DmaChnSetEvEnableFlags(DMA_CHANNEL3, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
463:                 	 ********************************************************************/
464:                 	 void			DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
465:                 
466:                 	/*********************************************************************
467:                 	 * Function:        void DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
468:                 	 *
469:                 	 * PreCondition:    chn	- valid DMA channel
470:                 	 *
471:                 	 * Input:			chn		- DMA channel number
472:                 	 * 					eFlags	- event flags with the following significance:
473:                 	 * 								- DMA_EV_ERR: address error event
474:                 	 * 								- DMA_EV_ABORT: transfer abort event
475:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
476:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
477:                 	 * 								- DMA_EV_DST_HALF: destination half event
478:                 	 * 								- DMA_EV_DST_FULL: destination full event
479:                 	 * 								- DMA_EV_SRC_HALF: source half event
480:                 	 * 								- DMA_EV_SRC_FULL: source full event
481:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
482:                 	 *
483:                 	 * Output:          None
484:                 	 *
485:                 	 * Side Effects:    None
486:                 	 *
487:                 	 * Overview:		The function clears the event enable flags for the selected DMA channel.
488:                 	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
489:                 	 * 					disabled for the selected channel, the other channel event flags won't be touched.
490:                 	 *
491:                 	 * Note:            None.
492:                 	 *
493:                 	 * Example:			DmaChnClrEvEnableFlags(DMA_CHANNEL3, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
494:                 	 ********************************************************************/
495:                 	 void			DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
496:                 
497:                 	/*********************************************************************
498:                 	 * Function:        void DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
499:                 	 *
500:                 	 * PreCondition:    chn	- valid DMA channel
501:                 	 *
502:                 	 * Input:			chn		- DMA channel number
503:                 	 * 					eFlags	- event flags with the following significance:
504:                 	 * 								- DMA_EV_ERR: address error event
505:                 	 * 								- DMA_EV_ABORT: transfer abort event
506:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
507:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
508:                 	 * 								- DMA_EV_DST_HALF: destination half event
509:                 	 * 								- DMA_EV_DST_FULL: destination full event
510:                 	 * 								- DMA_EV_SRC_HALF: source half event
511:                 	 * 								- DMA_EV_SRC_FULL: source full event
512:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
513:                 	 *
514:                 	 * Output:          None
515:                 	 *
516:                 	 * Side Effects:    None
517:                 	 *
518:                 	 * Overview:		The function sets the event enable flags for the selected DMA channel.
519:                 	 * 					The channel event flags are forced to the eFlags value.
520:                 	 *
521:                 	 * Note:            None.
522:                 	 *
523:                 	 * Example:			DmaChnWriteEvEnableFlags(DMA_CHANNEL3, DMA_EV_ALL_EVNTS);
524:                 	 ********************************************************************/
525:                 	 void			DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
526:                 
527:                 	/*********************************************************************
528:                 	 * Function:        DmaEvFlags DmaChnGetEvEnableFlags(DmaChannel chn)
529:                 	 *
530:                 	 * PreCondition:    chn	- valid DMA channel
531:                 	 *
532:                 	 * Input:			chn		- DMA channel number
533:                 	 *
534:                 	 * Output:          - event flags with the following significance:
535:                 	 * 						- DMA_EV_ERR: address error event
536:                 	 * 						- DMA_EV_ABORT: transfer abort event
537:                 	 * 						- DMA_EV_CELL_DONE: cell transfer complete event
538:                 	 * 						- DMA_EV_BLOCK_DONE: block transfer complete event
539:                 	 * 						- DMA_EV_DST_HALF: destination half event
540:                 	 * 						- DMA_EV_DST_FULL: destination full event
541:                 	 * 						- DMA_EV_SRC_HALF: source half event
542:                 	 * 						- DMA_EV_SRC_FULL: source full event
543:                 	 *						- DMA_EV_ALL_EVNTS: all of the above flags
544:                 	 *
545:                 	 * Side Effects:    None
546:                 	 *
547:                 	 * Overview:		The function returns the event enabled flags for the selected DMA channel.
548:                 	 *
549:                 	 * Note:            None.
550:                 	 *
551:                 	 * Example:			DmaEvFlags enabledFlags=DmaChnGetEvEnableFlags(DMA_CHANNEL3);
552:                 	 ********************************************************************/
553:                 	 DmaEvFlags	DmaChnGetEvEnableFlags(DmaChannel chn);
554:                 
555:                 	/*********************************************************************
556:                 	 * Function:        void DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags)
557:                 	 *
558:                 	 * PreCondition:    chn	- valid DMA channel
559:                 	 *
560:                 	 * Input:			chn		- DMA channel number
561:                 	 * 					eFlags	- event flags with the following significance:
562:                 	 * 								- DMA_EV_ERR: address error event
563:                 	 * 								- DMA_EV_ABORT: transfer abort event
564:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
565:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
566:                 	 * 								- DMA_EV_DST_HALF: destination half event
567:                 	 * 								- DMA_EV_DST_FULL: destination full event
568:                 	 * 								- DMA_EV_SRC_HALF: source half event
569:                 	 * 								- DMA_EV_SRC_FULL: source full event
570:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
571:                 	 *
572:                 	 * Output:          None
573:                 	 *
574:                 	 * Side Effects:    None
575:                 	 *
576:                 	 * Overview:		The function clears the event flags for the selected DMA channel.
577:                 	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
578:                 	 * 					cleared for the selected channel, the other channel event flags won't be touched.
579:                 	 *
580:                 	 * Note:            None.
581:                 	 *
582:                 	 * Example:			DmaChnClrEvFlags(DMA_CHANNEL3, DMA_EV_ALL_EVNTS);
583:                 	 ********************************************************************/
584:                 	 void			DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags);
585:                 
586:                 	/*********************************************************************
587:                 	 * Function:        DmaEvFlags DmaChnGetEvFlags(DmaChannel chn)
588:                 	 *
589:                 	 * PreCondition:    chn	- valid DMA channel
590:                 	 *
591:                 	 * Input:			chn		- DMA channel number
592:                 	 *
593:                 	 * Output:          event flags with the following significance:
594:                 	 * 						- DMA_EV_ERR: address error event
595:                 	 * 						- DMA_EV_ABORT: transfer abort event
596:                 	 * 						- DMA_EV_CELL_DONE: cell transfer complete event
597:                 	 * 						- DMA_EV_BLOCK_DONE: block transfer complete event
598:                 	 * 						- DMA_EV_DST_HALF: destination half event
599:                 	 * 						- DMA_EV_DST_FULL: destination full event
600:                 	 * 						- DMA_EV_SRC_HALF: source half event
601:                 	 * 						- DMA_EV_SRC_FULL: source full event
602:                 	 * 						- DMA_EV_ALL_EVNTS: all of the above flags
603:                 	 *
604:                 	 * Side Effects:    None
605:                 	 *
606:                 	 * Overview:		The function returns the event flags for the selected DMA channel.
607:                 	 *
608:                 	 * Note:            None.
609:                 	 *
610:                 	 * Example:			DmaEvFlags intSetFlags=DmaChnGetEvFlags(DMA_CHANNEL3);
611:                 	 ********************************************************************/
612:                 	 DmaEvFlags	DmaChnGetEvFlags(DmaChannel chn);
613:                 
614:                 
615:                 	// high level helpers for fast strcpy/memcpy transfers
616:                 
617:                 	/*********************************************************************
618:                 	 * Function:        DmaTxferRes DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri)
619:                 	 *
620:                 	 * PreCondition:    chn		- a valid DMA channel
621:                 	 * 					s1, s2	- valid memory pointers
622:                 	 * 					n>0, n<=DmaGetMaxTxferSize()
623:                 	 *
624:                 	 * Input:			s1		- destination pointer
625:                 	 * 					s2		- source pointer
626:                 	 * 					n		- number of bytes to transfer
627:                 	 * 					chn		- the DMA channel to perform the transfer
628:                 	 * 					chPri	- the desired channel priority
629:                 	 *
630:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
631:                 	 * 					an DmaTxferRes error code  otherwise
632:                 	 *
633:                 	 * Side Effects:    None
634:                 	 *
635:                 	 * Overview:		The function configures a DMA channel for a fast memory transfer.
636:                 	 * 			Then it copies one block of memory from source to destination.
637:                 	 *
638:                 	 *
639:                 	 * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
640:                 	 *                    This way, the transfer will occur correctly together with checksum calculation.
641:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
642:                 	 *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
643:                 	 *                  - The function clears the suspend state and resumes the operation of the DMA controller.
644:                 	 *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
645:                 	 *
646:                  	 * Example:		res=DmaChnMemcpy(pDst, pSrc, buffSz, DMA_CHANNEL0, DMA_CHN_PRI3);
647:                  	 ********************************************************************/
648:                 	 DmaTxferRes	DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri);
649:                 
650:                 	/*********************************************************************
651:                 	 * Function:        DmaTxferRes DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri)
652:                 	 *
653:                 	 * PreCondition:    chn		- a valid DMA channel
654:                 	 * 					s1, s2	- valid memory pointers
655:                 	 *
656:                 	 * Input:			s1		- destination pointer
657:                 	 * 					s2		- source pointer
658:                 	 * 					chn		- the DMA channel to perform the transfer
659:                 	 * 					chPri	- the desired channel priority
660:                 	 *
661:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
662:                 	 * 					an DmaTxferRes error code  otherwise
663:                 	 *
664:                 	 * Side Effects:    None
665:                 	 *
666:                 	 * Overview:		The function configures a DMA channel for a fast memory transfer.
667:                 	 * 			Then it copies one zero terminated string from source to destination.
668:                 	 *
669:                 	 *
670:                 	 * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
671:                 	 *                    This way, the transfer will occur correctly together with checksum calculation.
672:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
673:                 	 *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
674:                 	 *                  - The function clears the suspend state and resumes the operation of the DMA controller.
675:                 	 *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
676:                 	 *
677:                 	 *
678:                  	 * Example:		res=DmaChnStrcpy(str1, str2, DMA_CHANNEL1, DMA_CHN_PRI3);
679:                 	 *********************************************************************/
680:                 	 DmaTxferRes	DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri);
681:                 
682:                 	/*********************************************************************
683:                 	 * Function:        DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri)
684:                 	 *
685:                 	 * PreCondition:    chn		- a valid DMA channel
686:                 	 * 				- s1, s2	- valid memory pointers
687:                 	 *                              - 0 < n <= DmaGetMaxTxferSize()
688:                 	 *
689:                 	 * Input:			s1		- destination pointer
690:                 	 * 					s2		- source pointer
691:                 	 * 					n	- max number of bytes to transfer
692:                 	 * 					chn		- the DMA channel to perform the transfer
693:                 	 * 					chPri	- the desired channel priority
694:                 	 *
695:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
696:                 	 * 					an DmaTxferRes error code  otherwise
697:                 	 *
698:                 	 * Side Effects:    None
699:                 	 *
700:                 	 * Overview:		The function configures a DMA channel for a fast memory transfer.
701:                 	 * 			Then it copies one zero terminated string from source to destination.
702:                 	 * 			It copies no more than n characters from s2.
703:                 	 *
704:                 	 *
705:                 	 * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
706:                 	 *                    This way, the transfer will occur correctly together with checksum calculation.
707:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
708:                 	 *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
709:                 	 *                  - The function clears the suspend state and resumes the operation of the DMA controller.
710:                 	 *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
711:                 	 *
712:                 	 *
713:                  	 * Example:		res=DmaChnStrncpy(str1, str2, MAX_STR_LEN, DMA_CHANNEL1, DMA_CHN_PRI3);
714:                 	 ********************************************************************/
715:                 	 DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri);
716:                 
717:                 	/*********************************************************************
718:                 	 * Function:        DmaTxferRes DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri)
719:                 	 *
720:                 	 * PreCondition:    chn    - a valid DMA channel
721:                 	 *                  d, s   - valid memory pointer
722:                 	 *                  n>0, n<=DmaGetMaxTxferSize()
723:                 	 *
724:                 	 * Input:           d     - address where to deposit the result
725:                 	 *                  s     - source buffer pointer
726:                 	 *                  n     - number of bytes in the pointer
727:                 	 *                  chn   - the DMA channel to use
728:                 	 *                  chPri - the desired channel priority
729:                 	 * 
730:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
731:                 	 *                  an DmaTxferRes error code  otherwise
732:                 	 *
733:                 	 * Side Effects:    None
734:                 	 *
735:                 	 * Overview:        The function is a helper that calculates the CRC of a memory block.
736:                 	 *                  The function configures the DMA channel for a fast memory transfer and calculates the CRC.
737:                 	 *
738:                 	 *
739:                 	 * Note:            - The CRC generator must have been previously configured using DmaSfmCrcConfigure()
740:                 	 *                  - No transfer is done, just the CRC is calculated.
741:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
742:                 	 *                  - Append mode is enabled and the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
743:                 	 *                  - The checksum type is switched to CRC.
744:                 	 *                  - The way the data is fed into the checksum calculation block is affected by DmaSfmConfigure().
745:                 	 *                  
746:                 	 * Example:          int myCrc; DmaChnMemCrc(&myCrc, srcBuff, sizeof(srcBuff), DMA_CHANNEL2, DMA_CHN_PRI3);
747:                 	 ********************************************************************/
748:                 	 DmaTxferRes	DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri);
749:                 
750:                 	/*********************************************************************
751:                 	 * Function:        DmaTxferRes DmaChnMemChecksum(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri)
752:                 	 *
753:                 	 * PreCondition:    chn    - a valid DMA channel
754:                 	 *                  d, s   - valid memory pointer
755:                 	 *                  n>0, n<=DmaGetMaxTxferSize()
756:                 	 *
757:                 	 * Input:           d     - address where to deposit the result
758:                 	 *                  s     - source buffer pointer
759:                 	 *                  n     - number of bytes in the pointer
760:                 	 *                  chn   - the DMA channel to use
761:                 	 *                  chPri - the desired channel priority
762:                 	 * 
763:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
764:                 	 *                  an DmaTxferRes error code  otherwise
765:                 	 *
766:                 	 * Side Effects:    None
767:                 	 *
768:                 	 * Overview:        The function is a helper that calculates the IP checksum of a memory block.
769:                 	 *                  The function configures the DMA channel for a fast memory transfer and calculates the IP checksum.
770:                 	 *
771:                 	 *
772:                 	 * Note:            - The checksum generator must have been previously seeded using DmaSfmSetSeed()
773:                 	 *                  - No transfer is done, just the checksum is calculated.
774:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
775:                 	 *                  - Append mode is enabled and the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
776:                 	 *                  - The checksum type is switched to IP checksum.
777:                 	 *                  - The way the data is fed into the checksum calculation block is affected by DmaSfmConfigure().
778:                 	 *                  
779:                 	 * Example:          int myChecksum; DmaChnMemChecksum(&myChecksum, srcBuff, sizeof(srcBuff), DMA_CHANNEL1, DMA_CHN_PRI3);
780:                 	 ********************************************************************/
781:                 	 DmaTxferRes	DmaChnMemChecksum(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri);
782:                 
783:                 	// High level Special Function Module (SFM) functions
784:                 
785:                 	/*********************************************************************
786:                 	 * Function:        void DmaSfmConfigure(DmaChksumType cType, DmaBitOrder bitO, DmaReorderMode rMode)
787:                 	 *
788:                 	 * PreCondition:    cType, bitO, rMode - valid values
789:                 	 *
790:                 	 * Input:           cType - checksum type to be calculated: CRC or IP Checksum
791:                 	 *                  bitO  - the bit order to be used MSb or LSb first
792:                 	 *                  rMode - the reordering mode of the bytes when calculating the checksum 
793:                 	 *
794:                 	 * Output:          None
795:                 	 *
796:                 	 * Side Effects:    Whenever the Transfer re-ordering is enabled the rMode setting will influence the destination data layout
797:                 	 *
798:                 	 * Overview:        The function configures the SFM module by setting the parameters that define the behavior:
799:                 	 *                      - the type of the checksum to be calculated (either CRC or IP checksum are supported)
800:                 	 *                      - the bit ordering (how a specific byte is used in the checksum calculation: MSb or LSb first) 
801:                 	 *                      - the data re-ordering (how bytes are re-ordered before calculating the checksum).
802:                 	 *                      All these values affect the way the checksum is calculated.
803:                 	 *
804:                 	 * Note:            None
805:                 	 *
806:                 	 * Example:         DmaSfmConfigure(DMA_CHKSUM_CRC, DMA_BITO_LSb, DMA_REORDER_ENDIAN);
807:                 	 ********************************************************************/
808:                 	extern __inline__ void __attribute__((always_inline)) DmaSfmConfigure(DmaChksumType cType, DmaBitOrder bitO, DmaReorderMode rMode)
809:                 	{
810:                 		DCRCCONCLR=_DCRCCON_CRCTYP_MASK|_DCRCCON_BITO_MASK|_DCRCCON_BYTO_MASK;
811:                 		DCRCCONSET=(cType<<_DCRCCON_CRCTYP_POSITION)|(bitO<<_DCRCCON_BITO_POSITION)|(rMode<<_DCRCCON_BYTO_POSITION);
812:                 	}
813:                 
814:                 	/*********************************************************************
815:                 	 * Function:        void DmaSfmTxferReorder(int enable)
816:                 	 *
817:                 	 * PreCondition:    None
818:                 	 *
819:                 	 * Input:           enable - boolean to enable/disable the re-ordering of the data transfer
820:                 	 *
821:                 	 * Output:          None
822:                 	 *
823:                 	 * Side Effects:    None
824:                 	 *
825:                 	 * Overview:        The function configures the data transfer re-ordering of the SFM module.
826:                 	 *                  If the re-ordering is enabled, the data is read from the source, re-ordered accordingly and then written to the destination.
827:                 	 *                  Otherwise the data is written to the destination un-modified.
828:                 	 *                  The re-ordering is the one specified by the DmaReorderMode parameter in the DmaSfmConfigure() call.
829:                 	 *                  
830:                 	 *
831:                 	 * Note:            - The data transfer re-ordering should be used only for normal (background mode) data transfers.
832:                 	 *                  - In append mode the data transfer re-ordering should not be enabled (undefined behavior)!
833:                 	 *                  - Whenever the data re-ordering is enabled, the transfer should be aligned at both ends (source and destination).
834:                 	 *                    Un-aligned transfers are not supported (undefined behavior)!
835:                 	 *
836:                 	 * Example:         DmaSfmTxferReorder();
837:                 	 ********************************************************************/
838:                 	extern __inline__ void __attribute__((always_inline)) DmaSfmTxferReorder(int enable)
839:                 	{
840:                 		DCRCCONCLR=_DCRCCON_WBO_MASK;
841:                 		DCRCCONSET=(enable<<_DCRCCON_WBO_POSITION);
842:                 	}
843:                 
844:                 
845:                 	 /*********************************************************************
846:                 	 * Function:        void DmaSfmCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
847:                 	 *
848:                 	 * PreCondition:    pLen   - valid polynomial length within 1-32
849:                 	 *
850:                 	 * Input:           polynomial	- the layout of the CRC generator
851:                 	 *                  pLen        - the length of the CRC generator polynomial
852:                 	 *                  seed        - the initial seed of the CRC generator
853:                 	 *
854:                 	 * Output:          None
855:                 	 *
856:                 	 * Side Effects:    None
857:                 	 *
858:                 	 * Overview:        The function configures the SFM CRC module by setting the parameters that define the generator polynomial:
859:                 	 *                  - the length of the CRC generator polynomial, pLen;
860:                 	 *                  - the function sets the layout of the shift stages that take place in the CRC generation.
861:                 	 *                    Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
862:                 	 *                    If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
863:                 	 *                    Note that in a proper CRC polynomial, both the most significant bit (MSb) and least significant bit(LSb)
864:                 	 *                    are always a '1'. Considering the generator polynomial: X^16+X^15+X^2+1, the value to be written as
865:                 	 *                    feedback should be 0x8005, or 0x8004, but not 0x018005;
866:                 	 *                  - the function sets the seed of the CRC generator. This is the initial data present in the
867:                 	 *                   CRC shift register before the CRC calculation begins. A good initial value is usually 0xffffffff.
868:                 	 *
869:                 	 * Note:            - Bit 0 of the generator polynomial is always XOR'ed.
870:                 	 *                  - When the append mode is set, the attached DMA channel has to have destination size <=4.
871:                 	 *                    Upon the transfer completion the calculated CRC is stored at the destination address.
872:                 	 *                  - When append mode is cleared, the DMA transfer occurs normally, and the CRC value is available using
873:                 	 *                    the CrcResult() function.
874:                 	 *                  - The CRC module should be configured before enabled.
875:                 	 *                  - These settings are relevant only when the SFM is configured for the CRC type of checksum.
876:                 	 *                  - The checksum register is the same for CRC or IP checksum mode. Therefore, this function changes also the seed for the IP checksum.
877:                 	 *                  - The way the data is fed into the checksum calculation block and the type of the checksum performed is affected by DmaSfmConfigure().
878:                 	 *
879:                 	 * Example:         DmaSfmCrcConfigure(0x04c11db7, 32, 0xffffffff);
880:                 	 ********************************************************************/
881:                 	extern __inline__ void __attribute__((always_inline)) DmaSfmCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
882:                 	{
883:                 		DCRCCONCLR=_DCRCCON_PLEN_MASK;
884:                 		DCRCCONSET=(pLen-1)<<_DCRCCON_PLEN_POSITION;
885:                 		DCRCDATA=seed;
886:                 		DCRCXOR=polynomial;
887:                 	}
888:                 	
889:                 	#define DmaCrcConfigure	DmaSfmCrcConfigure	// PIC32_3xx backward compatibility name
890:                 
891:                 
892:                 	/*********************************************************************
893:                 	 * Function:        void DmaSfmAttachChannel(DmaChannel chn, int appendMode)
894:                 	 *
895:                 	 * PreCondition:    chn	   - valid DMA channel
896:                 	 *
897:                 	 * Input:           chn         - the DMA channel to be attached to the checksum module.
898:                 	 *                  appendMode	- if TRUE the data passed to the checksum generator is not transferred to destination
899:                 	 *                                but it's written to the destination address when the block transfer is complete.
900:                 	 *                              - if FALSE the data is transferred normally while the checksum is calculated.
901:                 	 *                                The checksum will be available using the DmaSfmChecksum function.
902:                 	 *
903:                 	 * Output:          None
904:                 	 *
905:                 	 * Side Effects:    None
906:                 	 *
907:                 	 * Overview:        The function attaches the SFM checksum module to a DMA channel and enables the checksum generator.
908:                 	 *                  From now on, all the DMA traffic is directed to the SFM checksum generator. Once the DMA block transfer
909:                 	 *                  is complete, the checksum result is available in the checksum data register.
910:                 	 *                  If append mode is enabled, no data transfer takes place but the checksum result will be deposited at the DMA destination address.
911:                 
912:                 	 *
913:                 	 * Note:            If append mode is enabled the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
914:                 	 * 
915:                 	 * Example:         DmaSfmAttachChannel(DMA_CHANNEL0, TRUE);
916:                 	 ********************************************************************/
917:                 	void			DmaSfmAttachChannel(DmaChannel chn, int appendMode);
918:                 	#define			CrcAttachChannel	DmaSfmAttachChannel		// PIC32_3xx backward compatibility name	
919:                 
920:                 	/*********************************************************************
921:                 	 * Function:        unsigned int DmaSfmChecksum(void)
922:                 	 *
923:                 	 * PreCondition:    None
924:                 	 *
925:                 	 * Input:			None
926:                 	 *
927:                 	 * Output:          the current value of the checksum generator.
928:                 	 *
929:                 	 * Side Effects:    None
930:                 	 *
931:                 	 * Overview:		The function returns the calculated checksum value.
932:                 	 *
933:                 	 * Note:            - The function returns the valid checksum result. The masking out the unused MSbits in the checksum register is done by the hardware.
934:                 	 *                  - The way the data is fed into the checksum calculation block and the type of the checksum performed is affected by DmaSfmConfigure().
935:                 	 *
936:                 	 * Example:         unsigned int myChk=DmaSfmChecksum();
937:                 	 ********************************************************************/
938:                 	extern __inline__ int __attribute__((always_inline)) DmaSfmChecksum(void)
939:                 	{
940:                 		return DCRCDATA;
941:                 	}
942:                 	#define		CrcResult	DmaSfmChecksum		// PIC32_3xx backward compatibility name
943:                 	#define		DmaCrcGetValue	DmaSfmChecksum		// PIC32_3xx backward compatibility name 
944:                 
945:                 
946:                 	/*********************************************************************
947:                 	 * Function:        void DmaSfmSetSeed(unsigned int seed)
948:                 	 *
949:                 	 * PreCondition:    None
950:                 	 *
951:                 	 * Input:           seed	- the initial seed of the checksum generator
952:                 	 *
953:                 	 * Output:          None
954:                 	 *
955:                 	 * Side Effects:    None
956:                 	 *
957:                 	 * Overview:        The function sets the seed of the checksum generator. This is the initial data present in the
958:                 	 *                  CRC shift register or the IP checksum calculator before the actual transfer/calculation begins.
959:                 	 *
960:                 	 * Note:            When the SFM is configured for IP checksum mode, only the least significant 16 bits are relevant.
961:                 	 *
962:                 	 * Example:         DmaSfmSetSeed(0xffffffff);
963:                 	 ********************************************************************/
964:                 	extern __inline__ void __attribute__((always_inline)) DmaSfmSetSeed(unsigned int seed)
965:                 	{
966:                 		DCRCDATA=seed;
967:                 	}
968:                 	#define		DmaCrcSetSeed	DmaSfmSetSeed		// PIC32_3xx backward compatibility name
969:                 
970:                 	 
971:                 /*********************  end of high level functions ****************************************/
972:                 
973:                 	// low level definitions for the API functions
974:                 
975:                 
976:                 	typedef struct
977:                 	{
978:                 		union
979:                 		{
980:                 			struct
981:                 			{
982:                 				unsigned int chn:	3;		// last active DMA channel
983:                 				unsigned int rdOp:	1;		// last DMA operation, read if 1, write if 0
984:                 			};
985:                 			unsigned int	w;						// word access
986:                 		}lastAccess;
987:                 		void*	lastAddress;		// most recent DMA address
988:                 	}DmaStatus;			// DMA controller status
989:                 
990:                 	typedef enum
991:                 	{
992:                 		DMA_GFLG_SUSPEND =	_DMACON_SUSPEND_MASK,	// suspend DMA controller operation
993:                 		DMA_GFLG_ON =		_DMACON_ON_MASK,		// DMA module enabled/desabled
994:                 		//
995:                 		DMA_GFLG_ALL_FLAGS=	DMA_GFLG_SUSPEND|DMA_GFLG_ON		// all flags
996:                 	}DmaGlblFlags;	// flags for controlling global DMA controller behavior. From processor header file.
997:                 
998:                 
999:                 
1000:                
1001:                	typedef enum
1002:                	{
1003:                		DMA_EV_ABORT_IRQ_EN =		_DCH0ECON_AIRQEN_MASK,
1004:                		DMA_EV_START_IRQ_EN =		_DCH0ECON_SIRQEN_MASK,
1005:                        // use DMA_EV_START_IRQ() and DMA_EV_ABORT_IRQ() below for selecting
1006:                        // the start and abort IRQ signals
1007:                		DMA_EV_MATCH_EN =			_DCH0ECON_PATEN_MASK,
1008:                
1009:                
1010:                        // compiler use only field
1011:                        _DMA_EV_MAX_MASK =     _DCH0ECON_CHAIRQ_MASK,
1012:                	}DmaEvCtrlFlags;	/*DMA channel event control fields accessible as flags also
1013:                	                	  part of DmaEvCtrlFlags:
1014:                	                	*/
1015:                	#define	DMA_EV_START_IRQ(irq)	(DMA_EV_START_IRQ_EN | ((irq)<<_DCH0ECON_CHSIRQ_POSITION))	// NOTE: irq has to be a symbol from the processor header file
1016:                	#define	DMA_EV_ABORT_IRQ(irq)	(DMA_EV_ABORT_IRQ_EN | ((irq)<<_DCH0ECON_CHAIRQ_POSITION))	// NOTE: irq has to be a symbol from the processor header file
1017:                
1018:                	// DMA channel event control as a structure:
1019:                	#define	DmaEvCtrl	__DCH0ECONbits_t
1020:                
1021:                
1022:                
1023:                
1024:                	typedef enum
1025:                	{
1026:                		DMA_CTL_AUTO_EN =		_DCH0CON_CHAEN_MASK,
1027:                		DMA_CTL_CHAIN_EN =		_DCH0CON_CHCHN_MASK,
1028:                		DMA_CTL_DET_EN =		_DCH0CON_CHAED_MASK,
1029:                		DMA_CTL_CHN_EN =		_DCH0CON_CHEN_MASK,
1030:                		DMA_CTL_CHAIN_DIR =		_DCH0CON_CHCHNS_MASK,
1031:                        // use the DMA_CTL_PRI() below for selecting the DMA
1032:                        // channel priority
1033:                	}DmaChnCtrlFlags;	// controlling the DMA channel with flags
1034:                	// also part of DmaChnCtrlFlags:
1035:                	#define	DMA_CTL_PRI(pri)	((pri)&_DCH0CON_CHPRI_MASK) // DMA Control channel priority
1036:                
1037:                	// DMA channel control as a structure:
1038:                	#define	DmaChnCtrl  	__DCH0CONbits_t
1039:                
1040:                	typedef struct
1041:                	{
1042:                		void*	vSrcAdd;		// source of the DMA transfer, virtual
1043:                		void*	vDstAdd;		// destination of the DMA transfer, virtual
1044:                		int	srcSize;		// source buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
1045:                		int	dstSize;		// destination buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
1046:                		int	cellSize;		// no of bytes txferred per event, 1 to DmaGetMaxTxferSize().
1047:                	}DmaTxferCtrl;		// transfer setting: the transfer source, destination addresses and size, cell size
1048:                
1049:                
1050:                	/********************** low level DMA channel functions *******************************/
1051:                
1052:                
1053:                
1054:                	// Global DMA controller functions
1055:                
1056:                	/*********************************************************************
1057:                	 * Function:        void DmaEnable(int enable)
1058:                	 *
1059:                	 * PreCondition:    None
1060:                	 *
1061:                	 * Input:           enable - boolean to enable/disable the DMA controller
1062:                	 *
1063:                	 * Output:          None
1064:                	 *
1065:                	 * Side Effects:    None
1066:                	 *
1067:                	 * Overview:       The function enables/disables the DMA controller.
1068:                	 *
1069:                	 * Note:           None.
1070:                	 *
1071:                	 * Example:        DmaEnable(1);
1072:                	 ********************************************************************/
1073:                	extern __inline__ void __attribute__((always_inline)) DmaEnable(int enable)
1074:                	{
1075:                		if(enable)
1076:                		{
1077:                			DMACONSET=_DMACON_ON_MASK;
1078:                		}
1079:                		else
1080:                		{
1081:                			DMACONCLR=_DMACON_ON_MASK;
1082:                			while(DMACONbits.ON);		// wait to take effect
1083:                		}
1084:                	}
1085:                
1086:                	/*********************************************************************
1087:                	 * Function:        void DmaReset(void)
1088:                	 *
1089:                	 * PreCondition:    None
1090:                	 *
1091:                	 * Input:		None
1092:                	 *
1093:                	 * Output:          None
1094:                	 *
1095:                	 * Side Effects:    None
1096:                	 *
1097:                	 * Overview:        The function resets the DMA controller.
1098:                	 *
1099:                	 * Note:            None.
1100:                	 *
1101:                	 * Example:        DmaReset();
1102:                	 ********************************************************************/
1103:                	#define            DmaReset()	DmaEnable(0)
1104:                
1105:                
1106:                	/*********************************************************************
1107:                	 * Function:        int DmaSuspend(void)
1108:                	 *
1109:                	 * PreCondition:    None
1110:                	 *
1111:                	 * Input:		None
1112:                	 *
1113:                	 * Output:          true if the DMA was previously suspended, false otherwise
1114:                	 *
1115:                	 *
1116:                	 * Side Effects:    None
1117:                	 *
1118:                	 * Overview:        The function suspends the DMA controller.
1119:                	 *
1120:                	 * Note:            After the execution of this function the DMA operation is supposed to be suspended.
1121:                	 *                  I.e. the function has to wait for the suspension to take place!
1122:                	 *
1123:                	 * Example:         int susp=DmaSuspend();
1124:                	 ********************************************************************/
1125:                        extern __inline__ int __attribute__((always_inline)) DmaSuspend(void)
1126:                	{
1127:                		int suspSt;
1128:                		if(!(suspSt=DMACONbits.SUSPEND))
9D000184  3C02BF88   LUI V0, -16504
9D000188  8C423000   LW V0, 12288(V0)
9D00018C  7C420300   EXT V0, V0, 12, 1
9D000190  304200FF   ANDI V0, V0, 255
9D000194  AFC2003C   SW V0, 60(S8)
9D000198  8FC2003C   LW V0, 60(S8)
9D00019C  2C420001   SLTIU V0, V0, 1
9D0001A0  304200FF   ANDI V0, V0, 255
9D0001A4  1040000B   BEQ V0, ZERO, 0x9D0001D4
9D0001A8  00000000   NOP
9D000268  3C02BF88   LUI V0, -16504
9D00026C  8C423000   LW V0, 12288(V0)
9D000270  7C420300   EXT V0, V0, 12, 1
9D000274  304200FF   ANDI V0, V0, 255
9D000278  AFC20048   SW V0, 72(S8)
9D00027C  8FC20048   LW V0, 72(S8)
9D000280  2C420001   SLTIU V0, V0, 1
9D000284  304200FF   ANDI V0, V0, 255
9D000288  10400010   BEQ V0, ZERO, 0x9D0002CC
9D00028C  00000000   NOP
1129:                		{
1130:                			DMACONSET=_DMACON_SUSPEND_MASK;		// suspend
9D0001AC  3C02BF88   LUI V0, -16504
9D0001B0  24031000   ADDIU V1, ZERO, 4096
9D0001B4  AC433008   SW V1, 12296(V0)
9D000290  3C02BF88   LUI V0, -16504
9D000294  24031000   ADDIU V1, ZERO, 4096
9D000298  AC433008   SW V1, 12296(V0)
1131:                			while((DMACONbits.DMABUSY));	// wait to be actually suspended
9D0001B8  3C02BF88   LUI V0, -16504
9D0001BC  8C423000   LW V0, 12288(V0)
9D0001C0  30420800   ANDI V0, V0, 2048
9D0001C4  0002102B   SLTU V0, ZERO, V0
9D0001C8  304200FF   ANDI V0, V0, 255
9D0001CC  1440FFFA   BNE V0, ZERO, 0x9D0001B8
9D0001D0  00000000   NOP
9D00029C  3C02BF88   LUI V0, -16504
9D0002A0  8C423000   LW V0, 12288(V0)
9D0002A4  30420800   ANDI V0, V0, 2048
9D0002A8  0002102B   SLTU V0, ZERO, V0
9D0002AC  304200FF   ANDI V0, V0, 255
9D0002B0  1440FFFA   BNE V0, ZERO, 0x9D00029C
9D0002B4  00000000   NOP
9D0002B8  0B4000B3   J 0x9D0002CC
9D0002BC  00000000   NOP
1132:                		}
1133:                		return suspSt;
9D0001D4  8FC2003C   LW V0, 60(S8)
1134:                	}
1135:                
1136:                
1137:                
1138:                	/*********************************************************************
1139:                	 * Function:        void DmaResume(int susp)
1140:                	 *
1141:                	 * PreCondition:    None
1142:                	 *
1143:                	 * Input:		the desired DMA suspended state.
1144:                	 *
1145:                	 * Output:          None
1146:                	 *
1147:                	 * Side Effects:    None
1148:                	 *
1149:                	 * Overview:		The function restores the DMA controller activity to the old suspended mode.
1150:                	 *
1151:                	 * Note:            None.
1152:                	 *
1153:                	 * Example:			int isSusp=DmaSuspend(); {....}; DmaResume(isSusp);
1154:                	 ********************************************************************/
1155:                        extern __inline__ void __attribute__((always_inline)) DmaResume(int susp)
1156:                	{
1157:                		if(susp)
9D00025C  8FC20044   LW V0, 68(S8)
9D000260  10400017   BEQ V0, ZERO, 0x9D0002C0
9D000264  00000000   NOP
1158:                		{
1159:                			DmaSuspend();
1160:                		}
1161:                		else
1162:                		{
1163:                			DMACONCLR=_DMACON_SUSPEND_MASK;		// resume DMA activity
9D0002C0  3C02BF88   LUI V0, -16504
9D0002C4  24031000   ADDIU V1, ZERO, 4096
9D0002C8  AC433004   SW V1, 12292(V0)
1164:                		}
1165:                	}
1166:                
1167:                	/*********************************************************************
1168:                	 * Function:        void DmaGetStatus(DmaStatus* pStat)
1169:                	 *
1170:                	 * PreCondition:    pStat	- valid pointer
1171:                	 *
1172:                	 * Input:			pStat	- pointer to a DmaStatus structure to store the current DMA controller
1173:                	 * 							status, carrying the following info:
1174:                	 * 								- chn:	the last active DMA channel
1175:                	 * 								- rdOp: the last DMA operation, read/write
1176:                	 * 								- lastAddress: the most recent DMA address
1177:                	 *
1178:                	 * Output:          None
1179:                	 *
1180:                	 * Side Effects:    None
1181:                	 *
1182:                	 * Overview:		The function updates the info for the current DMA controller status.
1183:                	 * 					It updates the last DMA: operation, channel used and address.
1184:                	 *
1185:                	 * Note:            None.
1186:                	 *
1187:                	 * Example:			DmaStatus stat; DmaGetStatus(&stat);
1188:                	 ********************************************************************/
1189:                	 void			DmaGetStatus(DmaStatus* pStat);
1190:                
1191:                	/*********************************************************************
1192:                	 * Function:        void DmaSetGlobalFlags(DmaGlblFlags gFlags)
1193:                	 *
1194:                	 * PreCondition:    None
1195:                	 *
1196:                	 * Input:           gFlags - flags to be set, having the following fields:
1197:                	 * 			- DMA_GFLG_SUSPEND: DMA controller operation suspend
1198:                	 * 			- DMA_GFLG_ON: DMA controller enabled/desabled
1199:                	 * 			- DMA_GFLG_ALL_FLAGS: all flags
1200:                	 *
1201:                	 * Output:          None
1202:                	 *
1203:                	 * Side Effects:    None
1204:                	 *
1205:                	 * Overview:        The function affects the global behavior of the DMA controller.
1206:                	 *                  It sets the specified flags. Any flag that is set in the gFlags will be
1207:                	 *                  enabled, the other flags won't be touched.
1208:                	 *
1209:                	 * Note:            None.
1210:                	 *
1211:                	 * Example:         DmaSetGlobalFlags(DMA_GFLG_ON);
1212:                	 ********************************************************************/
1213:                        extern __inline__ void __attribute__((always_inline)) DmaSetGlobalFlags(DmaGlblFlags gFlags)
1214:                	{
1215:                		DMACONSET=gFlags;
1216:                	}
1217:                
1218:                	/*********************************************************************
1219:                	 * Function:        void DmaClrGlobalFlags(DmaGlblFlags gFlags)
1220:                	 *
1221:                	 * PreCondition:    None
1222:                	 *
1223:                	 * Input:           gFlags - flags to be cleared, having the following fields:
1224:                	 *                               - DMA_GFLG_SUSPEND: DMA controller operation suspend
1225:                	 *                               - DMA_GFLG_ON: DMA controller enabled/desabled
1226:                	 *                               - DMA_GFLG_ALL_FLAGS: all flags
1227:                	 *
1228:                	 * Output:          None
1229:                	 *
1230:                	 * Side Effects:    None
1231:                	 *
1232:                	 * Overview:        The function affects the global behavior of the DMA controller.
1233:                	 *                  It clears the specified flags. Any flag that is set in the gFlags will be
1234:                	 *                  cleared, the other flags won't be touched.
1235:                	 *
1236:                	 * Note:            None.
1237:                	 *
1238:                	 * Example:         DmaClrGlobalFlags(DMA_GFLG_SUSPEND);
1239:                	 ********************************************************************/
1240:                        extern __inline__ void __attribute__((always_inline)) DmaClrGlobalFlags(DmaGlblFlags gFlags)
1241:                	{
1242:                		DMACONCLR=gFlags;
1243:                	}
1244:                
1245:                
1246:                	/*********************************************************************
1247:                	 * Function:        void DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1248:                	 *
1249:                	 * PreCondition:    None
1250:                	 *
1251:                	 * Input:           gFlags - flags to be set, having the following fields:
1252:                	 *                                 - DMA_GFLG_SUSPEND: DMA controller operation suspend
1253:                	 *                                 - DMA_GFLG_ON: DMA controller enabled/desabled
1254:                	 *                                 - DMA_GFLG_ALL_FLAGS: all flags
1255:                	 *
1256:                	 * Output:          None
1257:                	 *
1258:                	 * Side Effects:    None
1259:                	 *
1260:                	 * Overview:        The function affects the global behavior of the DMA controller.
1261:                	 *                  It forces the flags to have the specified gFlags value.
1262:                	 *
1263:                	 * Note:            None.
1264:                	 *
1265:                	 * Example:         DmaWriteGlobalFlags(DMA_GFLG_ALL_FLAGS);
1266:                	 ********************************************************************/
1267:                        extern __inline__ void __attribute__((always_inline)) DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1268:                	{
1269:                		DMACON=gFlags;
1270:                	}
1271:                
1272:                	/*********************************************************************
1273:                	 * Function:        DmaGlblFlags DmaGetGlobalFlags(void)
1274:                	 *
1275:                	 * PreCondition:    None
1276:                	 *
1277:                	 * Input:           None
1278:                	 *
1279:                	 * Output:          The current DMA controller flags settings.
1280:                	 *                              - DMA_GFLG_SUSPEND: DMA controller operation suspend
1281:                	 *                              - DMA_GFLG_ON: DMA controller enabled/desabled
1282:                	 *
1283:                	 * Side Effects:    None
1284:                	 *
1285:                	 * Overview:        The function returns the global flags of the DMA controller.
1286:                	 *
1287:                	 * Note:            None.
1288:                	 *
1289:                	 * Example:         DmaGlblFlags dmaFlags=DmaGetGlobalFlags();
1290:                	 ********************************************************************/
1291:                        extern __inline__ DmaGlblFlags __attribute__((always_inline)) DmaGetGlobalFlags(void)
1292:                	{
1293:                		return (DmaGlblFlags)DMACON;
1294:                	}
1295:                
1296:                
1297:                	/*********************************************************************
1298:                	 * Function:        int DmaGetMaxTxferSize(void)
1299:                	 *
1300:                	 * PreCondition:    None
1301:                	 *
1302:                	 * Input:           None
1303:                	 *
1304:                	 * Output:          The maximum transfer capacity for a DMA channel, in bytes.
1305:                	 *
1306:                	 * Side Effects:    None
1307:                	 *
1308:                	 * Overview:        The function returns the maximum number of bytes that can be transferred by a DMA channel.
1309:                	 *
1310:                	 * Note:            Revision dependant.
1311:                	 *
1312:                	 * Example:         int dmaMaxSz=DmaGetMaxTxferSize();
1313:                	 ********************************************************************/
1314:                	extern __inline__ int __attribute__((always_inline)) DmaGetMaxTxferSize(void)
1315:                	{
1316:                		return 65536;
1317:                	}
1318:                
1319:                	// Direct Channel control functions
1320:                
1321:                	typedef enum
1322:                	{
1323:                		DMA_CONFIG_DEFAULT = 0,                             // DMA default operation
1324:                		DMA_CONFIG_AUTO	= _DCH0CON_CHAEN_MASK,              // DMA channel is auto enabled
1325:                		DMA_CONFIG_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK),	// DMA channel is chained to lower channel
1326:                		DMA_CONFIG_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),		// DMA channel is chained to higher channel
1327:                		DMA_CONFIG_DET_EN = _DCH0CON_CHAED_MASK,			// events detection enabled while channel off
1328:                		DMA_CONFIG_ENABLE = _DCH0CON_CHEN_MASK,	            // DMA channel is enabled after open
1329:                		DMA_CONFIG_MATCH	= 0x80000000,                   // DMA channel stops on match
1330:                	}DmaConfigFlags;	// flags for the channel configuration
1331:                
1332:                
1333:                
1334:                	/*********************************************************************
1335:                	 * Function:        void DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags)
1336:                	 *
1337:                	 * PreCondition:    chPri  - valid channel priority, 0-3
1338:                	 *
1339:                	 * Input:           chn    - channel to be configured in the DMA controller
1340:                	 *                  chPri  - the priority given to the channel, 0-3
1341:                	 *                  cFlags - orred flags specifying the configuration:
1342:                	 *                           DMA_CONFIG_DEFAULT: DMA default operation mode
1343:                	 *                           DMA_CONFIG_AUTO:	DMA channel is auto enabled
1344:                	 *                           DMA_CONFIG_CHAIN_LOW: DMA channel is chained to lower channel
1345:                	 *                           DMA_CONFIG_CHAIN_HI: DMA channel is chained to higher channel
1346:                	 *                           DMA_CONFIG_DET_EN: events detection enabled while channel off
1347:                	 *                           DMA_CONFIG_ENABLE: DMA channel is enabled when opened
1348:                	 *                           DMA_CONFIG_MATCH:	DMA channel stops on match
1349:                	 *
1350:                	 *
1351:                	 *
1352:                	 * Output:          None
1353:                	 *
1354:                	 * Side Effects:    None
1355:                	 *
1356:                	 * Overview:        The function configures the selected DMA channel using the supplied user flags and priority.
1357:                	 *
1358:                	 * Note:            - The channel is NOT turned off. It should be turned off before calling this function.
1359:                	 *                  The channel is just configured.
1360:                	 *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
1361:                	 *                  if DMA_CONFIG_ENABLE flag was not specified.
1362:                	 *                  - The function does not touch the interrupt flags, interrupt enables, etc.
1363:                	 *                  The interrupt flags should have been previously cleared and interrupts disabled before calling this function.
1364:                	 *                  - The start and abort Irqs, the channel event enable flags are not touched/cleared by this function.
1365:                	 *                  User has to call event channel functions to clear/enable the event flags if needed.
1366:                	 *
1367:                	 * Example:         DmaChnDisable(DMA_CHANNEL2); DmaChnConfigure(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_CONFIG_AUTO|DMA_CONFIG_MATCH|DMA_CONFIG_ENABLE);
1368:                	 ********************************************************************/
1369:                	void			DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags);
1370:                
1371:                
1372:                	/*********************************************************************
1373:                	 * Function:        int DmaChnGetSrcPnt(DmaChannel chn)
1374:                	 *
1375:                	 * PreCondition:    chn	- valid DMA channel
1376:                	 *
1377:                	 * Input:			chn		- DMA channel number
1378:                	 *
1379:                	 * Output:          Current channel source pointer.
1380:                	 *
1381:                	 * Side Effects:    None
1382:                	 *
1383:                	 * Overview:		The function retrieves the current source pointer for the selected DMA channel.
1384:                	 * 					It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the source transfer buffer.
1385:                	 *
1386:                	 * Note:            None
1387:                	 *
1388:                	 * Example:         int srcPnt=DmaChnGetSrcPnt(DMA_CHANNEL3);
1389:                	 ********************************************************************/
1390:                	 int			DmaChnGetSrcPnt(DmaChannel chn);
1391:                
1392:                	/*********************************************************************
1393:                	 * Function:        int DmaChnGetDstPnt(DmaChannel chn)
1394:                	 *
1395:                	 * PreCondition:    chn	- valid DMA channel
1396:                	 *
1397:                	 * Input:			chn		- DMA channel number
1398:                	 *
1399:                	 * Output:          Current channel destination pointer.
1400:                	 *
1401:                	 * Side Effects:    None
1402:                	 *
1403:                	 * Overview:		The function retrieves the current destination pointer for the selected DMA channel.
1404:                	 * 					It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the destination transfer buffer.
1405:                	 *
1406:                	 * Note:            None
1407:                	 *
1408:                	 * Example:			int dstPnt=DmaChnGetDstPnt(DMA_CHANNEL3);
1409:                	 ********************************************************************/
1410:                	 int			DmaChnGetDstPnt(DmaChannel chn);
1411:                
1412:                	/*********************************************************************
1413:                	 * Function:        int DmaChnGetCellPnt(DmaChannel chn)
1414:                	 *
1415:                	 * PreCondition:    chn	- valid DMA channel
1416:                	 *
1417:                	 * Input:			chn		- DMA channel number
1418:                	 *
1419:                	 * Output:          Current channel transfer pointer.
1420:                	 *
1421:                	 * Side Effects:    None
1422:                	 *
1423:                	 * Overview:		The function retrieves the current transfer progress pointer for the selected DMA channel.
1424:                	 * 					It ranges 0 to DmaGetMaxTxferSize()-1.
1425:                	 *
1426:                	 * Note:            None
1427:                	 *
1428:                	 * Example:			int cellPnt=DmaChnGetCellPnt(DMA_CHANNEL3);
1429:                	 ********************************************************************/
1430:                	 int			DmaChnGetCellPnt(DmaChannel chn);
1431:                
1432:                
1433:                
1434:                	/*********************************************************************
1435:                	 * Function:        void DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1436:                	 *
1437:                	 * PreCondition:    chn	- valid DMA channel
1438:                	 *
1439:                	 * Input:			chn			- DMA channel number
1440:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1441:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1442:                	 * 										- SIRQEN: enable/disable the start IRQ action
1443:                	 * 										- PATEN: enable/disable the pattern match and abort
1444:                	 * 									or any of the DmaEvCtrlFlags:
1445:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1446:                	 *
1447:                	 *
1448:                	 * Output:          None
1449:                	 *
1450:                	 * Side Effects:    None
1451:                	 *
1452:                	 * Overview:		The function sets the events that start and abort the transfer
1453:                	 * 					for the selected DMA channel.
1454:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1455:                	 * 					enabled for the selected channel, the other channel event flags won't be touched.
1456:                	 *
1457:                	 * Note:            None.
1458:                	 *
1459:                	 * Example:			either:
1460:                	 * 						DmaChnSetEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN;
1461:                	 * 					or:
1462:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.SIRQEN=1;
1463:                	 * 						DmaChnSetEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1464:                	 *
1465:                	 ********************************************************************/
1466:                	 void			DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1467:                
1468:                
1469:                	/*********************************************************************
1470:                	 * Function:        void DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1471:                	 *
1472:                	 * PreCondition:    chn	- valid DMA channel
1473:                	 *
1474:                	 * Input:			chn			- DMA channel number
1475:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1476:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1477:                	 * 										- SIRQEN: enable/disable the start IRQ action
1478:                	 * 										- PATEN: enable/disable the pattern match and abort
1479:                	 * 									or any of the DmaEvCtrlFlags:
1480:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1481:                	 *
1482:                	 *
1483:                	 * Output:          None
1484:                	 *
1485:                	 * Side Effects:    None
1486:                	 *
1487:                	 * Overview:		The function clears the events that start and abort the transfer
1488:                	 * 					for the selected DMA channel.
1489:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1490:                	 * 					disabled for the selected channel, the other channel event flags won't be touched.
1491:                	 *
1492:                	 * Note:            None.
1493:                	 *
1494:                	 * Example:			either:
1495:                	 * 						DmaChnClrEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN);
1496:                	 * 					or:
1497:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.AIRQEN=1;
1498:                	 * 						DmaChnClrEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1499:                	 *
1500:                	 ********************************************************************/
1501:                	 void			DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1502:                
1503:                
1504:                
1505:                	/*********************************************************************
1506:                	 * Function:        void DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1507:                	 *
1508:                	 * PreCondition:    chn	- valid DMA channel
1509:                	 *
1510:                	 * Input:			chn			- DMA channel number
1511:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1512:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1513:                	 * 										- SIRQEN: enable/disable the start IRQ action
1514:                	 * 										- PATEN: enable/disable the pattern match and abort
1515:                	 * 										- CHSIRQ: IRQ number to start the DMA channel transfer
1516:                	 * 										- CHAIRQ: IRQ number to abort the DMA channel transfer
1517:                	 * 									or any of the DmaEvCtrlFlags:
1518:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1519:                	 *
1520:                	 *
1521:                	 * Output:          None
1522:                	 *
1523:                	 * Side Effects:    None
1524:                	 *
1525:                	 * Overview:		The function writes the events that start and abort the transfer
1526:                	 * 					for the selected DMA channel.
1527:                	 *
1528:                	 * Note:            None.
1529:                	 *
1530:                	 * Example:			either:
1531:                	 * 						DmaChnWriteEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1532:                	 * 					or:
1533:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1534:                	 * 						DmaChnWriteEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1535:                	 *
1536:                	 ********************************************************************/
1537:                	 void			DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1538:                
1539:                
1540:                
1541:                	/*********************************************************************
1542:                	 * Function:        void DmaChnSetEventControl(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1543:                	 *
1544:                	 * PreCondition:    chn	- valid DMA channel
1545:                	 *
1546:                	 * Input:			chn			- DMA channel number
1547:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1548:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1549:                	 * 										- SIRQEN: enable/disable the start IRQ action
1550:                	 * 										- PATEN: enable/disable the pattern match and abort
1551:                	 * 										- CHSIRQ: IRQ number to start the DMA channel transfer
1552:                	 * 										- CHAIRQ: IRQ number to abort the DMA channel transfer
1553:                	 * 									or any of the DmaEvCtrlFlags:
1554:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1555:                	 *
1556:                	 *
1557:                	 * Output:          None
1558:                	 *
1559:                	 * Side Effects:    None
1560:                	 *
1561:                	 * Overview:		The function sets the events that start and abort the transfer
1562:                	 * 					for the selected DMA channel.
1563:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1564:                	 * 					enabled for the selected channel, the other channel event flags won't be touched.
1565:                	 *
1566:                	 * Note:           A shorter name for DmaChnWriteEventControlFlags();
1567:                	 *
1568:                	 * Example:			either:
1569:                	 * 						DmaChnSetEventControl(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1570:                	 * 					or:
1571:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1572:                	 * 						DmaChnSetEventControl(DMA_CHANNEL3, evCtrl.w);
1573:                	 *
1574:                	 ********************************************************************/
1575:                	#define			DmaChnSetEventControl(chn, dmaEvCtrl)	DmaChnWriteEventControlFlags(chn, dmaEvCtrl)
1576:                
1577:                
1578:                	/*********************************************************************
1579:                	 * Function:        DmaEvCtrlFlags DmaChnGetEventControl(DmaChannel chn)
1580:                	 *
1581:                	 * PreCondition:    chn	- valid DMA channel
1582:                	 *
1583:                	 * Input:			chn		- DMA channel number
1584:                	 *
1585:                	 * Output:          - 	either a DmaEvCtrl structure field, carrying the following info:
1586:                	 * 							- AIRQEN: enable/disable the abort IRQ action
1587:                	 * 							- SIRQEN: enable/disable the start IRQ action
1588:                	 * 							- PATEN: enable/disable the pattern match and abort
1589:                	 * 							- CHSIRQ: IRQ number to start the DMA channel transfer
1590:                	 * 							- CHAIRQ: IRQ number to abort the DMA channel transfer
1591:                	 * 						or any of the DmaEvCtrlFlags:
1592:                	 * 							DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1593:                	 *
1594:                	 *
1595:                	 * Side Effects:    None
1596:                	 *
1597:                	 * Overview:		The function retrieves the events that start and abort the transfer
1598:                	 * 					for the selected DMA channel.
1599:                	 *
1600:                	 * Note:            None.
1601:                	 *
1602:                	 * Example:			either:
1603:                	 * 						DmaEvCtrlFlags evCtrlW=DmaChnGetEventControl(DMA_CHANNEL3); if(evCtrlW&DMA_EV_MATCH_EN) {...}
1604:                	 * 					or:
1605:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=DmaChnGetEventControl(DMA_CHANNEL3); if(evCtrl.PATEN){...}
1606:                	 *
1607:                	 ********************************************************************/
1608:                	 DmaEvCtrlFlags	DmaChnGetEventControl(DmaChannel chn);
1609:                
1610:                
1611:                	/*********************************************************************
1612:                	 * Function:        void DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1613:                	 *
1614:                	 * PreCondition:    chn	- valid DMA channel
1615:                	 *
1616:                	 * Input:			chn			- DMA channel number
1617:                	 * 					dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1618:                	 * 										- autoEn: enable/disable the automatic mode
1619:                	 * 										- chainEn: enable/disable channel chaining
1620:                	 * 										- detectEn: enable/disable events detection when channel disabled
1621:                	 * 										- chEn: enable/disable channel functionality
1622:                	 * 										- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1623:                	 * 									or any of the DmaChnCtrlFlags flags:
1624:                	 * 										DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1625:                	 *
1626:                	 * Output:          None
1627:                	 *
1628:                	 * Side Effects:    None
1629:                	 *
1630:                	 * Overview:		The function sets the selected DMA channel control flags:
1631:                	 * 					the chaining or auto mode, and events detection.
1632:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1633:                	 * 					set for the selected channel, the other channel control flags won't be touched.
1634:                	 *
1635:                	 * Note:            None.
1636:                	 *
1637:                	 * Example:			either:
1638:                	 * 						DmaChnSetControlFlags(DMA_CHANNEL3, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1639:                	 * 					or:
1640:                	 * 						DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1641:                	 * 						DmaChnSetControlFlags(DMA_CHANNEL3, chCtrl.w);
1642:                	 *
1643:                	 ********************************************************************/
1644:                	 void			DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1645:                
1646:                	/*********************************************************************
1647:                	 * Function:        void DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1648:                	 *
1649:                	 * PreCondition:    chn	- valid DMA channel
1650:                	 *
1651:                	 * Input:			chn			- DMA channel number
1652:                	 * 					dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1653:                	 * 										- autoEn: enable/disable the automatic mode
1654:                	 * 										- chainEn: enable/disable channel chaining
1655:                	 * 										- detectEn: enable/disable events detection when channel disabled
1656:                	 * 										- chEn: enable/disable channel functionality
1657:                	 * 										- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1658:                	 * 									or any of the DmaChnCtrlFlags flags:
1659:                	 * 										DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1660:                	 *
1661:                	 * Output:          None
1662:                	 *
1663:                	 * Side Effects:    None
1664:                	 *
1665:                	 * Overview:		The function clears the selected DMA channel control flags:
1666:                	 * 					the chaining or auto mode and events detection.
1667:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1668:                	 * 					cleared for the selected channel, the other channel control flags won't be touched.
1669:                	 *
1670:                	 * Note:            None.
1671:                	 *
1672:                	 * Example:			either:
1673:                	 * 						DmaChnClrControlFlags(DMA_CHANNEL3, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1674:                	 * 					or:
1675:                	 * 						DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1676:                	 * 						DmaChnClrControlFlags(DMA_CHANNEL3, chCtrl.w);
1677:                	 *
1678:                	 ********************************************************************/
1679:                	 void			DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1680:                
1681:                	/*********************************************************************
1682:                	 * Function:        void DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1683:                	 *
1684:                	 * PreCondition:    chn	- valid DMA channel
1685:                	 *
1686:                	 * Input:			chn			- DMA channel number
1687:                	 * 					dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1688:                	 * 										- chPri: channel priority 0-3
1689:                	 * 										- autoEn: enable/disable the automatic mode
1690:                	 * 										- chainEn: enable/disable channel chaining
1691:                	 * 										- detectEn: enable/disable events detection when channel disabled
1692:                	 * 										- chEn: enable/disable channel functionality
1693:                	 * 										- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1694:                	 * 									or any of the DmaChnCtrlFlags flags:
1695:                	 * 										DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1696:                	 *
1697:                	 * Output:          None
1698:                	 *
1699:                	 * Side Effects:    None
1700:                	 *
1701:                	 * Overview:		The function enables/disables the selected DMA channel and also sets
1702:                	 * 					the channel priority, chaining mode or auto and events detection.
1703:                	 *
1704:                	 * Note:            None.
1705:                	 *
1706:                	 * Example:			either:
1707:                	 * 						DmaChnWriteControlFlags(DMA_CHANNEL3, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1708:                	 * 					or:
1709:                	 * 						DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1710:                	 * 						DmaChnWriteControlFlags(DMA_CHANNEL3, chCtrl.w);
1711:                	 *
1712:                	 ********************************************************************/
1713:                	 void			DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1714:                
1715:                	/*********************************************************************
1716:                	 * Function:        void DmaChnSetControl(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1717:                	 *
1718:                	 * PreCondition:    chn	- valid DMA channel
1719:                	 *
1720:                	 * Input:	    chn		- DMA channel number
1721:                	 *                  dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1722:                	 * 						- chPri: channel priority 0-3
1723:                	 * 						- autoEn: enable/disable the automatic mode
1724:                	 * 						- chainEn: enable/disable channel chaining
1725:                	 * 						- detectEn: enable/disable events detection when channel disabled
1726:                	 * 						- chEn: enable/disable channel functionality
1727:                	 * 						- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1728:                	 * 					or any of the DmaChnCtrlFlags flags:
1729:                	 * 						DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1730:                	 *
1731:                	 * Output:          None
1732:                	 *
1733:                	 * Side Effects:    None
1734:                	 *
1735:                	 * Overview:        The function enables/disables the selected DMA channel and also sets
1736:                	 * 					the channel priority, chaining mode or auto and events detection.
1737:                	 *
1738:                	 * Note:            Another name ( backward compatible) for DmaChnWriteControlFlags().
1739:                	 *
1740:                	 * Example:         either:
1741:                	 *                      DmaChnSetControl(DMA_CHANNEL3, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1742:                	 *                  or:
1743:                	 *                     	DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1744:                	 * 			DmaChnSetControl(DMA_CHANNEL3, chCtrl.w);
1745:                	 *
1746:                	 ********************************************************************/
1747:                	#define		DmaChnSetControl(chn, dmaChnCtrl)	DmaChnWriteControlFlags(chn, dmaChnCtrl)
1748:                
1749:                	/*********************************************************************
1750:                	 * Function:        DmaChnCtrlFlags DmaChnGetControlFlags(DmaChannel chn)
1751:                	 *
1752:                	 * PreCondition:    chn	- valid DMA channel
1753:                	 *
1754:                	 * Input:			chn			- DMA channel number
1755:                	 *
1756:                	 * Output:          - either a DmaChnCtrl structure field, carrying the following info:
1757:                	 * 							- chPri: channel priority 0-3
1758:                	 * 							- autoEn: enable/disable the automatic mode
1759:                	 * 							- chainEn: enable/disable channel chaining
1760:                	 * 							- detectEn: enable/disable events detection when channel disabled
1761:                	 * 							- chEn: enable/disable channel functionality
1762:                	 * 							- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1763:                	 *						or any of the DmaChnCtrlFlags flags:
1764:                	 *							DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1765:                	 *
1766:                	 * Side Effects:    None
1767:                	 *
1768:                	 * Overview:		The function retrieves the current control settings for the selected DMA channel,
1769:                	 * 					including the channel enable/disable status, the channel priority,
1770:                	 * 					chaining mode, auto mode and events detection.
1771:                	 *
1772:                	 * Note:            None.
1773:                	 *
1774:                	 * Example:			either:
1775:                	 * 						DmaChnCtrlFlags ctrl=DmaChnGetControlFlags(DMA_CHANNEL3); if(ctrl&DMA_CTL_AUTO_EN) {...}
1776:                	 * 					or:
1777:                	 * 						DmaChnCtrl chnCtrl; chnCtrl.w=DmaChnGetControlFlags(DMA_CHANNEL3); if(chnCtrl.autoEn) {...}
1778:                	 *
1779:                	 ********************************************************************/
1780:                	 DmaChnCtrlFlags	DmaChnGetControlFlags(DmaChannel chn);
1781:                
1782:                
1783:                	/*********************************************************************
1784:                	 * Function:        int DmaChnGetEvDetect(DmaChannel chn)
1785:                	 *
1786:                	 * PreCondition:    chn	- valid DMA channel
1787:                	 *
1788:                	 * Input:			chn		- DMA channel number
1789:                	 *
1790:                	 * Output:          TRUE if an DMA event was detected, FALSE otherwise.
1791:                	 *
1792:                	 * Side Effects:    None
1793:                	 *
1794:                	 * Overview:		The function returns the current event detection for the selected DMA channel.
1795:                	 *
1796:                	 * Note:            None.
1797:                	 *
1798:                	 * Example:			int evDetect=DmaChnGetEvDetect(DMA_CHANNEL3);
1799:                	 *
1800:                	 ********************************************************************/
1801:                	 int			DmaChnGetEvDetect(DmaChannel chn);
1802:                
1803:                	/*********************************************************************
1804:                	 * Function:        void DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0)
1805:                	 *
1806:                	 * PreCondition:    chn		- valid DMA channel
1807:                	 * 					pTxCtrl	- valid pointer
1808:                	 *
1809:                	 * Input:			chn			- DMA channel number
1810:                	 * 					pTxCtrl		- pointer to a DmaTxferCtrl that will carry the following info:
1811:                	 * 								- vSrcAdd: source of the DMA transfer
1812:                	 * 								- vDstAdd: destination of the DMA transfer
1813:                	 * 								- srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
1814:                	 * 								- dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
1815:                	 * 								- cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
1816:                	 *					mapToK0		- if TRUE, a Kernel address is mapped to KSeg0, else KSeg1.
1817:                	 *
1818:                	 * Output:          None
1819:                	 *
1820:                	 * Side Effects:    None
1821:                	 *
1822:                	 * Overview:		The function retrieves the transfer characteristics for a DMA channel transfer:
1823:                	 * 					the source and the destination addresses.
1824:                	 * 					It also retrieves the source and destination lengths
1825:                	 * 					and the number of bytes	transferred per event.
1826:                	 *
1827:                	 * Note:            None
1828:                	 *
1829:                	 * Example:			DmaTxferCtrl txCtl; DmaChnGetTxfer(DMA_CHANNEL3, &txCtl, FALSE);
1830:                	 ********************************************************************/
1831:                	 void			DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0);
1832:                
1833:                	// Low level checksum functions
1834:                
1835:                	/*********************************************************************
1836:                	 * Function:        void DmaSfmEnable(int enable)
1837:                	 *
1838:                	 * PreCondition:    None
1839:                	 *
1840:                	 * Input:           enable _ boolean to enable/disable the SFM functionality
1841:                	 *
1842:                	 * Output:          None
1843:                	 *
1844:                	 * Side Effects:    None
1845:                	 *
1846:                	 * Overview:        The function enables/diables the checksum module functionality.
1847:                	 *                  When enabled the attached DMA channel transfers are routed to the SFM module.
1848:                	 *
1849:                	 * Note:            The SFM module should be properly configured before enabled.
1850:                	 *
1851:                	 * Example:         DmaSfmEnable(1);
1852:                	 ********************************************************************/
1853:                	extern __inline__ void __attribute__((always_inline)) DmaSfmEnable(int enable)
1854:                	{
1855:                		if(enable)
1856:                		{
1857:                			DCRCCONSET=_DCRCCON_CRCEN_MASK;
1858:                		}
1859:                		else
1860:                		{
1861:                			DCRCCONCLR=_DCRCCON_CRCEN_MASK;
1862:                		}
1863:                	}
1864:                	#define DmaCrcEnable	DmaSfmEnable		// PIC32_3xx backward compatibility
1865:                
1866:                
1867:                	/*********************************************************************
1868:                	 * Function:        int DmaSfmGetEnable(void)
1869:                	 *
1870:                	 * PreCondition:    None
1871:                	 *
1872:                	 * Input:			None
1873:                	 *
1874:                	 * Output:          TRUE, if the SFM module is enabled
1875:                	 * 		    FALSE otherwise
1876:                	 *
1877:                	 * Side Effects:    None
1878:                	 *
1879:                	 * Overview:		The function returns the SFM module enabling status.
1880:                	 *
1881:                	 * Note:            None
1882:                	 *
1883:                	 * Example:	    int isSfmEnabled=DmaSfmGetEnable();
1884:                	 ********************************************************************/
1885:                	extern __inline__ int __attribute__((always_inline)) DmaSfmGetEnable(void)
1886:                	{
1887:                		return DCRCCONbits.CRCEN!=0;
1888:                	}
1889:                	#define		DmaCrcGetEnable 	DmaSfmGetEnable		// PIC32_3xx backward compatibility
1890:                
1891:                
1892:                	/*********************************************************************
1893:                	 * Function:        void DmaSfmAppendEnable(int enable)
1894:                	 *
1895:                	 * PreCondition:    None
1896:                	 *
1897:                	 * Input:           enable _ boolean to enable/disable the SFM append mode
1898:                	 *
1899:                	 * Output:          None
1900:                	 *
1901:                	 * Side Effects:    None
1902:                	 *
1903:                	 * Overview:        The function enables the SFM append mode. In this mode, the attached DMA channel reads
1904:                	 *                  the source data but does not write it to the destination address. The data it's just passed
1905:                	 *                  to the checksum generator for CRC/IP checksum calculation.
1906:                	 *                  When the block transfer is completed, the checksum result is written to the
1907:                	 *                  DMA channel destination address.
1908:                	 *
1909:                	 * Note:            The SFM module should be properly configured before enabled.
1910:                	 *
1911:                	 * Example:         DmaSfmAppendModeEnable(TRUE);
1912:                	 ********************************************************************/
1913:                	extern __inline__ void __attribute__((always_inline)) DmaSfmAppendEnable(int enable)
1914:                	{
1915:                		if(enable)
1916:                		{
1917:                			DCRCCONSET=_DCRCCON_CRCAPP_MASK;
1918:                		}
1919:                		else
1920:                		{
1921:                			DCRCCONCLR=_DCRCCON_CRCAPP_MASK;
1922:                		}
1923:                	}
1924:                	#define		DmaCrcAppendModeEnable	DmaSfmAppendEnable	// PIC32_3xx backward compatibility
1925:                
1926:                
1927:                	/*********************************************************************
1928:                	 * Function:        int DmaSfmGetAppendMode(void)
1929:                	 *
1930:                	 * PreCondition:    None
1931:                	 *
1932:                	 * Input:           None
1933:                	 *
1934:                	 * Output:          TRUE, if the SFM append mode is enabled
1935:                	 *                  FALSE otherwise
1936:                	 *
1937:                	 * Side Effects:    None
1938:                	 *
1939:                	 * Overview:        The function returns the SFM module enabling status.
1940:                	 *
1941:                	 * Note:            None
1942:                	 *
1943:                	 * Example:         int isAppendEnabled=DmaSfmGetAppendMode();
1944:                	 ********************************************************************/
1945:                	extern __inline__ int __attribute__((always_inline)) DmaSfmGetAppendMode(void)
1946:                	{
1947:                		return DCRCCONbits.CRCAPP!=0;
1948:                	}
1949:                	#define	DmaCrcGetAppendMode	DmaSfmGetAppendMode		// PIC32_3xx backward compatibility
1950:                
1951:                
1952:                	/*********************************************************************
1953:                	 * Function:        void DmaSfmSetAttach(DmaChannel chn)
1954:                	 *
1955:                	 * PreCondition:    chn		- valid DMA channel
1956:                	 *
1957:                	 * Input:           chn	- the DMA channel to be attached to the SFM module (the DMA channel transfers will be routed to the SFM module)
1958:                	 *
1959:                	 * Output:          None
1960:                	 *
1961:                	 * Side Effects:    None
1962:                	 *
1963:                	 * Overview:        The function directly attaches a DMA channel to the SFM module.
1964:                	 *
1965:                	 * Note:            None
1966:                	 *
1967:                	 * Example:         DmaSfmSetAttach(DMA_CHANNEL3);
1968:                	 ********************************************************************/
1969:                	extern __inline__ void __attribute__((always_inline)) DmaSfmSetAttach(DmaChannel chn)
1970:                	{
1971:                		DCRCCONCLR=_DCRCCON_CRCCH_MASK;
1972:                		DCRCCONSET=chn;
1973:                	}
1974:                	#define		DmaCrcSetAttach		DmaSfmSetAttach		// PIC32_3xx backward compatibility
1975:                
1976:                
1977:                	/*********************************************************************
1978:                	 * Function:        DmaChannel DmaSfmGetAttach(void)
1979:                	 *
1980:                	 * PreCondition:    None
1981:                	 *
1982:                	 * Input:           None
1983:                	 *
1984:                	 * Output:          the DMA channel that is currently attached to the CRC module
1985:                	 *
1986:                	 * Side Effects:    None
1987:                	 *
1988:                	 * Overview:        The function returns the DMA channel number that is currently attached to the SFM module.
1989:                	 *
1990:                	 * Note:            None
1991:                	 *
1992:                	 * Example:         DmaChannel chn=DmaSfmGetAttach();
1993:                	 ********************************************************************/
1994:                	extern __inline__ DmaChannel __attribute__((always_inline)) DmaSfmGetAttach(void)
1995:                	{
1996:                		return (DmaChannel)DCRCCONbits.CRCCH;
1997:                	}
1998:                	#define		DmaCrcGetAttach		DmaSfmGetAttach		// PIC32_3xx backward compatibility
1999:                
2000:                	/*********************************************************************
2001:                	 * Function:        void DmaCrcSetPLen(int pLen)
2002:                	 *
2003:                	 * PreCondition:    pLen - valid polynomial length within 1-32
2004:                	 *
2005:                	 * Input:           pLen	- the length of the CRC generator polynomial
2006:                	 *
2007:                	 * Output:          None
2008:                	 *
2009:                	 * Side Effects:    None
2010:                	 *
2011:                	 * Overview:        The length of the CRC generator polynomial is set as being pLen;
2012:                	 *
2013:                	 * Note:            None
2014:                	 *
2015:                	 * Example:         DmaCrcSetPLen(32);
2016:                	 ********************************************************************/
2017:                	extern __inline__ void __attribute__((always_inline)) DmaCrcSetPLen(int pLen)
2018:                	{
2019:                		DCRCCONCLR=_DCRCCON_PLEN_MASK;
2020:                		DCRCCONSET=(pLen)-1;
2021:                	}
2022:                
2023:                	/*********************************************************************
2024:                	 * Function:        int DmaCrcGetPLen(void)
2025:                	 *
2026:                	 * PreCondition:    None
2027:                	 *
2028:                	 * Input:           None
2029:                	 *
2030:                	 * Output:          the length of the CRC generator polynomial
2031:                	 *
2032:                	 * Side Effects:    None
2033:                	 *
2034:                	 * Overview:        The function returns the current length of the CRC generator polynomial.
2035:                	 *                  It's always a number between 1 and 32.
2036:                	 *
2037:                	 * Note:            None
2038:                	 *
2039:                	 * Example:         int polyLen=DmaCrcGetPLen();
2040:                	 ********************************************************************/
2041:                	extern __inline__ int __attribute__((always_inline)) DmaCrcGetPLen(void)
2042:                	{
2043:                		return	DCRCCONbits.PLEN+1; 
2044:                	}
2045:                
2046:                	/*********************************************************************
2047:                	 * Function:        void DmaCrcSetShiftFeedback(unsigned int feedback)
2048:                	 *
2049:                	 * PreCondition:    None
2050:                	 *
2051:                	 * Input:           feedback - the layout of the CRC generator
2052:                	 *
2053:                	 * Output:          None
2054:                	 *
2055:                	 * Side Effects:    None
2056:                	 *
2057:                	 * Overview:        The function sets the layout of the shift stages that take place in the CRC generation.
2058:                	 *                  Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
2059:                	 *                  If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
2060:                	 *
2061:                	 * Note:            Bit 0 of the generator polynomial is always XOR'ed.
2062:                	 *
2063:                	 * Example:         DmaCrcSetShiftFeedback(0x04c11db7);
2064:                	 ********************************************************************/
2065:                	extern __inline__ void __attribute__((always_inline)) DmaCrcSetShiftFeedback(unsigned int feedback)
2066:                	{
2067:                		DCRCXOR=feedback;
2068:                	}
2069:                
2070:                
2071:                	/*********************************************************************
2072:                	 * Function:        unsigned int DmaCrcGetShiftFeedback(void)
2073:                	 *
2074:                	 * PreCondition:    None
2075:                	 *
2076:                	 * Input:           None
2077:                	 *
2078:                	 * Output:          the current layout of the CRC generator
2079:                	 *
2080:                	 * Side Effects:    None
2081:                	 *
2082:                	 * Overview:        The function returns the layout of the shift stages that take place in the CRC generation.
2083:                	 *                  A bit set to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
2084:                	 *                  If a bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
2085:                	 *
2086:                	 * Note:            Bit 0 of the generator polynomial is always XOR'ed.
2087:                	 *
2088:                	 * Example:         int feedback=DmaCrcGetShiftFeedback();
2089:                	 ********************************************************************/
2090:                	extern __inline__ unsigned int __attribute__((always_inline)) DmaCrcGetShiftFeedback(void)
2091:                	{
2092:                		return DCRCXOR;
2093:                	}
2094:                
2095:                
2096:                
2097:                	// Channel test/debug and special functions
2098:                
2099:                	/*********************************************************************
2100:                	 * Function:        void DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags)
2101:                	 *
2102:                	 * PreCondition:    chn	- valid DMA channel
2103:                	 *
2104:                	 * Input:			chn		- DMA channel number
2105:                	 * 					eFlags	- event flags with the following significance:
2106:                	 * 								- DMA_EV_ERR: address error event
2107:                	 * 								- DMA_EV_ABORT: transfer abort event
2108:                	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
2109:                	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
2110:                	 * 								- DMA_EV_DST_HALF: destination half event
2111:                	 * 								- DMA_EV_DST_FULL: destination full event
2112:                	 * 								- DMA_EV_SRC_HALF: source half event
2113:                	 * 								- DMA_EV_SRC_FULL: source full event
2114:                	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
2115:                	 *
2116:                	 * Output:          None
2117:                	 *
2118:                	 * Side Effects:    None
2119:                	 *
2120:                	 * Overview:		The function sets the event flags for the selected DMA channel.
2121:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
2122:                	 * 					set for the selected channel, the other channel event flags won't be touched.
2123:                	 *
2124:                	 * Note:            This is intended as a channel test function.
2125:                	 *
2126:                	 * Example:			DmaChnSetEvFlags(DMA_CHANNEL0, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2127:                	 ********************************************************************/
2128:                	 void			DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2129:                
2130:                	/*********************************************************************
2131:                	 * Function:        void DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags)
2132:                	 *
2133:                	 * PreCondition:    chn	- valid DMA channel
2134:                	 *
2135:                	 * Input:			chn		- DMA channel number
2136:                	 * 					eFlags	- event flags with the following significance:
2137:                	 * 								- DMA_EV_ERR: address error event
2138:                	 * 								- DMA_EV_ABORT: transfer abort event
2139:                	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
2140:                	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
2141:                	 * 								- DMA_EV_DST_HALF: destination half event
2142:                	 * 								- DMA_EV_DST_FULL: destination full event
2143:                	 * 								- DMA_EV_SRC_HALF: source half event
2144:                	 * 								- DMA_EV_SRC_FULL: source full event
2145:                	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
2146:                	 *
2147:                	 * Output:          None
2148:                	 *
2149:                	 * Side Effects:    None
2150:                	 *
2151:                	 * Overview:		The function writes the event flags for the selected DMA channel.
2152:                	 * 					The channel event flags are forced to the eFlags value.
2153:                	 *
2154:                	 * Note:            This is intended as a channel test function.
2155:                	 *
2156:                	 * Example:			DmaChnWriteEvFlags(DMA_CHANNEL0, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2157:                	 ********************************************************************/
2158:                	 void			DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2159:                
2160:                
2161:                	/********************************************************************
2162:                	 * Include legacy DMA functions
2163:                	 * New projects should not use them!
2164:                	 * Note that interrupt functions are no longer provided.
2165:                	 * The functions in the int.h should be used instead.
2166:                	 ********************************************************************/
2167:                	#ifndef _PLIB_DISABLE_LEGACY
2168:                		#include <peripheral/legacy/dma_legacy.h>
2169:                	#endif
2170:                
2171:                
2172:                #else
2173:                	#undef _DMA_CHANNELS		// no DMA channels
2174:                #endif	// _DMAC0
2175:                
2176:                #endif /*_DMA_H_*/
2177:                
2178:                
